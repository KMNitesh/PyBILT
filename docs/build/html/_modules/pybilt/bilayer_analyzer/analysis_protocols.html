

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pybilt.bilayer_analyzer.analysis_protocols &mdash; PyBILT 0.1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> PyBILT
          

          
            
            <img src="../../../_static/PyBILT_logo_b.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html"><em>Py</em>thon based lipid <em>BIL</em>ayer molecular simulation analysis <em>T</em>oolkit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#install">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#quick-overview-of-pybilt">Quick overview of PyBILT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#additional-documentation-tutorials">Additional Documentation/Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#contact">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#contributing">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#license">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#acknowledgments">Acknowledgments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#built-with">Built With</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#core-developers">Core Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ba_analyses.html">Analyses available to the BilayerAnalyzer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">pybilt</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PyBILT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pybilt.bilayer_analyzer.analysis_protocols</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pybilt.bilayer_analyzer.analysis_protocols</h1><div class="highlight"><pre>
<span></span>
<span class="sd">&quot;&quot;&quot;Analysis Protocols</span>

<span class="sd">This is a support module that defines a set of classes used to contruct the &#39;analysis protocol&#39; and the &#39;analysis&#39; used</span>
<span class="sd">in the anlysis implemented by the pybilt.bilayer_analyzer.bilayer_anlayzer.BilayerAnalyzer class.</span>
<span class="sd">The AnalysisProtocol is the class used to organize and initial the the individual analysis functions/protocols. The</span>
<span class="sd">individual analysis functions/protocols are derived classes of AnalysisProtocol, and the availabel analysis can be</span>
<span class="sd">extended by simply defining a new protocol.</span>
<span class="sd">Example:</span>
<span class="sd">    # define a new analysis &#39;my_analysis&#39;</span>
<span class="sd">    # add it to the valid_analysis list</span>
<span class="sd">    valid_analysis.append(&#39;my_analysis&#39;)</span>
<span class="sd">    #add it to analysis_obj_name_dict dictionary with the buildable object (e.g. mda_frame)  needed for the analysis.</span>
<span class="sd">    #The buildables are built by the bilayer analyzer and can accessed from it for the analysisanalysis.</span>
<span class="sd">    analysis_obj_name_dict[&#39;my_analysis&#39;] = &#39;mda_frame&#39;</span>
<span class="sd">    class MyAnalysisProtocol(AnalysisFunctionProtocol):</span>
<span class="sd">        #minimal def the __init__ and run_analysisfuncions</span>
<span class="sd">        def __init__(self, args):</span>
<span class="sd">            #define the initialization</span>
<span class="sd">        #The run_analysis function should always take three inputs</span>
<span class="sd">        #    of data that is passed in from the BilayerAnalayzer instance</span>
<span class="sd">        #    that owns this instance of an analysis protocol. The values are:</span>
<span class="sd">        #       ba_settings = BilayerAnalyzer.settings --&gt; The adjustable</span>
<span class="sd">        #           settings dictionary which contains data like &#39;lateral&#39;, and</span>
<span class="sd">        #           &#39;norm&#39;.</span>
<span class="sd">        #       ba_reps = BilayerAnalyzer.reps --&gt; The dictionary container of</span>
<span class="sd">        #           frame representations. e.g. &#39;com_frame&#39; and &#39;lipid_grid&#39;</span>
<span class="sd">        #       ba_mda_data = BilayerAnalyzer.mda_data --&gt; An MDAData instance</span>
<span class="sd">        #           that contains data like the MDAnalysis universe, trajectory,</span>
<span class="sd">        #           bilayer_selection, etc.</span>
<span class="sd">        def run_analysis(self, ba_settings, ba_reps, ba_mda_data):</span>
<span class="sd">            #.............</span>
<span class="sd">            #doing my analysis</span>
<span class="sd">            #................</span>
<span class="sd">            return</span>

<span class="sd">        #redefine any other functions from AnalysisProtocol or add new ones.</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># imports</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">object</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span> <span class="k">as</span> <span class="nn">scicon</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">range</span>
<span class="c1">#import ast</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">six.moves.cPickle</span> <span class="k">as</span> <span class="nn">pickle</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">cmath</span>
<span class="kn">import</span> <span class="nn">copy</span> <span class="k">as</span> <span class="nn">cp</span>


<span class="c1"># PyBILT imports</span>
<span class="kn">from</span> <span class="nn">pybilt.common.running_stats</span> <span class="k">import</span> <span class="n">RunningStats</span><span class="p">,</span> <span class="n">binned_average</span>
<span class="kn">import</span> <span class="nn">pybilt.mda_tools.mda_density_profile</span> <span class="k">as</span> <span class="nn">mda_dp</span>
<span class="kn">import</span> <span class="nn">pybilt.lipid_grid.lipid_grid_curv</span> <span class="k">as</span> <span class="nn">lgc</span>
<span class="kn">from</span> <span class="nn">pybilt.common</span> <span class="k">import</span> <span class="n">distance_cutoff_clustering</span> <span class="k">as</span> <span class="n">dc_cluster</span>
<span class="kn">from</span> <span class="nn">pybilt.common.distance_cutoff_clustering</span> <span class="k">import</span> <span class="n">distance_euclidean_pbc</span><span class="p">,</span> <span class="n">vector_difference_pbc</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">cdist</span>
<span class="c1">#need some containers for bookkeeping</span>
<span class="n">command_protocols</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">valid_analysis</span><span class="o">=</span> <span class="p">[]</span>
<span class="n">analysis_obj_name_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1"># obj_dict = {&quot;com_frame&quot;:COMFrame}</span>
<span class="c1">#define the buildable objects that are used by the analysisfunctions</span>
<span class="n">use_objects</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mda_frame&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;com_frame&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;lipid_grid&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
    <span class="s2">&quot;vector_frame&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>


<span class="c1"># TO DO:</span>
<span class="c1">#</span>


<div class="viewcode-block" id="word_list_to_string"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.word_list_to_string">[docs]</a><span class="k">def</span> <span class="nf">word_list_to_string</span><span class="p">(</span><span class="n">word_list</span><span class="p">,</span> <span class="n">delimeter</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates a single string from a list of strings</span>

<span class="sd">    This function can be used to combine words in a list into one long sentence</span>
<span class="sd">    string.</span>

<span class="sd">    Args:</span>
<span class="sd">        word_list (list/tuple): A list (or other container) of strings.</span>
<span class="sd">        delimeter (str, Optional): A string to delimit the strings in the list</span>
<span class="sd">            when combining the strings.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span><span class="p">:</span>
        <span class="n">string</span><span class="o">+=</span><span class="n">word</span><span class="o">+</span><span class="n">delimeter</span>
    <span class="n">nchar</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nchar</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<span class="c1">#def _run_analysis_alias(protocol_analyzer):</span>
<span class="c1">#    protocol = protocol_analyzer[0]</span>
<span class="c1">#    protocol.run_analysis(protocol_analyzer[1])</span>
<span class="c1">#    return protocol</span>

<span class="k">def</span> <span class="nf">_run_analysis_alias</span><span class="p">(</span><span class="n">protocol_analyzer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; An alias function to pass to multiprocessing threads</span>

<span class="sd">    This function is used internally in the BilayerAnalyzer.run_analysis_mp</span>
<span class="sd">    function to pass to the multiprocessing threads.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">protocol_analyzer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">protocol_analyzer</span>

<span class="c1"># protocol for the analysis to run during the frame loop</span>
<div class="viewcode-block" id="Analyses"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses">[docs]</a><span class="k">class</span> <span class="nc">Analyses</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class to facilitate analysis of the bilayers via the BilayerAnalyzer</span>

<span class="sd">    This object stores all the analyses that are being performed  by the</span>
<span class="sd">    BilayerAnalyzer class, and it provides functionality to add and remove</span>
<span class="sd">    analyses.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        use_objects (dict): A dictionary of buildable objects that need to be</span>
<span class="sd">            contructed in the BilayerAnalyzer for the analysis defined in this</span>
<span class="sd">            protocol.</span>
<span class="sd">        in_commands (list): A list of the input strings for the analysis to be</span>
<span class="sd">            used.</span>
<span class="sd">        arguments (list): A list of the arguments for analysis.</span>
<span class="sd">        analysis_keys (list): A list of the keys assigned to analysis.</span>
<span class="sd">        command_protocol (dict): A dictionary of the analysis objects.</span>
<span class="sd">        analysis_ids (list): A list of the ids assigned to analysis.</span>
<span class="sd">        n_commands (int): The number of initialized analysis.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_commands</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits Analyses with input analysis_commands</span>

<span class="sd">        Args:</span>
<span class="sd">            analysis_commands (list): A list of the input strings for the</span>
<span class="sd">                analyses to be used. This is internally parsed together by</span>
<span class="sd">                the calling BilayerAnalyzer class object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span> <span class="o">=</span> <span class="n">use_objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_commands</span> <span class="o">=</span> <span class="n">analysis_commands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_commands</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># check analysis</span>

        <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">analysis_commands</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_analysis</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
        <span class="c1"># object dependencies</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="p">[</span><span class="s1">&#39;lipid_grid&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Define the getitem function &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Define the len function &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">)</span>

<div class="viewcode-block" id="Analyses.add_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses.add_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">add_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used to add a new analysis to the internal set of analyses</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (str, list, tuple, or dict): The input to parsed for the</span>
<span class="sd">                type of analysis and its settings to be added to set of</span>
<span class="sd">                analyses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_analysis_from_string</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_analysis_from_list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_analysis_from_dict</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">_add_analysis_from_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parses string inputs. &quot;&quot;&quot;</span>
        <span class="n">command</span> <span class="o">=</span> <span class="n">analysis_string</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">comp_key</span> <span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">comp_id</span> <span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">comp_args</span> <span class="o">=</span> <span class="n">word_list_to_string</span><span class="p">(</span><span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">comp_key</span> <span class="ow">in</span> <span class="n">valid_analysis</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">comp_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
                    <span class="n">comp_object</span> <span class="o">=</span> <span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="n">comp_key</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="p">[</span><span class="n">comp_object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_args</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_id</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_key</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">comp_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">command_protocols</span><span class="p">[</span>
                        <span class="n">comp_key</span><span class="p">](</span><span class="n">comp_args</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;analysisid &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                                       <span class="s2">&quot;has already been used!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_id</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;wrong number of arguments &quot;</span>
                                   <span class="s2">&quot;for analysis </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">command</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;invalid analysisid&quot;</span>
                               <span class="s2">&quot; &#39;</span><span class="si">{}</span><span class="s2">&#39; : </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_key</span><span class="p">,</span> <span class="n">command</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_commands</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_add_analysis_from_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parses list/tuple inputs. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">analysis_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">comp_key</span> <span class="o">=</span> <span class="n">analysis_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">comp_id</span> <span class="o">=</span> <span class="n">analysis_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">comp_args</span> <span class="o">=</span> <span class="n">analysis_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">comp_args</span><span class="p">[</span><span class="s1">&#39;analysis_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp_id</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">comp_key</span> <span class="ow">in</span> <span class="n">valid_analysis</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">comp_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
                    <span class="n">comp_object</span> <span class="o">=</span> <span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="n">comp_key</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="p">[</span><span class="n">comp_object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_args</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_id</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_key</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">comp_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">command_protocols</span><span class="p">[</span>
                        <span class="n">comp_key</span><span class="p">](</span><span class="n">comp_args</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;analysis_id &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                                       <span class="s2">&quot;has already been used!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_id</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;invalid analysis_key &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_key</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;wrong number of arguments in the input list/tuple. Should be three: [a_key, a_id, a_set_dict]&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_commands</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_add_analysis_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parses dict inputs. &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;analysis_key&#39;</span><span class="p">,</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">,</span> <span class="s2">&quot;analysis_settings&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">analysis_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;required key: </span><span class="si">{}</span><span class="s2"> , not in the input dictionary.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="n">comp_key</span> <span class="o">=</span> <span class="n">analysis_dict</span><span class="p">[</span><span class="s1">&#39;analysis_key&#39;</span><span class="p">]</span>
        <span class="n">comp_id</span> <span class="o">=</span> <span class="n">analysis_dict</span><span class="p">[</span><span class="s1">&#39;analysis_id&#39;</span><span class="p">]</span>
        <span class="n">comp_args</span> <span class="o">=</span> <span class="n">analysis_dict</span><span class="p">[</span><span class="s1">&#39;analysis_settings&#39;</span><span class="p">]</span>
        <span class="n">comp_args</span><span class="p">[</span><span class="s1">&#39;analysis_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp_id</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">comp_key</span> <span class="ow">in</span> <span class="n">valid_analysis</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">comp_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
                <span class="n">comp_object</span> <span class="o">=</span> <span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="n">comp_key</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="p">[</span><span class="n">comp_object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_args</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_id</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_key</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">comp_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">command_protocols</span><span class="p">[</span>
                    <span class="n">comp_key</span><span class="p">](</span><span class="n">comp_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;analysisid &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                                   <span class="s2">&quot;has already been used!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_id</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;invalid analysis_key &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_key</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_commands</span><span class="o">+=</span><span class="mi">1</span>

        <span class="k">return</span>

<div class="viewcode-block" id="Analyses.remove_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses.remove_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">remove_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the analysis with the given id from the set of analyses.</span>

<span class="sd">        Args:</span>
<span class="sd">            analysis_id (str): The string analysis_id of the analysis that is</span>
<span class="sd">                to be removed from the internal set of analyses.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">analysis_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">analysis_id</span><span class="p">]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">analysis_id</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_commands</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;no analysis with id &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">analysis_id</span><span class="p">))</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Analyses.remove_all"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses.remove_all">[docs]</a>    <span class="k">def</span> <span class="nf">remove_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Removes all of the analyses from internal set. &quot;&quot;&quot;</span>

        <span class="n">a_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span>
        <span class="k">for</span> <span class="n">a_id</span> <span class="ow">in</span> <span class="n">a_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_analysis</span><span class="p">(</span><span class="n">a_id</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Analyses.print_protocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses.print_protocol">[docs]</a>    <span class="k">def</span> <span class="nf">print_protocol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Prints to std out the protocol of the analyses. &quot;&quot;&quot;</span>

        <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;build objects:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="nb">print</span> <span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;with analysis:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">analysis_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">analysis_id</span><span class="p">]</span><span class="o">.</span><span class="n">print_protocol</span><span class="p">()</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Analyses.dump_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses.dump_data">[docs]</a>    <span class="k">def</span> <span class="nf">dump_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calls the individual save_data functions of each AnalysisProtocol.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, Optional): The string path where output files should be</span>
<span class="sd">                dumped to disc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;dumping analysis data to pickle files...&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">analysis_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;analysis id: </span><span class="si">{}</span><span class="s2"> ---&gt; </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">analysis_id</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">analysis_id</span><span class="p">]</span><span class="o">.</span><span class="n">save_file_name</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">analysis_id</span><span class="p">]</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Analyses.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calls the individual rest functions for each AnalysisProtocol. &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">analysis_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">analysis_id</span><span class="p">]</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span></div></div>

<span class="c1">#base class for analysis protocols</span>
<div class="viewcode-block" id="AnalysisProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol">[docs]</a><span class="k">class</span> <span class="nc">AnalysisProtocol</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for analysis protocols.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        analysis_key (str): The key name of this analysis.</span>
<span class="sd">        analysis_id (str): The unique id assigned to this analyisis.</span>
<span class="sd">        save_file_name (str): The path and filename for the pickle file output of</span>
<span class="sd">            this analysis&#39; results.</span>
<span class="sd">        settings (dict): A dict of the internal settings of the analysis.</span>
<span class="sd">        analysis_output (list or list like): Used to store the ouptut of this</span>
<span class="sd">            analysis during the frame loop.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pickleable</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_short_description</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Inits the AnalysisProtocol using the input args.</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of argument keys and values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;parent analysis protocol&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments</span>
    <span class="k">def</span> <span class="nf">_parse_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parses the setup arguments for this analysis.</span>
<span class="sd">        Args:</span>
<span class="sd">            args (list): List of argument keys and values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print args</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_string</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_dict</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Invalid input structure for arguments/settings to analysis type &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span><span class="p">)</span>
        <span class="k">return</span>
        <span class="c1"># required - a check protocol function which reports relevant settings</span>
    <span class="k">def</span> <span class="nf">_parse_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parses the input arguments from a string. &quot;&quot;&quot;</span>

        <span class="n">arg_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_str_to_dict</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="c1">#type cast setttings if needed</span>
        <span class="n">arg_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cast_settings</span><span class="p">(</span><span class="n">arg_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_dict</span><span class="p">(</span><span class="n">arg_dict</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_parse_str_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts the input argument str to dict. &quot;&quot;&quot;</span>
        <span class="n">arg_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">arg_dict</span><span class="p">[</span><span class="s1">&#39;analysis_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nargs</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">arg_key</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span>  <span class="n">arg_arg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

    <span class="c1"># cast the input string values of settings to appropriate types -- should be overwritten in derived classes to</span>
    <span class="c1"># properly type cast their own settings.</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cast the input arguments from str to the appropriate type (e.g. int).&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">dummy_setting_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

    <span class="k">def</span> <span class="nf">_parse_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parses the input arguments from a dict. &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;analysis_id&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;required key </span><span class="se">\&#39;</span><span class="s2">anlaysis_id</span><span class="se">\&#39;</span><span class="s2"> not assigned in input dict for analysis type: </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span>  <span class="n">arg_arg</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="n">arg_arg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="AnalysisProtocol.short_description"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.short_description">[docs]</a>    <span class="k">def</span> <span class="nf">short_description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the protocols short description.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span></div>

<div class="viewcode-block" id="AnalysisProtocol.pickleable"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.pickleable">[docs]</a>    <span class="k">def</span> <span class="nf">pickleable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether or not the protocol can be pickled.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pickleable</span></div>

<div class="viewcode-block" id="AnalysisProtocol.print_protocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.print_protocol">[docs]</a>    <span class="k">def</span> <span class="nf">print_protocol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prints to std out the internal data and settings for the protocol.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;Analysis: &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;  with analysis_id: </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)))</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;   and settings: &quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;    </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="n">key</span><span class="p">])))</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="AnalysisProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs the analysis that this protocol represents for the current</span>
<span class="sd">        frame in the external BilayerAnalyzer&#39;s run_analysis function.</span>

<span class="sd">        Args:</span>
<span class="sd">            ba_settings (dict): The settings stored in the external</span>
<span class="sd">                BilayerAnalyzer instance.</span>
<span class="sd">            ba_reps (dict): The representation objects stored in the external</span>
<span class="sd">                BilayerAnalyzer instance.</span>
<span class="sd">            ba_mda_data (MDAData instance): The instance of MDAData stored in</span>
<span class="sd">                the external BilayerAnalyzer instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># do some stuff</span>
        <span class="c1"># get an output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span><span class="p">)</span>
        <span class="n">dummy_ba_settings</span> <span class="o">=</span> <span class="n">ba_settings</span>
        <span class="n">dummy_ba_reps</span> <span class="o">=</span> <span class="n">ba_reps</span>
        <span class="n">dummy_ba_mda_data</span> <span class="o">=</span> <span class="n">ba_mda_data</span>
        <span class="c1"># save the output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="AnalysisProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dumps the outputs of this protocol to disc.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, Optional): The string containing the path to the location</span>
<span class="sd">                that the analysis results should be dumped to on disc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">),</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="AnalysisProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the analysis_output of this protocol. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnalysisProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the analysis by resetting the outputs and any necessary</span>
<span class="sd">        internal variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span></div></div>


<span class="c1"># define a new analysis &#39;msd&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;msd&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;msd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="MSDProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDProtocol">[docs]</a><span class="k">class</span> <span class="nc">MSDProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the mean squared displacement from a single time origin.</span>

<span class="sd">    This analysis computes the mean squared displacement (MSD) versus time</span>
<span class="sd">    of the centers of mass of the specified lipids for a single time origin</span>
<span class="sd">    (i.e. the first frame in the trajectory analysis):</span>
<span class="sd">        MSD(t) = &lt;(r(t) - r_0)^2&gt;\_i</span>
<span class="sd">    where the angle brackets denote averaging over all lipids of type i;</span>
<span class="sd">    the lipid type used for the analysis is controlled by the ```leaflet```</span>
<span class="sd">    setting.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;msd&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">            this analysis. Default: &#39;all&#39;, averages over all lipid types.</span>

<span class="sd">    References:</span>
<span class="sd">        1. Preston B. Moore, Carlos F. Lopez, Michael L. Klein, Dynamical</span>
<span class="sd">            Properties of a Hydrated Lipid Bilayer from a Multinanosecond</span>
<span class="sd">            Molecular Dynamics Simulation, Biophysical Journal, Volume 81,</span>
<span class="sd">            Issue 5, 2001, Pages 2484-2494, ISSN 0006-3495,</span>
<span class="sd">            http://dx.doi.org/10.1016/S0006-3495(01)75894-8.</span>
<span class="sd">            (http://www.sciencedirect.com/science/article/pii/S0006349501758948)</span>

<span class="sd">        2. Yoshimichi Andoh, Susumu Okazaki, Ryuichi Ueoka, Molecular</span>
<span class="sd">            dynamics study of lipid bilayers modeling the plasma membranes</span>
<span class="sd">            of normal murine thymocytes and leukemic GRSL cells, Biochimica</span>
<span class="sd">            et Biophysica Acta (BBA) - Biomembranes, Volume 1828, Issue 4,</span>
<span class="sd">            April 2013, Pages 1259-1270, ISSN 0005-2736,</span>
<span class="sd">            https://doi.org/10.1016/j.bbamem.2013.01.005.</span>
<span class="sd">            (http://www.sciencedirect.com/science/article/pii/S0005273613000096)</span>

<span class="sd">        3. Section 8.7,</span>
<span class="sd">            http://manual.gromacs.org/documentation/5.1.4/manual-5.1.4.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Single time origin mean squared displacement.&quot;</span>
    <span class="c1"># self._return_length = 2</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;msd&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;msd_multi&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of MSDProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_time</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>


<div class="viewcode-block" id="MSDProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">leaflet</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">selcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">com_curr</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
            <span class="n">selcoords</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_curr</span><span class="p">[:]</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># initialize a numpy array to hold the msd for the selection</span>
        <span class="n">msd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># initialize a running stats object to do the averaging over resids</span>
        <span class="n">drs_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>

        <span class="n">ref_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>


        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">com_curr</span> <span class="o">=</span> \
                    <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;first_com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                        <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">ref_coords</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_curr</span><span class="p">[:]</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="n">ref_coords</span><span class="p">[:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;first_com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span>
            <span class="c1"># get the current com frame list</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_time</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">50000.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="n">selcoords</span><span class="p">[:]</span>
            <span class="n">ref_coords</span> <span class="o">=</span> <span class="n">selcoords</span><span class="p">[:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_time</span> <span class="o">=</span> <span class="n">tc</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;updating ref_coords at time </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tc</span><span class="p">))</span>
            <span class="c1"># quit()</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">tc</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">selcoords</span> <span class="o">-</span> <span class="n">ref_coords</span>
        <span class="n">drs</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">dr</span>
        <span class="c1"># loop over the selections for this frame</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">drs</span><span class="p">:</span>
            <span class="n">drs_curr</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:]</span>
            <span class="n">drs_mag</span> <span class="o">=</span> <span class="n">drs_curr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">drs_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">drs_mag</span><span class="p">)</span>
        <span class="c1"># get the msd for the current selection</span>
        <span class="n">msdcurr</span> <span class="o">=</span> <span class="n">drs_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">msd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="n">msd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">msdcurr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msd</span><span class="p">)</span>
        <span class="k">return</span></div></div>


<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;msd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSDProtocol</span>

<span class="c1"># define a new analysis &#39;msd&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;msd_multi&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;msd_multi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="MSDMultiProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDMultiProtocol">[docs]</a><span class="k">class</span> <span class="nc">MSDMultiProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the mean squared displacement using multiple time origins.</span>

<span class="sd">    This analysis computes the average mean squared displacement (MSD) of</span>
<span class="sd">    the centers of mass of the specified lipids using multiple time origins</span>
<span class="sd">    and thus multiple time blocks:</span>
<span class="sd">        MSD = &lt;&lt;(r(tau) - r_0)^2&gt;\_i&gt;\_tau</span>
<span class="sd">    where the inner angle brackets denote averaging over all lipids i and</span>
<span class="sd">    the outer brackets denote averaging over all time origins tau. The</span>
<span class="sd">    diffusion coefficient is estimated from the MSD using a simplified</span>
<span class="sd">    version Einstein&#39;s relation:</span>
<span class="sd">        D_i ~ MSD_i/(4.0*tau)</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;msd_multi&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">            this analysis. Default: &#39;all&#39;, averages over all lipid types.</span>
<span class="sd">        n_tau (int): Specify the time block size in number of frames.</span>
<span class="sd">            Default: 50 ( 1000 picoseconds for timestep of 2 fs and frame</span>
<span class="sd">            output ever 100 timesteps).</span>
<span class="sd">        n_sigma (int): Specify the time between origins in number of frames.</span>
<span class="sd">            Default: 50.</span>

<span class="sd">    Note:</span>
<span class="sd">        According to results in Ref 3 the time blocks used to estimate the</span>
<span class="sd">        MSD should not be overlapping. Therefore, it is recommended to use</span>
<span class="sd">        n_sigma &gt;= n_tau.</span>

<span class="sd">    References:</span>
<span class="sd">        1. Christofer Hofsab, Erik Lindahl, and Olle Edholm, &quot;Molecular</span>
<span class="sd">            Dynamics Simulations of Phospholipid Bilayers with Cholesterol&quot;,</span>
<span class="sd">            Biophys J. 2003 Apr; 84(4): 2192-2206.</span>
<span class="sd">            doi:  10.1016/S0006-3495(03)75025-5</span>

<span class="sd">        2. Orsi, Mario, Julien Michel, and Jonathan W. Essex.</span>
<span class="sd">            &quot;Coarse-grain modelling of DMPC and DOPC lipid bilayers.&quot;</span>
<span class="sd">            Journal of Physics: Condensed Matter 22.15 (2010): 155106.</span>
<span class="sd">            http://iopscience.iop.org/article/10.1088/0953-8984/22/15/155106/meta</span>

<span class="sd">        3. Gaurav Pranami and Monica H. Lamm, Estimating Error in Diffusion</span>
<span class="sd">            Coefficients Derived from Molecular Dynamics Simulations,</span>
<span class="sd">            Journal of Chemical Theory and Computation 2015 11 (10),</span>
<span class="sd">            4586-4592, DOI: 10.1021/acs.jctc.5b00574,</span>
<span class="sd">            http://pubs.acs.org/doi/full/10.1021/acs.jctc.5b00574</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Multiple time origin mean squared displacement.&quot;</span>
    <span class="c1"># self._return_length = 2</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;msd_multi&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;msd&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of MSDMultiProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_tau&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tau_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_have_tau</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;n_tau&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;n_sigma&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="MSDMultiProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDMultiProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="c1">#determine the frame intervals</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">leaflet</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">indices</span>
            <span class="c1">#self.analysis_output.append([])</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">selcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">com_curr</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
            <span class="n">selcoords</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_curr</span><span class="p">[:]</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># initialize a running stats object to do the averaging over resids</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ref_coords</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">com_curr</span> <span class="o">=</span> \
                    <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;first_com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                        <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">ref_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">com_curr</span><span class="p">[:])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_coords</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># get the current com frame list</span>
        <span class="c1">#print(self._sigma_counter)</span>
        <span class="c1">#print(type(self.settings[&#39;n_sigma&#39;]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_counter</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_sigma&#39;</span><span class="p">]:</span>
            <span class="c1">#print(&quot;{} {}&quot;.format(self._sigma_counter, self.settings[&#39;n_sigma&#39;]))</span>
            <span class="c1">#print(&quot;{}&quot;.format(self._sigma_counter &lt; self.settings[&#39;n_sigma&#39;]))</span>
            <span class="n">n_blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tau_counter</span><span class="p">,</span> <span class="n">n_blocks</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_tau&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_tau&#39;</span><span class="p">]:</span>
                    <span class="n">drs_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
                    <span class="n">ref_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                    <span class="n">dr</span> <span class="o">=</span> <span class="n">selcoords</span> <span class="o">-</span> <span class="n">ref_coords</span>
                    <span class="n">drs</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">dr</span>
                    <span class="c1"># loop over the selections for this frame</span>
                    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">drs</span><span class="p">:</span>
                        <span class="n">drs_curr</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:]</span>
                        <span class="n">drs_mag</span> <span class="o">=</span> <span class="n">drs_curr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                        <span class="n">drs_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">drs_mag</span><span class="p">)</span>
                    <span class="c1"># get the msd for the current selection</span>
                    <span class="n">msdcurr</span> <span class="o">=</span> <span class="n">drs_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">msdcurr</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tau_counter</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_counter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_sigma&#39;</span><span class="p">]:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ref_coords</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">com_curr</span> <span class="o">=</span> \
                    <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                        <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">ref_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">com_curr</span><span class="p">[:])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_coords</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">n_blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tau_counter</span><span class="p">,</span> <span class="n">n_blocks</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_tau&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_tau&#39;</span><span class="p">]:</span>
                    <span class="n">drs_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
                    <span class="n">ref_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                    <span class="n">dr</span> <span class="o">=</span> <span class="n">selcoords</span> <span class="o">-</span> <span class="n">ref_coords</span>
                    <span class="n">drs</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">dr</span>
                    <span class="c1"># loop over the selections for this frame</span>
                    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">drs</span><span class="p">:</span>
                        <span class="n">drs_curr</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:]</span>
                        <span class="n">drs_mag</span> <span class="o">=</span> <span class="n">drs_curr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                        <span class="n">drs_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">drs_mag</span><span class="p">)</span>
                    <span class="c1"># get the msd for the current selection</span>
                    <span class="n">msdcurr</span> <span class="o">=</span> <span class="n">drs_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">msdcurr</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tau_counter</span><span class="o">+=</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_have_tau</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame_counter</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_counter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_tau&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> \
                    <span class="o">-</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;first_com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_have_tau</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div>
    <span class="k">def</span> <span class="nf">_process_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_output</span><span class="p">):</span>
        <span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">analysis_output</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="c1">#print(analysis_output)</span>
        <span class="n">msd_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">analysis_output</span><span class="p">)</span>
        <span class="n">msd_average</span> <span class="o">=</span> <span class="n">msd_array</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">msd_std_err</span> <span class="o">=</span> <span class="n">msd_array</span><span class="o">.</span><span class="n">std</span><span class="p">()</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">msd_array</span><span class="p">))</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span>
        <span class="n">diffusion_coeff</span> <span class="o">=</span> <span class="n">msd_average</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">tau</span><span class="p">)</span>
        <span class="n">diffusion_coeff_std_err</span> <span class="o">=</span> <span class="n">msd_std_err</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">tau</span><span class="p">)</span>
        <span class="n">analysis_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">msd_average</span><span class="p">,</span> <span class="n">msd_std_err</span><span class="p">,</span>
                                    <span class="n">diffusion_coeff</span><span class="p">,</span> <span class="n">diffusion_coeff_std_err</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">analysis_output</span>

<div class="viewcode-block" id="MSDMultiProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDMultiProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>

        <span class="n">analysis_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">analysis_output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="MSDMultiProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDMultiProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">analysis_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">analysis_output</span></div>

<div class="viewcode-block" id="MSDMultiProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDMultiProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tau_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_have_tau</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span></div></div>

<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;msd_multi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSDMultiProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;apl_box&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;apl_box&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>


<div class="viewcode-block" id="APLBoxProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLBoxProtocol">[docs]</a><span class="k">class</span> <span class="nc">APLBoxProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the area per lipid using the lateral area.</span>

<span class="sd">    This analysis is used to estimate the area per lipid (APL)</span>
<span class="sd">    using the lateral box dimensions,</span>
<span class="sd">        A_l = 2&lt;A_xy&gt;/N_l ,</span>
<span class="sd">    where A_xy is area of the lateral box dimensions (used to approximate the surface area of the bilayer)</span>
<span class="sd">    and N_l is the number of lipids in the bilayer.</span>
<span class="sd">    As a molar quantity this approach is only accurate for</span>
<span class="sd">    homogenous lipid bilayers. If the bilayer is inhomogenous then this</span>
<span class="sd">    estimate represents a composite average of the area per lipid.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;apl_box&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        None</span>

<span class="sd">    References:</span>
<span class="sd">        1. Preston B. Moore, Carlos F. Lopez, Michael L. Klein, Dynamical Properties of a Hydrated Lipid Bilayer</span>
<span class="sd">            from a Multinanosecond Molecular Dynamics Simulation, Biophysical Journal, Volume 81, Issue 5, 2001,</span>
<span class="sd">            Pages 2484-2494, ISSN 0006-3495, http://dx.doi.org/10.1016/S0006-3495(01)75894-8.</span>
<span class="sd">            (http://www.sciencedirect.com/science/article/pii/S0006349501758948)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Area per lipid using box dimensions.&quot;</span>
    <span class="c1"># _return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;apl_box&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;apl_grid&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of APLBoxProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

<div class="viewcode-block" id="APLBoxProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLBoxProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">plane</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.0</span>
        <span class="n">nlipids</span> <span class="o">=</span> <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">n_residues</span>
        <span class="n">apl</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">nlipids</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">apl</span><span class="p">)</span>
        <span class="n">apl_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">apl</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">apl_t</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="APLBoxProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLBoxProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;apl_box&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">APLBoxProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;bilayer_thickness&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;bilayer_thickness&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;lipid_grid&#39;</span>


<div class="viewcode-block" id="BTGridProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.BTGridProtocol">[docs]</a><span class="k">class</span> <span class="nc">BTGridProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the bilayer thickness using a gridding procedure.</span>

<span class="sd">    This analysis uses a lipid grid representation (lipid positions are mapped</span>
<span class="sd">    to 2-D grids, one grid per leaflet) of the bilayer to estimate the bilayer</span>
<span class="sd">    thickness. This is done by measuring the difference in &#39;z&#39; position between</span>
<span class="sd">    corresponding grid points  of opposing bilayer leaflets.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;bilayer_thickness&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        None</span>

<span class="sd">    Note:</span>
<span class="sd">        The P-P distance can be estimated for phospholipid by assigning</span>
<span class="sd">        positions of the phosphorous atoms to the lipid grid.</span>

<span class="sd">    References:</span>
<span class="sd">        1. Allen et al. Vol. 30, No. 12 Journal of Computational Chemistry</span>
<span class="sd">        2. Gapsys et al. J Comput Aided Mol Des (2013) 27:845-858</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Bilayer thickness using lipid_grid.&quot;</span>
    <span class="c1"># self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;bilayer_thickness&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;lipid_length&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of BTGridProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>


<div class="viewcode-block" id="BTGridProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.BTGridProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">current_thickness</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;lipid_grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">average_thickness</span><span class="p">()</span>
        <span class="c1"># print (current_thickness)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1"># print (time)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">current_thickness</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">bt_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">bt_t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">bt_t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_thickness</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bt_t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">bt_t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bt_t</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="BTGridProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.BTGridProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;bilayer_thickness&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTGridProtocol</span>

<span class="c1"># define a new analysis &#39;apl_grid&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;apl_grid&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;apl_grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;lipid_grid&#39;</span>


<div class="viewcode-block" id="APLGridProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLGridProtocol">[docs]</a><span class="k">class</span> <span class="nc">APLGridProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the indvidual area per lipid for each lipid type using a gridding procedure.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;apl_grid&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        None</span>

<span class="sd">    References:</span>
<span class="sd">        1. Allen et al. Vol. 30, No. 12 Journal of Computational Chemistry</span>
<span class="sd">        2. Gapsys et al. J Comput Aided Mol Des (2013) 27:845-858</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Area per lipid using 2D lipid grids.&quot;</span>
    <span class="c1">#_return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;apl_grid&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;apl_box&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of APLGridProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># parse input arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span>

<div class="viewcode-block" id="APLGridProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLGridProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">apl_grid_out</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;lipid_grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">area_per_lipid</span><span class="p">()</span>
        <span class="c1"># print (current_thickness)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1"># print (time)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">apl_grid_out</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;composite&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">apl_grid_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">running_res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">apl_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">apl_grid_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;composite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">apl_t</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">apl_grid_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running_res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">apl_grid_out</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">apl_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">apl_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
            <span class="n">apl_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">apl_grid_out</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">apl_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">apl_res</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">apl_res</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="APLGridProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLGridProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="APLGridProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLGridProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div>

<div class="viewcode-block" id="APLGridProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLGridProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;apl_grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">APLGridProtocol</span>

<span class="c1"># define a new analysis &#39;disp_vec&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;disp_vec&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;disp_vec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>

<span class="c1">#need to think more about box scaling (settings[&#39;scale&#39;]). currently if set True</span>
<span class="c1"># will scale by the box size of the reference frame</span>
<div class="viewcode-block" id="DispVecProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecProtocol">[docs]</a><span class="k">class</span> <span class="nc">DispVecProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Comute displacement vectors for each lipid in the specified</span>
<span class="sd">    leaflet(s) of bilayer.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;disp_vec&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">            this analysis. Default: &#39;all&#39;, includes all lipid types.</span>
<span class="sd">        wrapped (bool): Specify whether to use the wrapped (&#39;True&#39;) or</span>
<span class="sd">            un-wrapped (&#39;False&#39;) coordintes for the base of the vectors.</span>
<span class="sd">            Default: False</span>
<span class="sd">        interval (int): Sets the frame interval over which to compute the</span>
<span class="sd">                displacement vectors.</span>
<span class="sd">        scale (bool): Specify whether to scale the coordinates by the box</span>
<span class="sd">            dimensions of the reference frame. Default: False</span>
<span class="sd">        scale_to_max (bool): Specify whether to scale the coordinates by the</span>
<span class="sd">            box dimensions of the maximum box size in the anlysis.</span>
<span class="sd">            Default: False.</span>

<span class="sd">    Note:</span>
<span class="sd">        The real frame ```interval``` setting needs to be a multiple of the</span>
<span class="sd">        frame looping interval set within the BilayerAnalyzer instance</span>
<span class="sd">        (i.e., analyzer.frame_range[2]) for this analysis to work properly.</span>

<span class="sd">    References:</span>
<span class="sd">        1. Emma Falck, Tomasz Rog, Mikko Karttunen, and Ilpo Vattulainen,</span>
<span class="sd">            Lateral Diffusion in Lipid Membranes through Collective Flows,</span>
<span class="sd">            Journal of the American Chemical Society, 2008 130 (1), 44-45</span>
<span class="sd">            DOI: 10.1021/ja7103558</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Displacement vectors.&quot;</span>
    <span class="c1"># self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;disp_vec&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;disp_vec_corr&#39;</span><span class="p">,</span> <span class="s1">&#39;disp_vec_nncorr&#39;</span><span class="p">,</span> <span class="s1">&#39;disp_vec_corr_avg&#39;</span><span class="p">,</span> <span class="s1">&#39;spatial_velocity_corr&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of DispVecProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1">#default settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;scale_to_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.group = &#39;all&#39;</span>
        <span class="c1">#self.wrapped = False</span>
        <span class="c1">#self.interval = 10</span>
        <span class="c1"># parse input arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1">#check the scaling settings</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;scale_to_max&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_dim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;interval&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;wrapped&#39;</span><span class="p">:</span>
                    <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">]</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_arg</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span>
                    <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">]</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_arg</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;scale_to_max&#39;</span><span class="p">:</span>
                    <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">]</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_arg</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>


<div class="viewcode-block" id="DispVecProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_dim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;frame_range&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">frame</span>
        <span class="c1">#print(self.settings[&#39;leaflet&#39;])</span>
        <span class="c1">#print(self.settings[&#39;scale&#39;])</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_frame</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span><span class="p">)</span>
        <span class="c1">#print (interval, &quot; &quot;, self.settings[&#39;interval&#39;])</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;lower&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;bad setting for </span><span class="se">\&#39;</span><span class="s2">leaflet</span><span class="se">\&#39;</span><span class="s2"> in &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;. Using default </span><span class="se">\&#39;</span><span class="s2">both</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

            <span class="c1"># get the current frame</span>
            <span class="n">curr_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="n">prev_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span>

            <span class="c1">#get box dimensions for reference frame (i.e. prev_frame)</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">box</span>
            <span class="n">box_lateral</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box_lateral</span><span class="p">)</span>
            <span class="c1"># get the coordinates for the selection at this frame</span>
            <span class="n">vec_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="c1"># vec_ends = []</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">resnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">resname</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                <span class="n">resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span>
                <span class="n">com_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]:</span>
                    <span class="c1">#print(&quot;scaling coordinates..&quot;)</span>
                    <span class="c1">#print(self.settings[&#39;leaflet&#39;])</span>
                    <span class="c1">#print(self.settings[&#39;scale&#39;])</span>
                    <span class="c1">#print(type(self.settings[&#39;scale&#39;]))</span>
                    <span class="c1">#print(type(self.settings[&#39;wrapped&#39;]))</span>
                    <span class="c1">#quit()</span>
                    <span class="n">com_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/=</span><span class="n">box_lateral</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">com_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/=</span><span class="n">box_lateral</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/=</span><span class="n">box_lateral</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/=</span><span class="n">box_lateral</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">com_j_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/=</span><span class="n">box_lateral</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">com_j_w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/=</span><span class="n">box_lateral</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1">#    vec_ends.append([com_j[0],com_j[0],com_i[0]-com_j[0],com_i[1]-com_j[1]])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">vec_ends</span><span class="p">,</span> <span class="n">resnames</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="n">current_frame</span>
            <span class="k">return</span>
        <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">_process_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;scale_to_max&#39;</span><span class="p">]:</span>
            <span class="n">boxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boxes</span><span class="p">)</span>
            <span class="c1"># print(boxes)</span>
            <span class="n">max_x</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">max_y</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">]</span>
            <span class="c1"># print(self.settings[&#39;scale&#39;])</span>
            <span class="c1"># print(max_x, max_y)</span>
            <span class="n">scaled_out</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">vec_end_res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">:</span>
                <span class="n">vec_ends</span> <span class="o">=</span> <span class="n">vec_end_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">resnames</span> <span class="o">=</span> <span class="n">vec_end_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#print(vec_ends[:,0])</span>
                <span class="c1">#print(max_x)</span>
                <span class="c1">#for i in range(len(vec_ends)):</span>
                <span class="c1">#    vec_ends[i, 0] /= max_x</span>
                <span class="c1">#    vec_ends[i, 2] /= max_x</span>
                <span class="c1">#    vec_ends[i, 1] /= max_y</span>
                <span class="c1">#    vec_ends[i, 3] /= max_y</span>
                <span class="n">vec_ends</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">max_x</span>
                <span class="c1">#vec_ends *= 1.0</span>
                <span class="c1">#print(vec_ends[:,0])</span>
                <span class="n">vec_ends</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">max_x</span>
                <span class="n">vec_ends</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">max_y</span>
                <span class="n">vec_ends</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">/=</span> <span class="n">max_y</span>
                <span class="c1">#quit()</span>
                <span class="n">scaled_out</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">vec_ends</span><span class="p">,</span> <span class="n">resnames</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">scaled_out</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span>

<div class="viewcode-block" id="DispVecProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_output</span><span class="p">()</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;disp_vec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DispVecProtocol</span>

<span class="c1"># define a new analysis</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;mass_dens&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;mass_dens&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>


<div class="viewcode-block" id="MassDensProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MassDensProtocol">[docs]</a><span class="k">class</span> <span class="nc">MassDensProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the mass density profile for the specified selection.</span>

<span class="sd">    This protocol is used to estimate the 1-dimensional mass density profile</span>
<span class="sd">    for a selection of atoms along the bilayer normal. The profile is</span>
<span class="sd">    automatically centered on the bilayer&#39;s center of mass along the bilayer</span>
<span class="sd">    normal.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;mass_dens&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        selection_string (str): Provide the MDAnalysis compatible selection</span>
<span class="sd">            for the atoms to include in this analysis. Default: &#39;BILAYER&#39;,</span>
<span class="sd">            use all the lipids of the bilayer as recovered from the</span>
<span class="sd">            selection given to the external BilayerAnalyzer.</span>
<span class="sd">        n_bins (int): Set the number of bins to divide the normal dimensions</span>
<span class="sd">            into for binning. Defalt: 25</span>

<span class="sd">    References:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_pickleable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Mass density profile.&quot;</span>
    <span class="c1"># self._return_length = None</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;mass_dens&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of MassDensProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;selection_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;BILAYER&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_bins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">25</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#self.selection_string = &#39;all&#39;</span>
        <span class="c1">#self.n_bins = 25</span>

        <span class="c1">#parse input arguments/settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>


        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>
        <span class="c1">#in this case the casting is taken care of in _parse_str_to_dict</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

    <span class="c1"># needed to overwrite the string parser to handle the selection string</span>
    <span class="k">def</span> <span class="nf">_parse_str_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="c1"># print args</span>
        <span class="n">arg_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">arg_dict</span><span class="p">[</span><span class="s1">&#39;analysis_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">read_sel_string</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">n_bins_arg</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nargs</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">arg_key</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1">#print (&#39;arg_key: &#39;, arg_key)</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;n_bins&#39;</span><span class="p">:</span>
                    <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="s1">&#39;n_bins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                    <span class="n">read_sel_string</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">n_bins_arg</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;selection&#39;</span><span class="p">:</span>
                    <span class="n">selection_words</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nargs</span><span class="p">)</span> <span class="k">if</span>
                                       <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">)]</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selection_words</span><span class="p">)</span>
                    <span class="n">selection_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">selection_words</span><span class="p">:</span>
                        <span class="n">selection_string</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">word</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="s1">&#39;selection_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">selection_string</span>
                    <span class="n">read_sel_string</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">n_bins_arg</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">read_sel_string</span> <span class="ow">or</span> <span class="n">n_bins_arg</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>


<div class="viewcode-block" id="MassDensProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MassDensProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="MassDensProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MassDensProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;selection_string&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;selection_string&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;BILAYER&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bilayer_sel&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">bilayer_sel</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;non-bilayer&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">mda_universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;selection_string&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># print &quot;there are &quot;,len(indices),&quot; members&quot;</span>

        <span class="n">norm_axis</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;normal_dimension&#39;</span><span class="p">]</span>
        <span class="n">ref_sel</span> <span class="o">=</span> <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">bilayer_sel</span>
        <span class="c1"># mda_density_profile</span>
        <span class="n">centers_density</span> <span class="o">=</span> <span class="n">mda_dp</span><span class="o">.</span><span class="n">mass_density_profile</span><span class="p">(</span>
            <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">mda_trajectory</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">,</span>
            <span class="n">fstart</span><span class="o">=</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;frame_index&#39;</span><span class="p">],</span>
            <span class="n">fend</span><span class="o">=</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;frame_index&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">norm_axis</span><span class="p">,</span>
            <span class="n">nbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_bins&#39;</span><span class="p">],</span> <span class="n">refsel</span><span class="o">=</span><span class="n">ref_sel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="o">=</span> <span class="n">centers_density</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centers</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">+=</span> <span class="n">centers_density</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="MassDensProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MassDensProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="n">centers_density</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">centers_density</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="MassDensProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MassDensProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">odict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">odict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">odict</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">odict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">in_dict</span></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;mass_dens&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MassDensProtocol</span>

<span class="c1"># define a new analysis &#39;nnf&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;nnf&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;nnf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="NNFProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NNFProtocol">[docs]</a><span class="k">class</span> <span class="nc">NNFProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the nearest neighbor fraction for one lipid type with another.</span>

<span class="sd">    This analysis picks a specified number (n_neighbors) of nearest neighbors</span>
<span class="sd">    centered on a lipid of reference lipid type and then counts the number of</span>
<span class="sd">    lipids (M) of target lipid type and estimates the fraction,</span>
<span class="sd">        nnf =  &lt;M/n_neighbors&gt; ,</span>
<span class="sd">    where angle brackets denote averaging over lipids of specified by settings</span>
<span class="sd">    resname_1. This metric is also referred to as &#39;fractional interations&#39;.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;nnf&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        n_neighbors (int): Specifies the number of nearest neighbors to</span>
<span class="sd">            to include in computation. Default: 5</span>
<span class="sd">        resname_1 (str): Specify the resname of the reference lipid type to</span>
<span class="sd">            include in this analysis. Default: &#39;first&#39;, the first lipid in</span>
<span class="sd">            the list pulled from the com_frame representation.</span>
<span class="sd">        resname_2 (str): Specify the resname of the target lipid type to</span>
<span class="sd">            include in this analysis. Default: &#39;first&#39;, the first lipid in</span>
<span class="sd">            the list pulled from the com_frame representation.</span>

<span class="sd">    Note:</span>
<span class="sd">        The anlysis in centered on lipids of the type specified by the</span>
<span class="sd">        ```resname_1``` setting and returns the fraction of lipids of the type</span>
<span class="sd">        specified by the ```resname_2``` setting within the ```n_neighbors```</span>
<span class="sd">        nearest neighbors.</span>

<span class="sd">    References:</span>
<span class="sd">        1. A. H. de Vries, A. E. Mark and S. J. Marrink, J. Phys. Chem. B,</span>
<span class="sd">            2004, 108, 2454-2463</span>

<span class="sd">        2. M. Orsi and J. W. Essex, Faraday Discuss., 2013, 161, 249-272</span>

<span class="sd">        3. Koldso H, Shorthouse D, He Lie Sansom MSP (2014) &quot;Lipid</span>
<span class="sd">            Clustering Correlates with Membrane Curvature as Revealed by</span>
<span class="sd">            Molecular Simulations of Complex Lipid Bilayers.&quot; PloS Comput</span>
<span class="sd">            Biol 10(10): e1003911. doi.10.1371/journal.pcbi.1003911</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Lateral order nearest neighbor fraction.&quot;</span>
    <span class="c1"># self._return_length = 2</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;nnf&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of NNFProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#parse input arguments/settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># for outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="NNFProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NNFProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="NNFProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NNFProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="c1">#pass</span>
            <span class="c1"># build group/resname/lipid type list</span>
            <span class="n">lipid_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nlipids</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">leaflet_name</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">leaflet</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet_name</span><span class="p">]</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="n">nlipids</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflet</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lipid_types</span><span class="p">:</span>
                        <span class="n">lipid_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nlipids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nlipids</span><span class="o">-</span><span class="mi">1</span>

            <span class="n">n_ltypes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lipid_types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lipid_types</span> <span class="o">=</span> <span class="n">lipid_types</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_ltypes</span> <span class="o">=</span> <span class="n">n_ltypes</span>

        <span class="n">lipid_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipid_types</span>
        <span class="n">n_ltypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ltypes</span>
        <span class="c1">#print lipid_types</span>
        <span class="n">x_index</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_index</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">box_x</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">x_index</span><span class="p">]</span>
        <span class="n">box_y</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">y_index</span><span class="p">]</span>
        <span class="n">l_box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">box_x</span><span class="p">,</span> <span class="n">box_y</span><span class="p">])</span>
        <span class="n">box_x_h</span> <span class="o">=</span> <span class="n">box_x</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">box_y_h</span> <span class="o">=</span> <span class="n">box_y</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">ltype_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span>
        <span class="n">ltype_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span>
        <span class="c1">#print &quot;ltype_a: &quot;,ltype_a,&quot; ltype_b: &quot;,ltype_b</span>
        <span class="n">avg_frac</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">leaflet_name</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
            <span class="n">leaflet</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet_name</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">has_group</span><span class="p">(</span><span class="n">ltype_a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">has_group</span><span class="p">(</span><span class="n">ltype_b</span><span class="p">):</span>
                <span class="n">ltype_a_indices</span> <span class="o">=</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">ltype_a</span><span class="p">)</span>
                <span class="n">all_index</span> <span class="o">=</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ltype_a_indices</span><span class="p">:</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">all_index</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                            <span class="n">pos_a</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[[</span><span class="n">x_index</span><span class="p">,</span> <span class="n">y_index</span><span class="p">]]</span>
                            <span class="n">pos_b</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[[</span><span class="n">x_index</span><span class="p">,</span> <span class="n">y_index</span><span class="p">]]</span>
                            <span class="n">dist</span> <span class="o">=</span> <span class="n">distance_euclidean_pbc</span><span class="p">(</span><span class="n">pos_a</span><span class="p">,</span> <span class="n">pos_b</span><span class="p">,</span> <span class="n">l_box</span><span class="p">,</span>
                                                          <span class="n">center</span><span class="o">=</span><span class="s1">&#39;box_half&#39;</span><span class="p">)</span>
                            <span class="n">ltype</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                            <span class="c1">#print &quot;ltype: &quot;,ltype,&quot; dist &quot;,dist</span>
                            <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">j</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">ltype</span><span class="p">])</span>
                    <span class="n">neighbors</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">nn_neighbors</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]]</span>
                    <span class="c1">#print neighbors</span>
                    <span class="c1">#print nn_neighbors</span>
                    <span class="c1">#quit()</span>
                    <span class="n">n_type_b</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">nn_neighbors</span><span class="p">:</span>
                        <span class="n">ntype</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">ntype</span> <span class="o">==</span> <span class="n">ltype_b</span><span class="p">:</span>
                            <span class="n">n_type_b</span> <span class="o">+=</span> <span class="mf">1.0</span>
                    <span class="n">frac</span> <span class="o">=</span> <span class="n">n_type_b</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]</span>
                    <span class="c1">#print &quot;frac &quot;,frac,&quot; n_type_b: &quot;,n_type_b,&quot; set_n_neighbors: &quot;,self.settings[&#39;n_neighbors&#39;]</span>

                    <span class="n">avg_frac</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">frac</span><span class="p">)</span>

        <span class="n">f_current</span> <span class="o">=</span> <span class="n">avg_frac</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">f_current</span><span class="p">)</span>
        <span class="n">f_run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">f_run_dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tc</span><span class="p">,</span> <span class="n">f_current</span><span class="p">,</span> <span class="n">f_run</span><span class="p">,</span> <span class="n">f_run_dev</span><span class="p">])</span>
        <span class="k">return</span></div></div>

    <span class="c1"># def run_analysis(self, ba_settings, ba_reps, ba_mda_data):</span>
    <span class="c1">#</span>
    <span class="c1">#     if self._first_frame:</span>
    <span class="c1">#         pass</span>
    <span class="c1">#         #build group/resname/lipid type list</span>
    <span class="c1">#         lipid_types = []</span>
    <span class="c1">#         for leaflet in ba_reps[&#39;leaflets&#39;]:</span>
    <span class="c1">#             groups = leaflet.get_group_names()</span>
    <span class="c1">#             for group in groups:</span>
    <span class="c1">#                 if group not in lipid_types:</span>
    <span class="c1">#                     lipid_types.append(group)</span>
    <span class="c1">#         n_ltypes = len(lipid_types)</span>
    <span class="c1">#         self.lipid_types = lipid_types</span>
    <span class="c1">#         self.n_ltypes = n_ltypes</span>
    <span class="c1">#</span>
    <span class="c1">#     lipid_types = self.lipid_types</span>
    <span class="c1">#     n_ltypes = self.n_ltypes</span>
    <span class="c1">#</span>
    <span class="c1">#     x_index = ba_settings[&#39;lateral&#39;][0]</span>
    <span class="c1">#     y_index = ba_settings[&#39;lateral&#39;][1]</span>
    <span class="c1">#     box = ba_reps[&#39;current_mda_frame&#39;].dimensions[0:3]</span>
    <span class="c1">#     box_x = box[x_index]</span>
    <span class="c1">#     box_y = box[y_index]</span>
    <span class="c1">#     box_x_h = box_x/2.0</span>
    <span class="c1">#     box_y_h = box_y/2.0</span>
    <span class="c1">#</span>
    <span class="c1">#     for leaflet in ba_reps[&#39;leaflets&#39;]:</span>
    <span class="c1">#         all_indices = leaflet.get_member_indices()</span>
    <span class="c1">#</span>
    <span class="c1">#         #X-X types</span>
    <span class="c1">#         for lipid_type in lipid_types:</span>
    <span class="c1">#             if leaflet.has_group(lipid_type):</span>
    <span class="c1">#                 ltype_indices = leaflet.get_group_indices(lipid_type)</span>
    <span class="c1">#                 nlip = len(ltype_indices)</span>
    <span class="c1">#                 neigbors = dict()</span>
    <span class="c1">#                 for lindex in ltype_indices:</span>
    <span class="c1">#                     neigbors[lindex] = []</span>
    <span class="c1">#                     for lindex_b in ltype_indices:</span>
    <span class="c1">#</span>
    <span class="c1">#                         if lindex_b != lindex:</span>
    <span class="c1">#                             pos_a = ba_reps[&#39;com_frame&#39;].lipidcom[lindex].com</span>
    <span class="c1">#                             pos_b = ba_reps[&#39;com_frame&#39;].lipidcom[lindex_b].com</span>
    <span class="c1">#                             dx = np.abs(pos_a[x_index] - pos_b[x_index])</span>
    <span class="c1">#                             dy = np.abs(pos_a[y_index] - pos_b[y_index])</span>
    <span class="c1">#                             #minimum image for wrapped coordinates</span>
    <span class="c1">#                             if dx &gt; box_x_h:</span>
    <span class="c1">#                                dx = box_x - np.absolute(pos_a[x_index]-box_x_h) - np.absolute(pos_b[x_index]-box_x_h)</span>
    <span class="c1">#</span>
    <span class="c1">#                             if dy &gt; box_yy_h:</span>
    <span class="c1">#                                dy = box_y - np.absolute(pos_a[y_index]-box_y_h) - np.absolute(pos_b[y_index]-box_y_h)</span>
    <span class="c1">#                             dist = np.sqrt(dx**2 + dy**2)</span>
    <span class="c1">#                             neigbors[lindex_b].append([lindex_b, dist])</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#         #X-Y types</span>
    <span class="c1">#         for i in range(n_ltypes-1):</span>
    <span class="c1">#             for j in range(i+1, n_ltypes):</span>
    <span class="c1">#             ltype_i = lipid_types[i]</span>
    <span class="c1">#             ltype_j = lipid_types[j]</span>
    <span class="c1">#             if leaflet.has_group(ltype_i) and leaflet.has_group(ltype_j):</span>
    <span class="c1">#</span>
    <span class="c1">#                 ltype_indices = leaflet.get_group_indices()</span>
    <span class="c1">#                 for lipid_type_b in lipid_types:</span>
    <span class="c1">#                     if leaflet.has_group(lipid_type_b):</span>
    <span class="c1">#                         ltype_b_indices</span>
    <span class="c1">#     tc = ba_reps[&#39;com_frame&#39;].time</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#     return</span>


<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;nnf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NNFProtocol</span>

<span class="c1"># define a new analysis &#39;disp_vec&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;disp_vec_corr&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;disp_vec_corr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="DispVecCorrelationProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationProtocol">[docs]</a><span class="k">class</span> <span class="nc">DispVecCorrelationProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Comute the pair-wise cross correlation matrix for the displacement vectors for each lipid in the specified leaflet(s) of bilayer.</span>

<span class="sd">    This analysis computes the displacement vectors as in &#39;disp_vec&#39; analysis</span>
<span class="sd">    (DispVecProtocol), but then continues to compute the pair-wise cross</span>
<span class="sd">    correlation matrix between each vector. i.e. the cos(theta) for the angle</span>
<span class="sd">    theta between the vectors.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;disp_vec_corr&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">            this analysis. Default: &#39;all&#39;, includes all lipid types.</span>
<span class="sd">        wrapped (bool): Specify whether to use the wrapped (&#39;True&#39;) or</span>
<span class="sd">            un-wrapped (&#39;False&#39;) coordintes for the base of the vectors.</span>
<span class="sd">            Default: False</span>
<span class="sd">        interval (int): Sets the frame interval over which to compute the</span>
<span class="sd">                displacement vectors. f</span>

<span class="sd">    References:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Displacement vector correlation matrix.&quot;</span>
    <span class="c1"># self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;disp_vec_corr&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;disp_vec&#39;</span><span class="p">,</span> <span class="s1">&#39;disp_vec_nncorr&#39;</span><span class="p">,</span> <span class="s1">&#39;disp_vec_corr_avg&#39;</span><span class="p">,</span> <span class="s1">&#39;spatial_velocity_corr&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of DispVecCorrelationProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;interval&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;wrapped&#39;</span><span class="p">:</span>
                    <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">]</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_arg</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="DispVecCorrelationProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecCorrelationProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">frame</span>

        <span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_frame</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span><span class="p">)</span>
        <span class="c1">#print (interval, &quot; &quot;, self.settings[&#39;interval&#39;])</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;lower&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;bad setting for </span><span class="se">\&#39;</span><span class="s2">leaflet</span><span class="se">\&#39;</span><span class="s2"> in &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;. Using default </span><span class="se">\&#39;</span><span class="s2">both</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

            <span class="c1"># get the current frame</span>
            <span class="n">curr_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="n">prev_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span>
            <span class="c1"># get the coordinates for the selection at this frame</span>
            <span class="n">vec_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="c1"># vec_ends = []</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">resnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">resname</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                <span class="n">resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span>
                <span class="n">com_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#    vec_ends.append([com_j[0],com_j[0],com_i[0]-com_j[0],com_i[1]-com_j[1]])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">corr_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="n">n_com</span><span class="p">))</span>
            <span class="c1">#loop over vectors</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com</span><span class="p">):</span>
                <span class="n">corr_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">vec_end_a</span> <span class="o">=</span> <span class="n">vec_ends</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vec_a</span> <span class="o">=</span> <span class="n">vec_end_a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec_end_a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_com</span><span class="p">):</span>
                    <span class="n">vec_end_b</span> <span class="o">=</span> <span class="n">vec_ends</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">vec_b</span> <span class="o">=</span> <span class="n">vec_end_b</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec_end_b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_a</span><span class="p">,</span> <span class="n">vec_b</span><span class="p">)</span>
                    <span class="n">cos_t</span> <span class="o">=</span> <span class="n">dot</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_a</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_b</span><span class="p">))</span>
                    <span class="n">corr_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_t</span>
                    <span class="n">corr_mat</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_t</span>



            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">corr_mat</span><span class="p">,</span> <span class="n">resnames</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="n">current_frame</span>
            <span class="c1">#return vec_ends</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecCorrelationProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecCorrelationProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;disp_vec_corr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DispVecCorrelationProtocol</span>

<span class="c1"># define a new analysis &#39;disp_vec&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;disp_vec_nncorr&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;disp_vec_nncorr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="DispVecNNCorrelationProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecNNCorrelationProtocol">[docs]</a><span class="k">class</span> <span class="nc">DispVecNNCorrelationProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Comute the pair-wise cross correlations for the displacement vectors for each lipid in the specified leaflet(s) of bilayer and its nearest neighbor.</span>

<span class="sd">    This analysis computes the displacement vectors as in the &#39;disp_vec&#39;</span>
<span class="sd">    analysis (DispVecProtocol), but then continues to compute the pair-wise</span>
<span class="sd">    cross correlation between each vector and its nearest neighbor. i.e. the</span>
<span class="sd">    cos(theta) for the angle theta between the vectors.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;disp_vec_nncorr&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">            this analysis. Default: &#39;all&#39;, includes all lipid types.</span>
<span class="sd">        wrapped (bool): Specify whether to use the wrapped (&#39;True&#39;) or</span>
<span class="sd">            un-wrapped (&#39;False&#39;) coordintes for the base of the vectors.</span>
<span class="sd">            Default: False</span>
<span class="sd">        interval (int): Sets the frame interval over which to compute the</span>
<span class="sd">                displacement vectors. f</span>

<span class="sd">    References:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Displacement vector nearest neigbor correlations.&quot;</span>
    <span class="c1">#    self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;disp_vec_nncorr&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;disp_vec&#39;</span><span class="p">,</span> <span class="s1">&#39;disp_vec_corr&#39;</span><span class="p">,</span> <span class="s1">&#39;disp_vec_corr_avg&#39;</span><span class="p">,</span> <span class="s1">&#39;spatial_velocity_corr&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of DispVecNNCorrelationProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;interval&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;wrapped&#39;</span><span class="p">:</span>
                    <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">]</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_arg</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="DispVecNNCorrelationProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecNNCorrelationProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecNNCorrelationProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecNNCorrelationProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">frame</span>

        <span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_frame</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span><span class="p">)</span>
        <span class="c1">#print (interval, &quot; &quot;, self.settings[&#39;interval&#39;])</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;lower&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;bad setting for </span><span class="se">\&#39;</span><span class="s2">leaflet</span><span class="se">\&#39;</span><span class="s2"> in &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;. Using default </span><span class="se">\&#39;</span><span class="s2">both</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

            <span class="c1"># get the current frame</span>
            <span class="n">curr_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="n">prev_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span>
            <span class="c1">#get the vector ends</span>

            <span class="c1"># get the coordinates for the selection at this frame</span>
            <span class="n">vec_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="c1"># vec_ends = []</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">resnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">resname</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                <span class="n">resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span>
                <span class="n">com_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#    vec_ends.append([com_j[0],com_j[0],com_i[0]-com_j[0],com_i[1]-com_j[1]])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="c1">#loop over vectors</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com</span><span class="p">):</span>
                <span class="n">vec_end_a</span> <span class="o">=</span> <span class="n">vec_ends</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vec_a</span> <span class="o">=</span> <span class="n">vec_end_a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec_end_a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1">#now loop over again and find nearest neighbor at vector bases</span>
                <span class="n">nn_vec</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">nn_dist</span> <span class="o">=</span> <span class="mf">1000000.0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">vec_end_b</span> <span class="o">=</span> <span class="n">vec_ends</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">vec_b</span> <span class="o">=</span> <span class="n">vec_end_b</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec_end_b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_end_b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">vec_end_a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">nn_dist</span><span class="p">:</span>
                            <span class="n">nn_dist</span> <span class="o">=</span> <span class="n">dist</span>
                            <span class="n">nn_vec</span> <span class="o">=</span> <span class="n">vec_b</span>
                <span class="c1">#now analysis the correlation (cos(theta))</span>
                <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_a</span><span class="p">,</span> <span class="n">nn_vec</span><span class="p">)</span>
                <span class="n">cos_t</span> <span class="o">=</span> <span class="n">dot</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_a</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">nn_vec</span><span class="p">))</span>
                <span class="n">corr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_t</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">corr</span><span class="p">,</span> <span class="n">resnames</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="n">current_frame</span>
            <span class="c1">#return vec_ends</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecNNCorrelationProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecNNCorrelationProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecNNCorrelationProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecNNCorrelationProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;disp_vec_nncorr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DispVecNNCorrelationProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ndcorr&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;ndcorr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>

<div class="viewcode-block" id="NDCorrProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NDCorrProtocol">[docs]</a><span class="k">class</span> <span class="nc">NDCorrProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Correlation between bilayer surfucace curvature and the clustering of lipid molecules.</span>

<span class="sd">    This protocol is used to estimate the cross correlation between the</span>
<span class="sd">    normal dimension deflection of lipids and the lipid types in local</span>
<span class="sd">    blocks of the bilayer. This serves as a measure of the correlation</span>
<span class="sd">    between the local curvature and composition of the bilayer.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;ndcorr&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        None</span>

<span class="sd">    Note:</span>
<span class="sd">        Automatically estimates the correlations with each lipid type in the</span>
<span class="sd">        bilayer selection provided to the external BilayerAnalyzer object.</span>

<span class="sd">    References:</span>
<span class="sd">        1. Koldso H, Shorthouse D, He Lie Sansom MSP (2014) &quot;Lipid</span>
<span class="sd">            Clustering Correlates with Membrane Curvature as Revealed by</span>
<span class="sd">            Molecular Simulations of Complex Lipid Bilayers.&quot; PloS Comput</span>
<span class="sd">            Biol 10(10): e1003911. doi.10.1371/journal.pcbi.1003911</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Correlation between bilayer surface curvature and lipid clustering.&quot;</span>
    <span class="c1">#    self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;ndcorr&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of NDCorrProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># default function settings</span>

        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="c1">#save file name for pickle dump of results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1">#for analysis and outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">return</span>


<div class="viewcode-block" id="NDCorrProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NDCorrProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="c1">#construct the grids</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="n">lgc</span><span class="o">.</span><span class="n">LipidGrids</span><span class="p">(</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">],</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">],</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">leafs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grids</span><span class="o">.</span><span class="n">leaf_grid</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">all_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leafs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_types</span><span class="p">:</span>
                        <span class="n">all_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leafs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l_type</span> <span class="ow">in</span> <span class="n">all_types</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#analysis the correlations</span>
        <span class="n">correlations</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">norm_displacement_cross_correlation</span><span class="p">()</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1">#extract the data</span>
        <span class="n">leafs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">correlations</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leafs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l_type</span> <span class="ow">in</span> <span class="n">correlations</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">corr</span> <span class="o">=</span> <span class="n">correlations</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>
                <span class="n">corr_run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">corr_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">time</span><span class="p">,</span> <span class="n">corr</span><span class="p">,</span> <span class="n">corr_run</span><span class="p">,</span> <span class="n">corr_std</span><span class="p">]))</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="NDCorrProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NDCorrProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="NDCorrProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NDCorrProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">tkey</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">tkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">tkey</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;ndcorr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NDCorrProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;dc_cluster&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;dc_cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>

<span class="c1">#</span>
<div class="viewcode-block" id="DCClusterProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DCClusterProtocol">[docs]</a><span class="k">class</span> <span class="nc">DCClusterProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute lipid clusters using a hiearchical distance based method.</span>

<span class="sd">    This analysis uses a type of hiearchical clustering where points (lipid</span>
<span class="sd">    centers of mass) are are added to a cluster if they are within a specified</span>
<span class="sd">    distance of any other point within the cluster.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;dc_cluster&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">            this analysis. Default: &#39;all&#39;, includes all lipid types.</span>
<span class="sd">        cutoff (float): The cutoff distance to use for the clustering.</span>
<span class="sd">            Default: 12.0</span>

<span class="sd">    Note:</span>
<span class="sd">        Only finds the self clusters for a single lipid type as specified by</span>
<span class="sd">        the ```resname``` setting.</span>

<span class="sd">    References:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Hiearchical clustering of lipids based on distance.&quot;</span>
    <span class="c1"># self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;dc_cluster&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of DCClusterProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cutoff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">12.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># default function settings</span>

        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="c1">#save file name for pickle dump of results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1">#for analysis and outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;nclusters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;min_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;avg_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;nclusters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;min_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;avg_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;cutoff&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="DCClusterProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DCClusterProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="c1">#pass</span>
            <span class="c1"># build group/resname/lipid type list</span>
            <span class="n">lipid_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">leaflet_name</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">leaflet</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet_name</span><span class="p">]</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
        <span class="c1">#        nlipids += len(leaflet.get_member_indices())</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lipid_types</span><span class="p">:</span>
                        <span class="n">lipid_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]])</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
        <span class="n">dist_func</span> <span class="o">=</span> <span class="n">dc_cluster</span><span class="o">.</span><span class="n">distance_euclidean_pbc</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">dc_cluster</span><span class="o">.</span><span class="n">distance_cutoff_clustering</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cutoff&#39;</span><span class="p">],</span> <span class="n">dist_func</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;box_half&#39;</span><span class="p">)</span>

        <span class="n">nclusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
        <span class="n">min_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">avg_size</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">max_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">min_size</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">elif</span> <span class="n">max_size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">max_size</span><span class="p">:</span>
                <span class="n">min_size</span> <span class="o">=</span> <span class="n">n</span>
            <span class="n">avg_size</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="c1">#protect for divide by zero</span>
        <span class="k">if</span> <span class="n">nclusters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">avg_size</span> <span class="o">/=</span> <span class="n">nclusters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;nclusters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">nclusters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">max_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;min_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">min_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;avg_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">avg_size</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;nclusters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span><span class="n">nclusters</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;nclusters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;nclusters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">deviation</span><span class="p">()])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span><span class="n">max_size</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">deviation</span><span class="p">()])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;min_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span><span class="n">min_size</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;min_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;min_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">deviation</span><span class="p">()])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;avg_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span><span class="n">avg_size</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;avg_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;avg_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">deviation</span><span class="p">()])</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DCClusterProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DCClusterProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">converted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="DCClusterProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DCClusterProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">converted</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;clusters&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">converted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;dc_cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DCClusterProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;vcm&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;vcm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>

<div class="viewcode-block" id="VolumeCompressibilityModulusProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.VolumeCompressibilityModulusProtocol">[docs]</a><span class="k">class</span> <span class="nc">VolumeCompressibilityModulusProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the isothermal volume compressibility modulus.</span>

<span class="sd">    This protocol is used to estimate the volume compressibility modulus,</span>
<span class="sd">        K_V = (&lt;V&gt;kT) / var(V),</span>
<span class="sd">    where V is the volume.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;vcm&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        temperature (float): The absolute temperature that the simulation</span>
<span class="sd">            was run at (i.e. in Kelvin). Default: 298.15 K</span>

<span class="sd">    References:</span>
<span class="sd">        1. Christofer Hofsab, Erik Lindahl, and Olle Edholm, &quot;Molecular</span>
<span class="sd">            Dynamics Simulations of Phospholipid Bilayers with Cholesterol&quot;,</span>
<span class="sd">            Biophys J. 2003 Apr; 84(4): 2192-2206.</span>
<span class="sd">            doi:  10.1016/S0006-3495(03)75025-5</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Volume compressibility modulus.&quot;</span>
    <span class="c1">#    self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;vcm&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;acm&#39;</span><span class="p">,</span> <span class="s1">&#39;ac&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of VolumeCompressibilityModulusProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">298.15</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># parse input arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1">#output filename for pickle dump of results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>


        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;temperature&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>


<div class="viewcode-block" id="VolumeCompressibilityModulusProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.VolumeCompressibilityModulusProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume_run</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="VolumeCompressibilityModulusProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.VolumeCompressibilityModulusProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">dimensions</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
        <span class="c1">#print(area)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>

        <span class="n">Kv</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># return</span>
            <span class="n">Kv</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Kv</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">*</span> <span class="n">scicon</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">])</span>
                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume_run</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span> <span class="n">Kv</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;vcm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">VolumeCompressibilityModulusProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;acm&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;acm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>

<div class="viewcode-block" id="AreaCompressibilityModulusProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaCompressibilityModulusProtocol">[docs]</a><span class="k">class</span> <span class="nc">AreaCompressibilityModulusProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the isothermal area compressibility modulus.</span>

<span class="sd">    This protocol is used to estimate the area compressibility modulus,</span>
<span class="sd">        K_A = (&lt;A&gt;kT) / var(A),</span>
<span class="sd">    where A is the area in the lateal dimension of the bilayer.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;acm&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        temperature (float): The absolute temperature that the simulation</span>
<span class="sd">            was run at (i.e. in Kelvin). Default: 298.15 K</span>

<span class="sd">    References:</span>
<span class="sd">        1. Christofer Hofsab, Erik Lindahl, and Olle Edholm, &quot;Molecular</span>
<span class="sd">            Dynamics Simulations of Phospholipid Bilayers with Cholesterol&quot;,</span>
<span class="sd">            Biophys J. 2003 Apr; 84(4): 2192-2206.</span>
<span class="sd">            doi:  10.1016/S0006-3495(03)75025-5</span>
<span class="sd">        2. L. Janosi and A. A. Gorfe, J. Chem. Theory Comput. 2010, 6,</span>
<span class="sd">            3267-3273</span>
<span class="sd">        3. D. Aguayo, F. D. Gonzalez-Nilo, and C. Chipot, J. Chem. Theory</span>
<span class="sd">            Comput. 2012, 8, 1765-1773</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Area compressibility modulus.&quot;</span>
    <span class="c1">#    self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;acm&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;ac&#39;</span><span class="p">,</span> <span class="s1">&#39;vcm&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of AreaCompressibilityModulusProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">298.15</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># parse input arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1">#output filename for pickle dump of results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>


        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;temperature&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>


<div class="viewcode-block" id="AreaCompressibilityModulusProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaCompressibilityModulusProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="AreaCompressibilityModulusProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaCompressibilityModulusProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">dimensions</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span><span class="o">/</span><span class="n">dimensions</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]]</span>
        <span class="c1">#print(area)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
        <span class="n">Ka</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">Ka_err</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="o">+=</span><span class="mi">1</span>
            <span class="c1">#return</span>
            <span class="n">Ka</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ka</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">*</span><span class="n">scicon</span><span class="o">.</span><span class="n">k</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">variance</span><span class="p">()</span>
            <span class="n">area_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
            <span class="n">area_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">n_areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">n</span>
            <span class="c1">#area_err = area_std/np.sqrt(self.area_run.n)</span>
            <span class="n">area_var_of_var</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="n">area_std</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_areas</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">area_std_of_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">area_var_of_var</span><span class="p">)</span>
            <span class="c1">#area_err_of_var = np.sqrt(area_var_of_var)/np.sqrt(self.area_run.n)</span>
            <span class="n">Ka_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">area_std</span><span class="o">/</span><span class="n">area_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">area_std_of_var</span><span class="o">/</span><span class="n">area_std</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Ka</span>
            <span class="c1">#Ka_err = (area_std/area_mean + ( (np.sqrt(2.0)*area_std**2)/np.sqrt(n_areas -1))/area_std**2 )*Ka</span>
        <span class="c1">#print &quot;&lt;A&gt;: &quot;, self.area_run.mean(), &quot; var(A): &quot;,self.area_run.variance()</span>
        <span class="c1">#print &quot;T: &quot;,self.settings[&#39;temperature&#39;],&quot; k: &quot;,scicon.k</span>
        <span class="c1">#conversion factor for Joules/Angstrom^2 to milliNewtons/meter</span>
        <span class="n">Ka</span><span class="o">*=</span><span class="mf">10.0</span><span class="o">**</span><span class="mi">23</span>
        <span class="n">Ka_err</span><span class="o">*=</span><span class="mf">10.0</span><span class="o">**</span><span class="mi">23</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span> <span class="n">Ka</span><span class="p">,</span> <span class="n">Ka_err</span><span class="p">,</span> <span class="n">area</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;acm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">AreaCompressibilityModulusProtocol</span>

<span class="c1"># define a new analysis &#39;msd&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ald&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;ald&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>

<div class="viewcode-block" id="ALDProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.ALDProtocol">[docs]</a><span class="k">class</span> <span class="nc">ALDProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the average lateral displacement of lipids.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;ald&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">            this analysis. Default: &#39;all&#39;, includes all lipid types.</span>

<span class="sd">    References:</span>
<span class="sd">        1. Kenichiro Koshiyama, Tetsuya Kodama, Takeru Yano, Shigeo</span>
<span class="sd">            Fujikawa, &quot;Molecular dynamics simulation of structural changes</span>
<span class="sd">            of lipid bilayers induced by shock waves: Effects of incident</span>
<span class="sd">            angles&quot;, Biochimica et Biophysica Acta (BBA) - Biomembranes,</span>
<span class="sd">            Volume 1778, Issue 6, June 2008, Pages 1423-1428</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Average lateral displacement.&quot;</span>
    <span class="c1">#    self._return_length = 2</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;ald&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;msd&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of ALDProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>


<div class="viewcode-block" id="ALDProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.ALDProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">leaflet</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">selcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">com_curr</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
            <span class="n">selcoords</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_curr</span><span class="p">[:]</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># initialize a numpy array to hold the msd for the selection</span>
        <span class="n">msd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># initialize a running stats object to do the averaging over resids</span>
        <span class="c1">#drs_stat = RunningStats()</span>

        <span class="n">ref_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">com_curr</span> <span class="o">=</span> \
                    <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;first_com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                        <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">ref_coords</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_curr</span><span class="p">[:]</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="n">ref_coords</span><span class="p">[:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span>
            <span class="c1"># get the current com frame list</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">tc</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">selcoords</span> <span class="o">-</span> <span class="n">ref_coords</span>
        <span class="n">m_dr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dr</span><span class="p">:</span>
            <span class="n">m_dr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">)))</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">m_dr</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">m_dr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="c1"># get the msd for the current selection</span>
        <span class="n">Lcurr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">msd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="n">msd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Lcurr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msd</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="ALDProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.ALDProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L_stat</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div></div>
<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;ald&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ALDProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ac&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;ac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>

<div class="viewcode-block" id="AreaCompressibilityProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaCompressibilityProtocol">[docs]</a><span class="k">class</span> <span class="nc">AreaCompressibilityProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the isothermal area compressibility.</span>

<span class="sd">    This protocol is used to estimate the area compressibility modulus,</span>
<span class="sd">        K_A^-1 = [(&lt;A&gt;kT) / var(A)]^-1 ,</span>
<span class="sd">    where A is the area in the lateal dimension of the bilayer.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;ac&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        temperature (float): The absolute temperature that the simulation</span>
<span class="sd">            was run at (i.e. in Kelvin). Default: 298.15 K</span>

<span class="sd">    Note:</span>
<span class="sd">        Area compressibility is the inverse of area compressibility modulus</span>
<span class="sd">        (see Ref.1).</span>

<span class="sd">    References:</span>
<span class="sd">        1. Yoshimichi Andoha, Susumu Okazakia, Ryuichi Ueokab, &quot;Molecular</span>
<span class="sd">            dynamics study of lipid bilayers modeling the plasma membranes of</span>
<span class="sd">            normal murine thymocytes and leukemic GRSL cells&quot;, Biochimica et</span>
<span class="sd">            Biophysica Acta (BBA) - Biomembranes, Volume 1828, Issue 4, April</span>
<span class="sd">            2013, Pages 1259-1270. https://doi.org/10.1016/j.bbamem.2013.01.005</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Isothermal area compressibility.&quot;</span>
    <span class="c1">#    self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;ac&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;acm&#39;</span><span class="p">,</span> <span class="s1">&#39;vcm&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of AreaCompressibilityProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">298.15</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># parse input arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1">#output filename for pickle dump of results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>


        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_fluctuation</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;temperature&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>


<div class="viewcode-block" id="AreaCompressibilityProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaCompressibilityProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_fluctuation</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="AreaCompressibilityProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaCompressibilityProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">dimensions</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span><span class="o">/</span><span class="n">dimensions</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
        <span class="n">area_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">fluctuation</span> <span class="o">=</span> <span class="p">(</span><span class="n">area</span> <span class="o">-</span> <span class="n">area_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_fluctuation</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">fluctuation</span><span class="p">)</span>
        <span class="n">X_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">variance</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">area_mean</span> <span class="o">*</span> <span class="n">scicon</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">])</span>
        <span class="c1">#conversion factor for Angstrom^2/Joules to meter^2/Joule</span>
        <span class="n">X_T</span><span class="o">*=</span><span class="mf">10.0</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">23</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span> <span class="n">X_T</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;ac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">AreaCompressibilityProtocol</span>

<span class="c1"># define a new analysis</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lop&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;lop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>

<div class="viewcode-block" id="LateralOrientationParameterProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LateralOrientationParameterProtocol">[docs]</a><span class="k">class</span> <span class="nc">LateralOrientationParameterProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the order parameter for lipid orientation vectors relative to the bilayer normal.</span>

<span class="sd">    This analysis is based on the P-N vector-normal angle analysis discussed</span>
<span class="sd">    in Ref. 1. Using two reference atoms from the specified lipid type a vector</span>
<span class="sd">    for each lipid is computed and the orientation relative to the bilayer</span>
<span class="sd">    normal is computed, i.e. cos(theta), for the angle between the two vectors.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;lop&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">            this analysis. Default: &#39;first&#39;, the first lipid type as stored in</span>
<span class="sd">            the com_frame.</span>
<span class="sd">        ref_atom_1 (str): The atom name of the reference atom to use as the</span>
<span class="sd">            base of the lipid orientation vector.</span>
<span class="sd">        ref_atom_2 (str): The atom name of the reference atom to use as the</span>
<span class="sd">            head of the lipid orientation vector.</span>

<span class="sd">    Note:</span>
<span class="sd">        The lipid orientation vector is defined as ```ref_atom_1```-&gt;```ref_atom_2```.</span>
<span class="sd">        This analysis is only performed for one lipid type, so a new intance of</span>
<span class="sd">        this analysis must be added to the BilayerAnalyzer for each lipid type</span>
<span class="sd">        that is to be analyzed.</span>


<span class="sd">    References:</span>
<span class="sd">        1. Zheng Li, Richard M. Venable, Laura A. Rogers, Diana Murray,</span>
<span class="sd">          and Richard W. Pastor, &quot;Molecular Dynamics Simulations of PIP2 and</span>
<span class="sd">          PIP3 in Lipid Bilayers: Determination of Ring Orientation, and the</span>
<span class="sd">          Effects of Surface Roughness on a Poisson-Boltzmann Description&quot;,</span>
<span class="sd">          Biophys J. 2009 Jul 8; 97(1): 155-163.</span>
<span class="sd">          doi: 10.1016/j.bpj.2009.04.037</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Lateral lipid orientation parameter.&quot;</span>
    <span class="c1">#    self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;lop&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;loa&#39;</span><span class="p">,</span> <span class="s1">&#39;lipid_tilt&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of LateralOrientationParameterProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;P&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;N&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="LateralOrientationParameterProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LateralOrientationParameterProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="c1">#norm_vec = np.zeros(3)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm_vec</span><span class="p">[</span><span class="n">norm</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">res_com</span> <span class="o">=</span> <span class="n">com_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">res_com</span><span class="o">.</span><span class="n">resid</span>

                <span class="n">sel_string</span> <span class="o">=</span> <span class="s2">&quot;resname &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot; and resid &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span>
                <span class="n">res_sel</span> <span class="o">=</span> <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">mda_universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel_string</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">res_sel</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">+=</span> <span class="n">res_sel</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="o">.</span><span class="n">residues</span>
        <span class="n">cos_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
            <span class="n">atom_1</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;residue.</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_1&#39;</span><span class="p">]))</span>
            <span class="n">atom_2</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;residue.</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_2&#39;</span><span class="p">]))</span>
            <span class="c1">#atom_1 = ast.literal_eval(&quot;residue.{}&quot;.format(self.settings[&#39;ref_atom_1&#39;]))</span>
            <span class="c1">#atom_2 = ast.literal_eval(&quot;residue.{}&quot;.format(self.settings[&#39;ref_atom_2&#39;]))</span>
            <span class="n">atom_1_i</span> <span class="o">=</span> <span class="n">atom_1</span><span class="o">.</span><span class="n">index</span>
            <span class="n">atom_2_i</span> <span class="o">=</span> <span class="n">atom_2</span><span class="o">.</span><span class="n">index</span>
            <span class="n">atom_1_coord</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atom_1_i</span><span class="p">]</span>
            <span class="n">atom_2_coord</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atom_2_i</span><span class="p">]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">atom_2_coord</span> <span class="o">-</span> <span class="n">atom_1_coord</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">diff</span><span class="p">))</span>
            <span class="n">cos_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_vec</span><span class="p">)</span><span class="o">/</span><span class="n">dist</span>
            <span class="n">cos_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">cos_t</span><span class="p">)</span>
        <span class="n">cos_t_avg</span> <span class="o">=</span> <span class="n">cos_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">cos_t_avg</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1">#self.running.push(ap</span>
        <span class="n">cos_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_t_avg</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cos_t</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="LateralOrientationParameterProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LateralOrientationParameterProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;lop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LateralOrientationParameterProtocol</span>

<span class="c1"># define a new analysis</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;loa&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;loa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>
<span class="c1">#Based on P-N vector-normal angle:</span>
<span class="c1">#Zheng Li, Richard M. Venable, Laura A. Rogers, Diana Murray,</span>
<span class="c1"># and Richard W. Pastor, &quot;Molecular Dynamics Simulations of PIP2 and PIP3</span>
<span class="c1"># in Lipid Bilayers: Determination of Ring Orientation, and the Effects of</span>
<span class="c1"># Surface Roughness on a Poisson-Boltzmann Description&quot;, Biophys J. 2009 Jul 8;</span>
<span class="c1"># 97(1): 155-163.</span>
<span class="c1"># doi:  10.1016/j.bpj.2009.04.037</span>
<div class="viewcode-block" id="LateralOrientationAngleProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LateralOrientationAngleProtocol">[docs]</a><span class="k">class</span> <span class="nc">LateralOrientationAngleProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the angle for lipid orientation vectors relative to the bilayer normal.</span>

<span class="sd">    This analysis is based on the P-N vector-normal angle analysis discussed</span>
<span class="sd">    in Ref. 1. Using two reference atoms from the specified lipid type a vector</span>
<span class="sd">    for each lipid is computed and the orientation relative to the bilayer</span>
<span class="sd">    normal is computed, i.e. theta, or the angle between the two vectors.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;loa&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">            this analysis. Default: &#39;first&#39;, the first lipid type as stored in</span>
<span class="sd">            the com_frame.</span>
<span class="sd">        ref_atom_1 (str): The atom name of the reference atom to use as the</span>
<span class="sd">            base of the lipid orientation vector.</span>
<span class="sd">        ref_atom_2 (str): The atom name of the reference atom to use as the</span>
<span class="sd">            head of the lipid orientation vector.</span>

<span class="sd">    Note:</span>
<span class="sd">        The lipid orientation vector is defined as ```ref_atom_1```-&gt;```ref_atom_2```.</span>
<span class="sd">        This analysis is only performed for one lipid type, so a new intance of</span>
<span class="sd">        this analysis must be added to the BilayerAnalyzer for each lipid type</span>
<span class="sd">        that is to be analyzed.</span>


<span class="sd">    References:</span>
<span class="sd">        1. Zheng Li, Richard M. Venable, Laura A. Rogers, Diana Murray,</span>
<span class="sd">          and Richard W. Pastor, &quot;Molecular Dynamics Simulations of PIP2 and</span>
<span class="sd">          PIP3 in Lipid Bilayers: Determination of Ring Orientation, and the</span>
<span class="sd">          Effects of Surface Roughness on a Poisson-Boltzmann Description&quot;,</span>
<span class="sd">          Biophys J. 2009 Jul 8; 97(1): 155-163.</span>
<span class="sd">          doi: 10.1016/j.bpj.2009.04.037</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Lateral lipid orientation angle.&quot;</span>
    <span class="c1">#    self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;loa&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;lop&#39;</span><span class="p">,</span> <span class="s1">&#39;lipid_tilt&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of LateralOrientationAngleProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;P&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;N&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="LateralOrientationAngleProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LateralOrientationAngleProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="c1">#norm_vec = np.zeros(3)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm_vec</span><span class="p">[</span><span class="n">norm</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">res_com</span> <span class="o">=</span> <span class="n">com_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">res_com</span><span class="o">.</span><span class="n">resid</span>

                <span class="n">sel_string</span> <span class="o">=</span> <span class="s2">&quot;resname &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot; and resid &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span>
                <span class="n">res_sel</span> <span class="o">=</span> <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">mda_universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel_string</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">res_sel</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">+=</span> <span class="n">res_sel</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="o">.</span><span class="n">residues</span>
        <span class="n">cos_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
            <span class="n">atom_1</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;residue.&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_1&#39;</span><span class="p">])</span>
            <span class="n">atom_2</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;residue.&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_2&#39;</span><span class="p">])</span>
            <span class="n">atom_1_i</span> <span class="o">=</span> <span class="n">atom_1</span><span class="o">.</span><span class="n">index</span>
            <span class="n">atom_2_i</span> <span class="o">=</span> <span class="n">atom_2</span><span class="o">.</span><span class="n">index</span>
            <span class="n">atom_1_coord</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atom_1_i</span><span class="p">]</span>
            <span class="n">atom_2_coord</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atom_2_i</span><span class="p">]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">atom_2_coord</span> <span class="o">-</span> <span class="n">atom_1_coord</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">diff</span><span class="p">))</span>
            <span class="n">cos_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_vec</span><span class="p">)</span><span class="o">/</span><span class="n">dist</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="mf">90.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cos_t</span><span class="p">)</span><span class="o">*</span><span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

            <span class="n">cos_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">cos_t_avg</span> <span class="o">=</span> <span class="n">cos_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">cos_t_avg</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1">#self.running.push(ap</span>
        <span class="n">cos_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_t_avg</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cos_t</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="LateralOrientationAngleProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LateralOrientationAngleProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;loa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LateralOrientationAngleProtocol</span>

<span class="c1"># define a new analysis &#39;flip_flop&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;flip_flop&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;flip_flop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="FlipFlopProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.FlipFlopProtocol">[docs]</a><span class="k">class</span> <span class="nc">FlipFlopProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Count any lipid flips flops between the leaflets.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;flip_flop&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        None</span>

<span class="sd">    References:</span>
<span class="sd">        1. Andrey A. Gurtovenko, and Ilpo Vattulainen, Molecular Mechanism</span>
<span class="sd">            for Lipid Flip-Flops, The Journal of Physical Chemistry B, 2007</span>
<span class="sd">            111 (48), 13554-13559, DOI: 10.1021/jp077094k</span>
<span class="sd">            http://pubs.acs.org/doi/abs/10.1021/jp077094k?journalCode=jpcbfk</span>

<span class="sd">        2. Nicolas Sapay, W. F. Drew Bennett, and D. Peter Tieleman,</span>
<span class="sd">            Molecular Simulations of Lipid Flip-Flop in the Presence of</span>
<span class="sd">            Model Transmembrane Helices, Biochemistry, 2010 49 (35),</span>
<span class="sd">            7665-7673, DOI: 10.1021/bi100878q</span>
<span class="sd">            http://pubs.acs.org/doi/abs/10.1021/bi100878q</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Count lipid flip flops.&quot;</span>
    <span class="c1">#    self._return_length = 2</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;flip_flop&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of FlipFlopProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_leaf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span>


<div class="viewcode-block" id="FlipFlopProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.FlipFlopProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reference_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reference_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">leaflet</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">resnames</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">resname</span> <span class="ow">in</span> <span class="n">resnames</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">resname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resnames</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">resname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resnames</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">resname</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;events&#39;</span><span class="p">:[]}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="n">curr_leaflets</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">leaflet</span> <span class="ow">in</span> <span class="n">curr_leaflets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">o_leaf</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">curr_leaflets</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">leaf</span> <span class="o">!=</span> <span class="n">leaflet</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_leaf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">o_leaf</span> <span class="o">=</span> <span class="n">o_leaf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">o_leaf</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">curr_leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reference_leaf</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>
            <span class="c1"># o_leaf -&gt; leaflet</span>
            <span class="n">forward_diff</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="c1"># leaflet -&gt; o_leaf</span>
            <span class="n">backward_diff</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">forward_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">forward_diff</span><span class="p">:</span>
                    <span class="n">resname</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                    <span class="n">resid</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">resid</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
                    <span class="n">frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mdnumber</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">resname</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">resname</span><span class="p">][</span><span class="s1">&#39;events&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">frame</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span>
                                                            <span class="n">o_leaf</span><span class="p">,</span> <span class="n">leaflet</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">backward_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">backward_diff</span><span class="p">:</span>
                    <span class="n">resname</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                    <span class="n">resid</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">resid</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
                    <span class="n">frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mdnumber</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">resname</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">resname</span><span class="p">][</span><span class="s1">&#39;events&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">frame</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span>
                                                            <span class="n">leaflet</span><span class="p">,</span> <span class="n">o_leaf</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">forward_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">backward_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reference_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reference_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="k">break</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="FlipFlopProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.FlipFlopProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dumps the outputs of this protocol to disc.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, Optional): The string containing the path to the location</span>
<span class="sd">                that the analysis results should be dumped to on disc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="FlipFlopProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.FlipFlopProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the analysis_output of this protocol. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div>

<div class="viewcode-block" id="FlipFlopProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.FlipFlopProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the analysis by resetting the outputs and any necessary</span>
<span class="sd">        internal variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_leaf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span></div></div>
<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;flip_flop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FlipFlopProtocol</span>

<span class="c1"># define a new analysis &#39;lipid_length&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lipid_length&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;lipid_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;vector_frame&#39;</span>

<div class="viewcode-block" id="LipidLengthProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LipidLengthProtocol">[docs]</a><span class="k">class</span> <span class="nc">LipidLengthProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the lipids length using the defined lipid vector.</span>

<span class="sd">    This analysis is used to compute the mean lipid length using</span>
<span class="sd">    the vector represetation of the specified lipids.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;lipid_length&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">            this analysis. Default: &#39;all&#39;, averages over all lipid types.</span>

<span class="sd">    References:</span>
<span class="sd">        1. Anton O. Chugunov,  Pavel E. Volynsky, Nikolay A. Krylov,</span>
<span class="sd">            Ivan A. Boldyrev, and Roman G. Efremov,  Liquid but Durable:</span>
<span class="sd">            Molecular Dynamics Simulations Explain the Unique Properties of</span>
<span class="sd">            Archaeal-Like Membranes, Scientific Reports, 4:7462, 2014,</span>
<span class="sd">            doi:10.1038/srep07462</span>
<span class="sd">            (https://www.nature.com/articles/srep07462)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Lipid length using the lipid vectors.&quot;</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;lipid_length&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of LipidLengthProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>


<div class="viewcode-block" id="LipidLengthProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LipidLengthProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">leaflet</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">vec_curr</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>
            <span class="n">lengths</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_curr</span><span class="p">,</span> <span class="n">vec_curr</span><span class="p">))</span>
            <span class="c1">#l_full = np.sqrt(np.dot(vec_curr, vec_curr))</span>
            <span class="c1">#vec_curr[0] = 0.0</span>
            <span class="c1">#vec_curr[1] = 0.0</span>
            <span class="c1">#l_z = np.sqrt(np.dot(vec_curr, vec_curr))</span>
            <span class="c1">#l_z = np.abs(vec_curr[2])</span>
            <span class="c1">#if l_full &lt; 30.0:</span>
            <span class="c1">#    print(l_full, l_z)</span>
            <span class="c1">#lengths[count] = l_z</span>
            <span class="c1">#if lengths[count] &gt; 30.0:</span>
            <span class="c1">#    print(lengths[count])</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1">#quit()</span>
            <span class="c1"># get the current com frame list</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1"># get the msd for the current selection</span>
        <span class="c1"># The extract is a patch to exclude vectors that are broken across periodic boundaries</span>
        <span class="n">mean_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">lengths</span> <span class="o">&lt;</span> <span class="mf">30.0</span><span class="p">,</span> <span class="n">lengths</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">lipid_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tc</span><span class="p">,</span> <span class="n">mean_length</span><span class="p">])</span>
        <span class="c1">#print(lipid_length)</span>
        <span class="c1">#quit()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lipid_length</span><span class="p">)</span>
        <span class="k">return</span></div></div>

<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;lipid_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LipidLengthProtocol</span>

<span class="c1"># define a new analysis</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lipid_tilt&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;lipid_tilt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;vector_frame&#39;</span>

<div class="viewcode-block" id="LipidTiltProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LipidTiltProtocol">[docs]</a><span class="k">class</span> <span class="nc">LipidTiltProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the lipids tilt angles using the defined lipid vector.</span>

<span class="sd">    This analyis estimates the mean lipid tilt using the vector represetation</span>
<span class="sd">    of the specified lipids in reference to a particular axis, typically the</span>
<span class="sd">    bilayer normal.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;lipid_tilt&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;upper&#39;</span>
<span class="sd">        resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">            this analysis. Default: &#39;all&#39;, averages over all lipid types.</span>
<span class="sd">        style (str: &#39;angle&#39;, &#39;order&#39;): Specify whether to compute the</span>
<span class="sd">            tilt angle (&#39;angle&#39;) or the tilt angle order parameter (&#39;order&#39;).</span>
<span class="sd">            Default: &#39;angle&#39;</span>
<span class="sd">        ref_axis (str: &#39;x&#39;, &#39;y&#39;, or &#39;z&#39;): Specify the reference axis that</span>
<span class="sd">            should be used to estimate the tilt. This is typically the</span>
<span class="sd">            axis along the bilayer normal. Default: &#39;z&#39;</span>

<span class="sd">    References:</span>
<span class="sd">        1. Anton O. Chugunov,  Pavel E. Volynsky, Nikolay A. Krylov,</span>
<span class="sd">            Ivan A. Boldyrev, and Roman G. Efremov,  Liquid but Durable:</span>
<span class="sd">            Molecular Dynamics Simulations Explain the Unique Properties of</span>
<span class="sd">            Archaeal-Like Membranes, Scientific Reports, 4:7462, 2014,</span>
<span class="sd">            doi:10.1038/srep07462</span>
<span class="sd">            (https://www.nature.com/articles/srep07462)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Lipid tilt using the lipid vectors.&quot;</span>
    <span class="c1">#    self._return_length = 2</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;lipid_tilt&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;loa&#39;</span><span class="p">,</span> <span class="s1">&#39;lipid_collinearity&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of LipidTiltProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;angle&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;z&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>


<div class="viewcode-block" id="LipidTiltProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LipidTiltProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">leaflet</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">indices</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_axis&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_axis&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_axis&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">vec_curr</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span>
                <span class="n">vec_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_curr</span><span class="p">,</span> <span class="n">vec_curr</span><span class="p">))</span>
                <span class="n">angle_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_curr</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span><span class="p">)</span><span class="o">/</span><span class="n">vec_length</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="mf">90.0</span> <span class="o">-</span> <span class="n">angle_rad</span><span class="o">*</span><span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;order&#39;</span><span class="p">:</span>
                <span class="n">vec_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_curr</span><span class="p">,</span> <span class="n">vec_curr</span><span class="p">))</span>
                <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_curr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span><span class="p">)</span><span class="o">/</span><span class="n">vec_length</span>

            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># get the current com frame list</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1"># get the msd for the current selection</span>
        <span class="n">mean_value</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">lipid_tilt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tc</span><span class="p">,</span> <span class="n">mean_value</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lipid_tilt</span><span class="p">)</span>
        <span class="k">return</span></div></div>


<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;lipid_tilt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LipidTiltProtocol</span>

<span class="c1"># define a new analysis</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lipid_collinearity&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;lipid_collinearity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;vector_frame&#39;</span>

<div class="viewcode-block" id="LipidCollinearityProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LipidCollinearityProtocol">[docs]</a><span class="k">class</span> <span class="nc">LipidCollinearityProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the lipid-lipid collinearity angles.</span>

<span class="sd">    This analysis computes the mean lipid-lipid collinearity angle (or order</span>
<span class="sd">    parameter) using the vector represetation of the specified lipids.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;lipid_collinearity&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;upper&#39;</span>
<span class="sd">        resname_1 (str): Specify the resname of the reference lipid type to</span>
<span class="sd">            include in this analysis. Default: &#39;first&#39;, the first lipid in</span>
<span class="sd">            the list pulled from the com_frame representation.</span>
<span class="sd">        resname_2 (str): Specify the resname of the target lipid type to</span>
<span class="sd">            include in this analysis. Default: &#39;first&#39;, the first lipid in</span>
<span class="sd">            the list pulled from the com_frame representation.</span>
<span class="sd">        style (str: &#39;angle&#39;, &#39;order&#39;): Specify whether to compute the</span>
<span class="sd">            tilt angle (&#39;angle&#39;) or the tilt angle order parameter (&#39;order&#39;).</span>
<span class="sd">            Default: &#39;angle&#39;</span>

<span class="sd">    References:</span>
<span class="sd">        1. Anton O. Chugunov,  Pavel E. Volynsky, Nikolay A. Krylov,</span>
<span class="sd">            Ivan A. Boldyrev, and Roman G. Efremov,  Liquid but Durable:</span>
<span class="sd">            Molecular Dynamics Simulations Explain the Unique Properties of</span>
<span class="sd">            Archaeal-Like Membranes, Scientific Reports, 4:7462, 2014,</span>
<span class="sd">            doi:10.1038/srep07462</span>
<span class="sd">            (https://www.nature.com/articles/srep07462)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Lipid-lipid collinearity.&quot;</span>
    <span class="c1">#    self._return_length = 2</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;lipid_collinearity&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;lipid_tilt&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of LipidCollinearityProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;angle&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices_1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices_2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

<div class="viewcode-block" id="LipidCollinearityProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LipidCollinearityProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;leaflet: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">leaflet</span><span class="p">)))</span>
            <span class="n">group_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span>
            <span class="n">group_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span>
            <span class="n">lipid_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nlipids</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">leaflet_name</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet_name</span><span class="p">]</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="n">nlipids</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lipid_types</span><span class="p">:</span>
                        <span class="n">lipid_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">indices_1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">indices_2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices_1</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_1</span><span class="p">)</span>
                    <span class="n">indices_2</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices_1</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_1</span><span class="p">)</span>
                <span class="n">indices_2</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices_1</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_1</span><span class="p">)</span>
                <span class="n">indices_2</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">leaflet</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices_1</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_1</span><span class="p">)</span>
                    <span class="n">indices_2</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices_1</span> <span class="o">=</span> <span class="n">indices_1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices_2</span> <span class="o">=</span> <span class="n">indices_2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">indices_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_1</span>
        <span class="n">indices_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_2</span>
        <span class="n">n_com_1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_1</span><span class="p">)</span>
        <span class="n">n_com_2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_2</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com_1</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">indices_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vec_i</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidvec</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>
                <span class="n">vec_i_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="n">vec_i</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_com_1</span><span class="p">):</span>
                    <span class="n">jj</span> <span class="o">=</span> <span class="n">indices_1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">vec_j</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidvec</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>
                    <span class="n">vec_j_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_j</span><span class="p">,</span> <span class="n">vec_j</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span>
                        <span class="n">angle_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="n">vec_j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vec_i_l</span><span class="o">*</span><span class="n">vec_j_l</span><span class="p">))</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle_rad</span><span class="o">*</span><span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;order&#39;</span><span class="p">:</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="n">vec_j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vec_i_l</span><span class="o">*</span><span class="n">vec_j_l</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com_1</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">indices_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vec_i</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidvec</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>
                <span class="n">vec_i_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="n">vec_i</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com_2</span><span class="p">):</span>
                    <span class="n">jj</span> <span class="o">=</span> <span class="n">indices_2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">vec_j</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidvec</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>
                    <span class="n">vec_j_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_j</span><span class="p">,</span> <span class="n">vec_j</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span>
                        <span class="n">angle_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="n">vec_j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vec_i_l</span><span class="o">*</span><span class="n">vec_j_l</span><span class="p">))</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle_rad</span><span class="o">*</span><span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;order&#39;</span><span class="p">:</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="n">vec_j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vec_i_l</span><span class="o">*</span><span class="n">vec_j_l</span><span class="p">))</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="c1"># get the current com frame list</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1"># get the msd for the current selection</span>
        <span class="n">mean_value</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">lipid_collinearity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tc</span><span class="p">,</span> <span class="n">mean_value</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lipid_collinearity</span><span class="p">)</span>
        <span class="k">return</span></div></div>


<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;lipid_collinearity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LipidCollinearityProtocol</span>


<span class="c1"># define a new analysis &#39;msd&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;halperin_nelson&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;halperin_nelson&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="HalperinNelsonProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.HalperinNelsonProtocol">[docs]</a><span class="k">class</span> <span class="nc">HalperinNelsonProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the mean hexagonal packing orientation parameter.</span>

<span class="sd">    This analysis implements Halperin and</span>
<span class="sd">    Nelson&#39;s rotational invariant to estimate the hexagonal packing orientation</span>
<span class="sd">    parameter. The value for lipid l is given by</span>
<span class="sd">        phi_l = | (1/6) * sum_{j element nn(l)} exp(6i*theta_{lj}) |^2 ,</span>
<span class="sd">    where i is complex and nn(l) are the 6 nearest neighbors of lipid</span>
<span class="sd">    l; theta_{lj} is the angle between the vector formed by beads</span>
<span class="sd">    representing lipid l and j and an arbitrary axis. The value is unity</span>
<span class="sd">    for perfect hexagonal packing, and it is zero to the extent that</span>
<span class="sd">    hexagonal packing is entirely absent. This protocol uses the &#39;com_frame&#39;</span>
<span class="sd">    representation of the bilayer.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;halperin_nelson&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;upper&#39;</span>

<span class="sd">    References:</span>
<span class="sd">        1. Shachi Katira, Kranthi K. Mandadapu, Suriyanarayanan</span>
<span class="sd">            Vaikuntanathan, Berend Smit, and David Chandler, The</span>
<span class="sd">            order-disorder transition in model lipid bilayers is a</span>
<span class="sd">            first-order hexatic to liquid phase transition, arXiv preprint</span>
<span class="sd">            [cond-mat.soft] 2015, arXiv:1506.04310.</span>
<span class="sd">            https://arxiv.org/pdf/1506.04310.pdf</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Halperin and Nelson&#39;s rotational invariant.&quot;</span>
    <span class="c1">#    self._return_length = 2</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;halperin_nelson&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of HalperinNelsonProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_distance_euclidean_pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_a</span><span class="p">,</span> <span class="n">v_b</span><span class="p">,</span> <span class="n">box_lengths</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;box_half&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">center</span> <span class="o">==</span> <span class="s1">&#39;zero&#39;</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v_a</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">center</span> <span class="o">==</span> <span class="s1">&#39;box_half&#39;</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">box_lengths</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="c1">#shift center to zero for minimum image</span>
        <span class="n">v_a</span> <span class="o">=</span> <span class="n">v_a</span> <span class="o">-</span> <span class="n">center</span>
        <span class="n">v_b</span> <span class="o">=</span> <span class="n">v_b</span> <span class="o">-</span> <span class="n">center</span>
        <span class="c1">#difference</span>
        <span class="n">d_v</span> <span class="o">=</span> <span class="n">v_a</span> <span class="o">-</span> <span class="n">v_b</span>
        <span class="n">d_v_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">d_v</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_a</span><span class="p">)</span>
        <span class="c1">#check for minimum image</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">v_i</span> <span class="o">=</span> <span class="n">d_v_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">box_i</span> <span class="o">=</span> <span class="n">box_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">box_i_h</span> <span class="o">=</span> <span class="n">box_i</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="k">if</span> <span class="n">v_i</span> <span class="o">&gt;</span> <span class="n">box_i_h</span><span class="p">:</span>
                <span class="n">d_v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_i</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">v_a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">v_b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d_v</span><span class="p">,</span> <span class="n">d_v</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d_v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_6nn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">com_frame</span><span class="p">,</span> <span class="n">lateral</span><span class="p">):</span>
        <span class="n">k</span><span class="o">=</span><span class="mi">6</span>
        <span class="c1">#initialize knn dict</span>
        <span class="n">knn</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">}</span>
        <span class="c1">#make sure X has the right shape for the cdist function</span>
        <span class="n">nX</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">[[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>\
         <span class="bp">self</span><span class="o">.</span><span class="n">_distance_euclidean_pbc</span><span class="p">(</span><span class="n">com_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">lateral</span><span class="p">],</span>\
         <span class="n">com_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">lateral</span><span class="p">],</span> <span class="n">com_frame</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">lateral</span><span class="p">],</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;box_half&#39;</span><span class="p">)]</span> \
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nX</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nX</span><span class="p">)]</span>
        <span class="c1">#sort distances</span>
        <span class="n">distances</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1">#pick up the k nearest</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">knn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">knn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">j</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="o">-</span><span class="n">vec</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">knn</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">knn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">vec</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">knn</span>

<div class="viewcode-block" id="HalperinNelsonProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.HalperinNelsonProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="c1">#determine the frame intervals</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">indices</span>
            <span class="c1">#self.analysis_output.append([])</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="c1"># initialize a running stats object to do the averaging over resids</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_6nn</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">],</span>
                                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">])</span>
        <span class="n">hn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">nn</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">nn_curr</span> <span class="o">=</span> <span class="n">nn</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">nn_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nn_curr</span><span class="p">:</span>
                <span class="n">n_ind</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">vec_l</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span><span class="p">)</span><span class="o">/</span><span class="n">vec_l</span>
                <span class="n">nn_sum</span><span class="o">+=</span><span class="n">cmath</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">6</span><span class="n">j</span><span class="o">*</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">hn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">nn_sum</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1">#for val in hn:</span>
        <span class="c1">#    print(&quot;hn: {}&quot;.format(val))</span>
        <span class="n">hn_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hn</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">hn_mean</span><span class="p">])</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="HalperinNelsonProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.HalperinNelsonProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span></div></div>

<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;halperin_nelson&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HalperinNelsonProtocol</span>

<span class="c1"># define a new analysis protocol</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;area_fluctuation&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;area_fluctuation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="AreaFluctuationProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaFluctuationProtocol">[docs]</a><span class="k">class</span> <span class="nc">AreaFluctuationProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the area fluctuation in the box along the bilayer laterals.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;area_fluctuation&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        None</span>

<span class="sd">    References:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Bilayer lateral box area fluctuation.&quot;</span>
    <span class="c1">#    self._return_length = 2</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;area_fluctuation&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;acm&#39;</span><span class="p">,</span> <span class="s1">&#39;ac&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of AreaFluctuationProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_sq_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>


<div class="viewcode-block" id="AreaFluctuationProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaFluctuationProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="n">area</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_sq_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">area</span><span class="o">*</span><span class="n">area</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">area_fluctuation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_area_sq_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">area_fluctuation</span><span class="p">])</span>
        <span class="c1"># print([ba_reps[&#39;com_frame&#39;].time, area, area_fluctuation])</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="AreaFluctuationProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaFluctuationProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_run</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_sq_run</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span></div></div>

<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;area_fluctuation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">AreaFluctuationProtocol</span>

<span class="c1"># define a new analysis &#39;disp_vec&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;disp_vec_corr_avg&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;disp_vec_corr_avg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="DispVecCorrelationAverageProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationAverageProtocol">[docs]</a><span class="k">class</span> <span class="nc">DispVecCorrelationAverageProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the pair-wise cross correlation between pairs of the displacement vectors for each lipid in the specified leaflet(s) of bilayer and do a inverse-distance weighted averaging.</span>

<span class="sd">    This analysis computes the displacement vectors as in DispVecProtocol,</span>
<span class="sd">    but then continues to compute the pair-wise cross correlations between</span>
<span class="sd">    each vector (i.e. the cos(theta) for the angle theta between the</span>
<span class="sd">    vectors) and averages the values using the inverse of the distance</span>
<span class="sd">    between the vector starting points as a weight.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;disp_vec_corr_avg&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">            this analysis. Default: &#39;all&#39;, includes all lipid types.</span>
<span class="sd">        wrapped (bool): Specify whether to use the wrapped (&#39;True&#39;) or</span>
<span class="sd">            un-wrapped (&#39;False&#39;) coordintes for the base of the vectors.</span>
<span class="sd">            Default: False</span>
<span class="sd">        interval (int): Sets the frame interval over which to compute the</span>
<span class="sd">                displacement vectors.</span>

<span class="sd">    References:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Weighted average of displacement vector correlations.&quot;</span>
    <span class="c1">#    self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;disp_vec_corr_avg&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;disp_vec&#39;</span><span class="p">,</span> <span class="s1">&#39;disp_vec_corr&#39;</span><span class="p">,</span> <span class="s1">&#39;disp_vec_nncorr&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of DispVecCorrelationAverageProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;interval&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;wrapped&#39;</span><span class="p">:</span>
                    <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">]</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_arg</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="DispVecCorrelationAverageProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationAverageProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecCorrelationAverageProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationAverageProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">frame</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">frame</span>

        <span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_frame</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span><span class="p">)</span>
        <span class="c1">#print (interval, &quot; &quot;, self.settings[&#39;interval&#39;])</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;lower&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;bad setting for </span><span class="se">\&#39;</span><span class="s2">leaflet</span><span class="se">\&#39;</span><span class="s2"> in &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;. Using default </span><span class="se">\&#39;</span><span class="s2">both</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">x_index</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y_index</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">box_x</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">x_index</span><span class="p">]</span>
            <span class="n">box_y</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">y_index</span><span class="p">]</span>
            <span class="n">l_box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">box_x</span><span class="p">,</span> <span class="n">box_y</span><span class="p">])</span>
            <span class="n">box_x_h</span> <span class="o">=</span> <span class="n">box_x</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">box_y_h</span> <span class="o">=</span> <span class="n">box_y</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="c1"># get the current frame</span>
            <span class="n">curr_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="n">prev_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span>
            <span class="c1"># get the coordinates for the selection at this frame</span>
            <span class="n">vec_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="c1"># vec_ends = []</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">resnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">resname</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                <span class="n">resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span>
                <span class="n">com_i_uw</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j_uw</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">d_v</span> <span class="o">=</span> <span class="n">vector_difference_pbc</span><span class="p">(</span><span class="n">com_j</span><span class="p">,</span> <span class="n">com_i</span><span class="p">,</span> <span class="n">l_box</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;box_half&#39;</span><span class="p">)</span>
                <span class="n">ddv</span> <span class="o">=</span> <span class="n">com_i</span> <span class="o">-</span> <span class="n">com_j</span>
                <span class="c1">#print &quot; ddv: &quot;,ddv, &quot; box_l: &quot;, l_box</span>
                <span class="c1">#print &quot;com_j: &quot;,com_j,&quot; com_i: &quot;,com_i,&quot; d_v: &quot;,d_v</span>
                <span class="c1">#print</span>
                <span class="c1">#if not np.allclose(ddv, d_v):</span>
                <span class="c1">#    quit()</span>
                <span class="c1">#print(d_v)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">d_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d_v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">d_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d_v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


                <span class="c1">#    vec_ends.append([com_j[0],com_j[0],com_i[0]-com_j[0],com_i[1]-com_j[1]])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">n_inter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cos_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">total_pos</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">weight_pos</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">total_neg</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">weight_neg</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">weight_tot</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com</span><span class="p">):</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">index_i</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vec_end_a</span> <span class="o">=</span> <span class="n">vec_ends</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vec_a</span> <span class="o">=</span> <span class="n">vec_end_a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec_end_a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">com_i_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index_i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_com</span><span class="p">):</span>
                    <span class="n">index_j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">vec_end_b</span> <span class="o">=</span> <span class="n">vec_ends</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">vec_b</span> <span class="o">=</span> <span class="n">vec_end_b</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec_end_b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_a</span><span class="p">,</span> <span class="n">vec_b</span><span class="p">)</span>
                    <span class="n">cos_t</span> <span class="o">=</span> <span class="n">dot</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_a</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_b</span><span class="p">))</span>
                    <span class="c1">#print &quot;cos_t: &quot;, cos_t, &quot; vev_a: &quot;, vec_a, &quot; vec_b: &quot;, vec_b</span>
                    <span class="n">com_j_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index_j</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                    <span class="n">pos_a</span> <span class="o">=</span> <span class="n">com_i_w</span><span class="p">[[</span><span class="n">x_index</span><span class="p">,</span> <span class="n">y_index</span><span class="p">]]</span>
                    <span class="n">pos_b</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[[</span><span class="n">x_index</span><span class="p">,</span> <span class="n">y_index</span><span class="p">]]</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">distance_euclidean_pbc</span><span class="p">(</span><span class="n">pos_a</span><span class="p">,</span> <span class="n">pos_b</span><span class="p">,</span> <span class="n">l_box</span><span class="p">,</span>
                                                         <span class="n">center</span><span class="o">=</span><span class="s1">&#39;box_half&#39;</span><span class="p">)</span>
                    <span class="c1">#print &quot; dist: &quot;, dist, &quot; cos_t: &quot;,cos_t</span>
                    <span class="c1">#if dist &lt; 60.0:</span>
                    <span class="n">total</span> <span class="o">+=</span> <span class="n">cos_t</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">dist</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">weights</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">dist</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">n_inter</span> <span class="o">+=</span> <span class="mf">1.0</span>
                    <span class="n">cos_sum</span> <span class="o">+=</span> <span class="n">cos_t</span>
                    <span class="n">weight_tot</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">dist</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cos_t</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">total_pos</span> <span class="o">+=</span> <span class="n">cos_t</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">dist</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">weight_pos</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">dist</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">cos_t</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">total_neg</span> <span class="o">+=</span> <span class="n">cos_t</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">dist</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">weight_neg</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">dist</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">j</span><span class="p">,</span> <span class="n">cos_t</span><span class="p">,</span> <span class="n">dist</span><span class="p">])</span>
                    <span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">cos_t</span><span class="p">,</span> <span class="n">dist</span><span class="p">])</span>
            <span class="n">nn_total</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">nn_weights</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">cos_sum</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com</span><span class="p">):</span>
                <span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">n_neighbors</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="c1">#print(n_neighbors[:6])</span>
                <span class="n">coss</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">diss</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">n_neighbors</span><span class="p">[:</span><span class="mi">6</span><span class="p">]:</span>
                    <span class="n">coss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">diss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">cos_sum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">coss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coss</span><span class="p">)</span>
                <span class="n">diss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">diss</span><span class="p">)</span>
                <span class="n">w_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">coss</span><span class="o">/</span><span class="n">diss</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">diss</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">nn_total</span> <span class="o">+=</span> <span class="n">w_val</span>
                <span class="n">nn_weights</span> <span class="o">+=</span> <span class="mf">1.0</span>
            <span class="c1">#     total += (coss/diss).sum()</span>
            <span class="c1">#     weights += (1.0/diss).sum()</span>
            <span class="c1">#     #print(np.array(coss).mean())</span>
            <span class="c1">#     #print(n_neighbors[0])</span>
            <span class="c1">#     #print</span>
            <span class="c1">#cos_sum = np.array(cos_sum)</span>
            <span class="n">w_avg</span> <span class="o">=</span> <span class="n">total</span><span class="o">/</span><span class="n">weights</span>
            <span class="n">w_avg_pos</span> <span class="o">=</span> <span class="n">total_pos</span><span class="o">/</span><span class="n">weight_pos</span>
            <span class="n">w_avg_neg</span> <span class="o">=</span> <span class="n">total_neg</span><span class="o">/</span><span class="n">weight_neg</span>
            <span class="n">f_pos</span> <span class="o">=</span> <span class="n">weight_pos</span><span class="o">/</span><span class="n">weight_tot</span>
            <span class="n">f_neg</span> <span class="o">=</span> <span class="n">weight_neg</span><span class="o">/</span><span class="n">weight_tot</span>
            <span class="n">nn_w_avg</span> <span class="o">=</span> <span class="n">nn_total</span><span class="o">/</span><span class="n">nn_weights</span>
            <span class="c1">#print &quot;w_avg: &quot;, w_avg, &quot; total: &quot;,total,&quot; weights: &quot;,weights</span>
            <span class="c1">#print &quot;w_avg_pos: &quot;, total_pos/weight_pos, &quot; total_pos: &quot;, total_pos, &quot; weight_pos: &quot;,weight_pos</span>
            <span class="c1">#print &quot;w_avg_neg: &quot;, total_neg/weight_neg, &quot; total_neg: &quot;, total_neg, &quot; weight_neg: &quot;,weight_neg</span>
            <span class="c1">#quit()</span>
            <span class="nb">print</span><span class="p">(([</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">w_avg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_running</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()]))</span>
            <span class="c1">#quit()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">w_avg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                                         <span class="n">w_avg</span><span class="p">,</span> <span class="n">nn_w_avg</span><span class="p">,</span>
                                         <span class="n">w_avg_pos</span><span class="p">,</span> <span class="n">w_avg_neg</span><span class="p">,</span> <span class="n">f_pos</span><span class="p">,</span> <span class="n">f_neg</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="n">current_frame</span>
            <span class="c1">#return vec_ends</span>
        <span class="k">return</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;disp_vec_corr_avg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DispVecCorrelationAverageProtocol</span>

<span class="c1"># define a new analysis</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;com_lateral_rdf&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;com_lateral_rdf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>

<div class="viewcode-block" id="COMLateralRDFProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.COMLateralRDFProtocol">[docs]</a><span class="k">class</span> <span class="nc">COMLateralRDFProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the 2-d radial pair distribution function in the bilayer lateral plane using the lipid centers of mass.</span>

<span class="sd">    This analysis protocol uses the &#39;com_frame&#39; representation.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;com_lateral_rdf&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname_1 (str): Specify the resname of the reference lipid type to</span>
<span class="sd">            include in this analysis. Default: &#39;first&#39;, the first lipid in</span>
<span class="sd">            the list pulled from the com_frame representation.</span>
<span class="sd">        resname_2 (str): Specify the resname of the target lipid type to</span>
<span class="sd">            include in this analysis. Default: &#39;first&#39;, the first lipid in</span>
<span class="sd">            the list pulled from the com_frame representation.</span>
<span class="sd">        n_bins (int): Specifies the number of bins to use when estimating</span>
<span class="sd">            the RDF. Default: 25</span>
<span class="sd">        range_inner (float): Specify the inner distance cutoff for the RDF.</span>
<span class="sd">            Default: 0.0</span>
<span class="sd">        range_outer (float): Specify the outer distance cutoff for the RDF.</span>
<span class="sd">            Default: 25.0</span>


<span class="sd">    References:</span>
<span class="sd">        1. Microsecond Molecular Dynamics Simulations of Lipid Mixing</span>
<span class="sd">            Chunkit Hong, D. Peter Tieleman, and Yi Wang Langmuir 2014 30</span>
<span class="sd">            (40), 11993-12001 DOI: 10.1021/la502363b</span>
<span class="sd">            http://pubs.acs.org/doi/abs/10.1021/la502363b</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Lipid-lipid RDF in the bilayer lateral plane.&quot;</span>
    <span class="c1"># self._return_length = 2</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;com_lateral_rdf&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;nnf&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of COMLateralRDFProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_bins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">25</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;range_inner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;range_outer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">25.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#parse input arguments/settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># for outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N_a</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N_b</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_leaf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;n_bins&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;range_inner&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;range_outer&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="COMLateralRDFProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.COMLateralRDFProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N_a</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N_b</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_leaf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_run</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="COMLateralRDFProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.COMLateralRDFProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># initialize the RDF histogram</span>
            <span class="n">rdf_range</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;range_inner&#39;</span><span class="p">],</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;range_outer&#39;</span><span class="p">]]</span>
            <span class="n">count</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_bins&#39;</span><span class="p">],</span>
                                        <span class="nb">range</span><span class="o">=</span><span class="n">rdf_range</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">*=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="n">count</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="n">edges</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="c1"># build group/resname/lipid type list</span>
            <span class="n">lipid_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nlipids</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">leaflet_name</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">leaflet</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet_name</span><span class="p">]</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="n">nlipids</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflet</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lipid_types</span><span class="p">:</span>
                        <span class="n">lipid_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">n_ltypes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lipid_types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lipid_types</span> <span class="o">=</span> <span class="n">lipid_types</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_ltypes</span> <span class="o">=</span> <span class="n">n_ltypes</span>
            <span class="n">n_leaf</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">leaflet_name</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">n_leaf</span> <span class="o">+=</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_leaf</span> <span class="o">=</span> <span class="n">n_leaf</span>

        <span class="n">lipid_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipid_types</span>
        <span class="n">n_ltypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ltypes</span>
        <span class="c1">#print lipid_types</span>
        <span class="n">x_index</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_index</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">box_x</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">x_index</span><span class="p">]</span>
        <span class="n">box_y</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">y_index</span><span class="p">]</span>
        <span class="n">l_box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">box_x</span><span class="p">,</span> <span class="n">box_y</span><span class="p">])</span>
        <span class="n">box_x_h</span> <span class="o">=</span> <span class="n">box_x</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">box_y_h</span> <span class="o">=</span> <span class="n">box_y</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">center</span><span class="p">[</span><span class="n">x_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_x_h</span>
        <span class="n">center</span><span class="p">[</span><span class="n">y_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_y_h</span>
        <span class="n">ltype_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span>
        <span class="n">ltype_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># COG = ba_reps[&#39;com_frame&#39;].cog()</span>
        <span class="c1"># print &quot;COG: &quot;,COG,&quot; box_x_h: &quot;,box_x_h</span>
        <span class="n">N_a</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">leaflet_name</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
            <span class="n">leaflet</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet_name</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflet</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">has_group</span><span class="p">(</span><span class="n">ltype_a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">has_group</span><span class="p">(</span><span class="n">ltype_b</span><span class="p">):</span>
                <span class="n">ltype_a_indices</span> <span class="o">=</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">ltype_a</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ltype_a</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ltype_a_indices</span><span class="p">)</span>
                <span class="n">ltype_b_indices</span> <span class="o">=</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">ltype_b</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_N_a</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ltype_a_indices</span><span class="p">)</span>
                <span class="n">N_a</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ltype_a_indices</span><span class="p">)</span>
                <span class="c1"># print(len(ltype_a_indices))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_N_b</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ltype_b_indices</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ltype_a_indices</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ltype_b_indices</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                            <span class="n">pos_a</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[[</span><span class="n">x_index</span><span class="p">,</span> <span class="n">y_index</span><span class="p">]]</span>
                            <span class="c1"># print &quot;pos_a: &quot;,pos_a+COG</span>
                            <span class="c1"># print &quot;pos_a - COG:&quot;,pos_a</span>
                            <span class="n">pos_b</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[[</span><span class="n">x_index</span><span class="p">,</span> <span class="n">y_index</span><span class="p">]]</span>

                            <span class="n">dist</span> <span class="o">=</span> <span class="n">distance_euclidean_pbc</span><span class="p">(</span><span class="n">pos_a</span><span class="p">,</span> <span class="n">pos_b</span><span class="p">,</span>
                                                          <span class="n">l_box</span><span class="p">,</span>
                                                          <span class="n">center</span><span class="o">=</span><span class="s1">&#39;box_half&#39;</span><span class="p">)</span>
                            <span class="c1"># print &quot;dist: &quot;, dist</span>
                            <span class="n">ltype</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                            <span class="c1"># if dist &lt; 2.0:</span>
                            <span class="c1">#    print &quot;ltype_a: &quot;,ltype_a,&quot; ltype_b: &quot;,ltype_b,&quot; dist &quot;,dist</span>
                            <span class="c1">#    print &quot;pos_a: &quot;, pos_a,&quot; pos_b: &quot;,pos_b</span>
                            <span class="c1">#ba_reps[&#39;com_frame&#39;].write_xyz(&#39;com_lateral_rdf_bughunt.xyz&#39;)</span>
                            <span class="c1">#quit()</span>
                            <span class="c1">#    quit()</span>
                            <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

        <span class="n">rdf_range</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;range_inner&#39;</span><span class="p">],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;range_outer&#39;</span><span class="p">]]</span>
        <span class="n">count</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_bins&#39;</span><span class="p">],</span>
                                    <span class="nb">range</span><span class="o">=</span><span class="n">rdf_range</span><span class="p">)</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="c1"># print(count)</span>
        <span class="c1"># print(self._count)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">+=</span> <span class="n">count</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># print(self._count)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">prod</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_frames</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="COMLateralRDFProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.COMLateralRDFProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dumps the outputs of this protocol to disc.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, Optional): The string containing the path to the location</span>
<span class="sd">                that the analysis results should be dumped to on disc.</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="COMLateralRDFProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.COMLateralRDFProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the analysis_output of this protocol. &quot;&quot;&quot;</span>
        <span class="c1"># Area in each radial shell</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">area</span> <span class="o">*=</span>  <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">N_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_a</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_leaf</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_frames</span><span class="p">)</span>
        <span class="n">N_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_b</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_leaf</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_frames</span><span class="p">)</span>
        <span class="n">N_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_leaf</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_frames</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">N_a</span><span class="o">*</span><span class="n">N_b</span>
        <span class="c1"># Adjust for duplicates when the resnames are the same.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]:</span>
            <span class="n">N</span> <span class="o">-=</span> <span class="n">N_a</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">-=</span> <span class="n">N_b</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">-=</span> <span class="n">N_a</span>

        <span class="c1"># print &quot;N_a &quot;, N_a,&quot; N_b &quot;,N_b,&quot; n_leaf &quot;,self._n_leaf,&quot; n_frames &quot;,self._n_frames</span>
        <span class="c1"># print(N)</span>
        <span class="c1"># Average number density</span>
        <span class="n">box_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="c1"># print &quot;box_area: &quot;,box_area,&quot; sqrt(box_area): &quot;,np.sqrt(box_area)</span>
        <span class="n">pair_density</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="p">(</span><span class="n">box_area</span><span class="p">)</span>
        <span class="n">density_all</span> <span class="o">=</span> <span class="n">N_all</span> <span class="o">/</span> <span class="n">box_area</span>
        <span class="n">density_a</span> <span class="o">=</span> <span class="n">N_a</span> <span class="o">/</span>  <span class="n">box_area</span>
        <span class="n">density_b</span> <span class="o">=</span> <span class="n">N_b</span> <span class="o">/</span> <span class="n">box_area</span>
        <span class="c1"># print &quot; density: &quot;,pair_density</span>
        <span class="c1"># print(self._count)</span>
        <span class="c1"># print(area)</span>
        <span class="n">normf</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">pair_density</span> <span class="o">*</span> <span class="n">area</span><span class="p">)</span>
        <span class="c1"># normf = density_a / area</span>
        <span class="n">rdf</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">*</span> <span class="n">normf</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_frames</span>
        <span class="c1"># print &quot;n_frames &quot;,self._n_frames</span>
        <span class="c1"># rdf /= density_all</span>
        <span class="c1"># rdf *= (N_a / N_all)*(N_b / N_all)</span>
        <span class="c1"># rdf *= (N_a / N_all)</span>
        <span class="k">return</span> <span class="n">rdf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bins</span></div></div>


<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;com_lateral_rdf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">COMLateralRDFProtocol</span>


<span class="c1"># define a new analysis</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;spatial_velocity_corr&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;spatial_velocity_corr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="SpatialVelocityCorrelationFunctionProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.SpatialVelocityCorrelationFunctionProtocol">[docs]</a><span class="k">class</span> <span class="nc">SpatialVelocityCorrelationFunctionProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute spatial correlation function between lipid displacements/pseudo-velocities.</span>

<span class="sd">    This analysis computes the displacement vectors as in the &#39;disp_vec&#39; analysis,</span>
<span class="sd">    and uses those to estimated a spatial correlation function between the</span>
<span class="sd">    displacments/pseudo-velocities; the function is of the radial separation</span>
<span class="sd">    between the base of each vector in the bilayers lateral plane. The</span>
<span class="sd">    correlation is the cos(theta) value for the angle theta between the</span>
<span class="sd">    vectors.</span>

<span class="sd">    This protocol is identified by the analysis key: &#39;spatial_velocity_corr&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        args (list): list of string keys and arguments</span>

<span class="sd">    Settings (parsed from args to settings dict):</span>
<span class="sd">        leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">            leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">        resname_1 (str): Specify the resname of the reference lipid type to</span>
<span class="sd">            include in this analysis. Special names are &#39;first&#39; and &#39;all&#39;,</span>
<span class="sd">            which use the first and all lipid types respectively. Default:</span>
<span class="sd">            &#39;first&#39;, the first lipid in the list pulled from the com_frame</span>
<span class="sd">            representation.</span>
<span class="sd">        resname_2 (str): Specify the resname of the target lipid type to</span>
<span class="sd">            include in this analysis. Special names are &#39;first&#39; and &#39;all&#39;,</span>
<span class="sd">            which use the first and all lipid types respectively. Default:</span>
<span class="sd">            &#39;first&#39;, the first lipid in the list pulled from the com_frame</span>
<span class="sd">            representation.</span>
<span class="sd">        n_bins (int): Specifies the number of bins to use when estimating</span>
<span class="sd">            the RDF. Default: 25</span>
<span class="sd">        range_inner (float): Specify the inner distance cutoff for the RDF.</span>
<span class="sd">            Default: 0.0</span>
<span class="sd">        range_outer (float): Specify the outer distance cutoff for the RDF.</span>
<span class="sd">            Default: 25.0</span>
<span class="sd">        interval (int): Sets the frame interval over which to compute the</span>
<span class="sd">                displacement vectors.</span>

<span class="sd">    Note:</span>
<span class="sd">        The radial distance is centered on lipids of type resname_1 and</span>
<span class="sd">        averaging is taken over the pair-wise interactions of lipids of</span>
<span class="sd">        type ```resname_1``` with lipids of type ```resname_2```.</span>

<span class="sd">    References:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Weighted average of displacement vector correlations.&quot;</span>
    <span class="c1">#    self._return_length = 4</span>
    <span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;spatial_velocity_corr&#39;</span>
    <span class="n">_related</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">&#39;disp_vec&#39;</span><span class="p">,</span> <span class="s1">&#39;disp_vec_corr&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of SpatialVelocityCorrelationFunctionProtocol.&quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_bins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">25</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;range_inner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;range_outer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">25.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_costheta</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1">#self._running = RunningStats()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_processed_output</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;interval&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;n_bins&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;range_inner&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;range_outer&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="SpatialVelocityCorrelationFunctionProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.SpatialVelocityCorrelationFunctionProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_costheta</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#self._running.reset()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_processed_output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="SpatialVelocityCorrelationFunctionProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.SpatialVelocityCorrelationFunctionProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>

            <span class="c1"># build group/resname/lipid type list</span>
            <span class="n">lipid_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nlipids</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">leaflet_name</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">leaflet</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet_name</span><span class="p">]</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="n">nlipids</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflet</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lipid_types</span><span class="p">:</span>
                        <span class="n">lipid_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">frame</span>

        <span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_frame</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span><span class="p">)</span>
        <span class="c1">#print (interval, &quot; &quot;, self.settings[&#39;interval&#39;])</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaf</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]:</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">])</span>
            <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">x_index</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y_index</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">box_x</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">x_index</span><span class="p">]</span>
            <span class="n">box_y</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">y_index</span><span class="p">]</span>
            <span class="n">l_box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">box_x</span><span class="p">,</span> <span class="n">box_y</span><span class="p">])</span>
            <span class="n">box_x_h</span> <span class="o">=</span> <span class="n">box_x</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">box_y_h</span> <span class="o">=</span> <span class="n">box_y</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="c1"># get the current frame</span>
            <span class="n">curr_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="n">prev_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span>
            <span class="c1"># get the coordinates for the selection at this frame</span>
            <span class="n">vec_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="c1"># vec_ends = []</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">resnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">resname</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                <span class="n">resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span>
                <span class="n">com_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>

                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#    vec_ends.append([com_j[0],com_j[0],com_i[0]-com_j[0],com_i[1]-com_j[1]])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">index_i</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vec_end_a</span> <span class="o">=</span> <span class="n">vec_ends</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vec_a</span> <span class="o">=</span> <span class="n">vec_end_a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec_end_a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">com_i_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index_i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">ltype_i</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index_i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ltype_i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_com</span><span class="p">):</span>
                        <span class="n">index_j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">ltype_j</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index_j</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">ltype_j</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">index_i</span> <span class="o">!=</span> <span class="n">index_j</span><span class="p">:</span>
                                <span class="n">vec_end_b</span> <span class="o">=</span> <span class="n">vec_ends</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                                <span class="n">vec_b</span> <span class="o">=</span> <span class="n">vec_end_b</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec_end_b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                                <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_a</span><span class="p">,</span> <span class="n">vec_b</span><span class="p">)</span>
                                <span class="n">cos_t</span> <span class="o">=</span> <span class="n">dot</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_a</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_b</span><span class="p">))</span>
                                <span class="n">com_j_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index_j</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>

                                <span class="n">dist</span> <span class="o">=</span> <span class="n">distance_euclidean_pbc</span><span class="p">(</span><span class="n">com_i_w</span><span class="p">[[</span><span class="n">x_index</span><span class="p">,</span> <span class="n">y_index</span><span class="p">]],</span>
                                                              <span class="n">com_j_w</span><span class="p">[[</span><span class="n">x_index</span><span class="p">,</span> <span class="n">y_index</span><span class="p">]],</span>
                                                              <span class="n">l_box</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;box_half&#39;</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_costheta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cos_t</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="n">current_frame</span>
            <span class="c1">#return vec_ends</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="SpatialVelocityCorrelationFunctionProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.SpatialVelocityCorrelationFunctionProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dumps the outputs of this protocol to disc.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, Optional): The string containing the path to the location</span>
<span class="sd">                that the analysis results should be dumped to on disc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">_process_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processed_output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cos_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_costheta</span><span class="p">)</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distances</span><span class="p">)</span>
            <span class="n">pos_range</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;range_inner&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;range_outer&#39;</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_processed_output</span> <span class="o">=</span> <span class="n">binned_average</span><span class="p">(</span><span class="n">cos_t</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span>
                                                    <span class="n">n_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_bins&#39;</span><span class="p">],</span>
                                                    <span class="n">position_range</span><span class="o">=</span><span class="n">pos_range</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="SpatialVelocityCorrelationFunctionProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.SpatialVelocityCorrelationFunctionProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the analysis_output of this protocol. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_output</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processed_output</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;spatial_velocity_corr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpatialVelocityCorrelationFunctionProtocol</span>

<span class="c1"># define a new analysis</span>
<span class="c1"># valid_analysis.append(&#39;stroboscopic_trajectory&#39;)</span>
<span class="c1"># analysis_obj_name_dict[&#39;stroboscopic_trajectory&#39;] = &#39;com_frame&#39;</span>
<span class="c1">#</span>
<span class="c1"># #need to think more about box scaling (settings[&#39;scale&#39;]). currently if set True</span>
<span class="c1"># # will scale by the box size of the reference frame</span>
<span class="c1"># class StroboscopicTrajectoryProtocol(AnalysisProtocol):</span>
<span class="c1">#     def __init__(self, args):</span>
<span class="c1">#         &quot;&quot;&quot;Compute the stroboscopic trajectory for a specified lipids.</span>
<span class="c1">#</span>
<span class="c1">#         This protocol is identified by the analysis key: &#39;stroboscopic_trajectory&#39;</span>
<span class="c1">#</span>
<span class="c1">#         Args:</span>
<span class="c1">#             args (list): list of string keys and arguments</span>
<span class="c1">#</span>
<span class="c1">#         Settings (parsed from args to settings dict):</span>
<span class="c1">#             resid (str): MDAnalysis selection string to used to select</span>
<span class="c1">#                 the lipids to include in the analysis. Default: &#39;all&#39;</span>
<span class="c1">#             wrapped (bool): Specify whether to use the wrapped (&#39;True&#39;) or</span>
<span class="c1">#                 un-wrapped (&#39;False&#39;) coordinates for the base of the vectors.</span>
<span class="c1">#                 Default: False</span>
<span class="c1">#             interval (int): Sets the frame interval over which to compute the</span>
<span class="c1">#                     displacement vectors. f</span>
<span class="c1">#             scale (bool): Specify whether to scale the coordinates by the box</span>
<span class="c1">#                 dimensions of the reference frame. Default: False</span>
<span class="c1">#</span>
<span class="c1">#         References:</span>
<span class="c1">#             1. Emma Falck, Tomasz Rog, Mikko Karttunen, and Ilpo Vattulainen,</span>
<span class="c1">#                 Lateral Diffusion in Lipid Membranes through Collective Flows,</span>
<span class="c1">#                 Journal of the American Chemical Society, 2008 130 (1), 44-45</span>
<span class="c1">#                 DOI: 10.1021/ja7103558</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # required</span>
<span class="c1">#         self._short_description = &quot;Displacement vectors.&quot;</span>
<span class="c1">#         self._return_length = 4</span>
<span class="c1">#         self.analysis_key = &#39;disp_vec&#39;</span>
<span class="c1">#         self.analysis_id = &#39;none&#39;</span>
<span class="c1">#</span>
<span class="c1">#         #default settings</span>
<span class="c1">#         self.settings = dict()</span>
<span class="c1">#         self.settings[&#39;leaflet&#39;] = &#39;both&#39;</span>
<span class="c1">#         self.settings[&#39;resname&#39;] = &#39;all&#39;</span>
<span class="c1">#         self.settings[&#39;wrapped&#39;] = False</span>
<span class="c1">#         self.settings[&#39;interval&#39;] = 5</span>
<span class="c1">#         self.settings[&#39;scale&#39;] = False</span>
<span class="c1">#         self._valid_settings = self.settings.keys()</span>
<span class="c1">#         #self.leaflet = &#39;both&#39;</span>
<span class="c1">#         #self.group = &#39;all&#39;</span>
<span class="c1">#         #self.wrapped = False</span>
<span class="c1">#         #self.interval = 10</span>
<span class="c1">#         # parse input arguments</span>
<span class="c1">#         self._parse_args(args)</span>
<span class="c1">#</span>
<span class="c1">#         # default function settings</span>
<span class="c1">#         self.save_file_name = self.analysis_id + &quot;.pickle&quot;</span>
<span class="c1">#</span>
<span class="c1">#         # storage for output</span>
<span class="c1">#         self.analysis_output = []</span>
<span class="c1">#         self.first_comp = True</span>
<span class="c1">#         self.last_com_frame = None</span>
<span class="c1">#         self.last_frame = 0</span>
<span class="c1">#</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     # required- function to parse the input arguments from string</span>
<span class="c1">#     def _cast_settings(self, arg_dict):</span>
<span class="c1">#</span>
<span class="c1">#         for arg_key in arg_dict.keys():</span>
<span class="c1">#             arg_arg = arg_dict[arg_key]</span>
<span class="c1">#             if arg_key in self._valid_settings:</span>
<span class="c1">#                 if arg_key == &#39;interval&#39;:</span>
<span class="c1">#                     arg_dict[arg_key] = int(arg_arg)</span>
<span class="c1">#                 elif arg_key == &#39;wrapped&#39;:</span>
<span class="c1">#                     arg_arg = arg_arg in [&#39;True&#39;, &#39;true&#39;]</span>
<span class="c1">#                     arg_dict[arg_key] = arg_arg</span>
<span class="c1">#                 elif arg_key == &#39;scale&#39;:</span>
<span class="c1">#                     arg_arg = arg_arg in [&#39;True&#39;, &#39;true&#39;]</span>
<span class="c1">#                     arg_dict[arg_key] = arg_arg</span>
<span class="c1">#             elif arg_key == &#39;analysis_id&#39;:</span>
<span class="c1">#                 pass</span>
<span class="c1">#             else:</span>
<span class="c1">#                 warnings.warn(</span>
<span class="c1">#                     &quot;ignoring invalid argument key &quot; + arg_key + &quot; for analysis&quot; + self.analysis_id)</span>
<span class="c1">#         return arg_dict</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#     def reset(self):</span>
<span class="c1">#         self.analysis_output = []</span>
<span class="c1">#         self.first_comp = True</span>
<span class="c1">#         self.last_com_frame = None</span>
<span class="c1">#         self.last_frame = 0</span>
<span class="c1">#</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def run_analysis(self, ba_settings, ba_reps, ba_mda_data):</span>
<span class="c1">#</span>
<span class="c1">#         if self.first_comp:</span>
<span class="c1">#             self.last_com_frame = ba_reps[&#39;com_frame&#39;]</span>
<span class="c1">#             self.first_comp = False</span>
<span class="c1">#             self.last_frame = ba_settings[&#39;frame_range&#39;][0]</span>
<span class="c1">#             return</span>
<span class="c1">#         current_frame = ba_reps[&#39;current_mda_frame&#39;].frame</span>
<span class="c1">#         #print(self.settings[&#39;leaflet&#39;])</span>
<span class="c1">#         #print(self.settings[&#39;scale&#39;])</span>
<span class="c1">#         interval = (current_frame) - (self.last_frame)</span>
<span class="c1">#         #print (interval, &quot; &quot;, self.settings[&#39;interval&#39;])</span>
<span class="c1">#         if interval == self.settings[&#39;interval&#39;]:</span>
<span class="c1">#             indices = []</span>
<span class="c1">#             if self.settings[&#39;leaflet&#39;] == &quot;both&quot;:</span>
<span class="c1">#                 for leaflets in ba_reps[&#39;leaflets&#39;]:</span>
<span class="c1">#                     curr_leaf = ba_reps[&#39;leaflets&#39;][leaflets]</span>
<span class="c1">#                     indices += curr_leaf.get_group_indices(self.settings[&#39;resname&#39;])</span>
<span class="c1">#             elif self.settings[&#39;leaflet&#39;] == &quot;upper&quot;:</span>
<span class="c1">#                 curr_leaf = ba_reps[&#39;leaflets&#39;][&#39;upper&#39;]</span>
<span class="c1">#                 indices = curr_leaf.get_group_indices(self.settings[&#39;resname&#39;])</span>
<span class="c1">#</span>
<span class="c1">#             elif self.settings[&#39;leaflet&#39;] == &quot;lower&quot;:</span>
<span class="c1">#                 curr_leaf = ba_reps[&#39;leaflets&#39;][&#39;lower&#39;]</span>
<span class="c1">#                 indices = curr_leaf.get_group_indices(self.settings[&#39;resname&#39;])</span>
<span class="c1">#             else:</span>
<span class="c1">#                 # unknown option--use default &quot;both&quot;</span>
<span class="c1">#                 warnings.warn(</span>
<span class="c1">#                     &quot;bad setting for \&#39;leaflet\&#39; in &quot; + self.analysis_id + &quot;. Using default \&#39;both\&#39;&quot;)</span>
<span class="c1">#                 self.settings[&#39;leaflet&#39;] = &#39;both&#39;</span>
<span class="c1">#                 for leaflets in ba_reps[&#39;leaflets&#39;]:</span>
<span class="c1">#                     curr_leaf = ba_reps[&#39;leaflets&#39;][leaflets]</span>
<span class="c1">#                     indices += curr_leaf.get_group_indices(self.settings[&#39;resname&#39;])</span>
<span class="c1">#             n_com = len(indices)</span>
<span class="c1">#</span>
<span class="c1">#             # get the current frame</span>
<span class="c1">#             curr_frame = ba_reps[&#39;com_frame&#39;]</span>
<span class="c1">#             prev_frame = self.last_com_frame</span>
<span class="c1">#</span>
<span class="c1">#             #get box dimensions for reference frame (i.e. prev_frame)</span>
<span class="c1">#             box = prev_frame.box</span>
<span class="c1">#             box_lateral = box[ba_settings[&#39;lateral&#39;]]</span>
<span class="c1">#             # get the coordinates for the selection at this frame</span>
<span class="c1">#             vec_ends = np.zeros((n_com, 4))</span>
<span class="c1">#             # vec_ends = []</span>
<span class="c1">#             count = 0</span>
<span class="c1">#             resnames = []</span>
<span class="c1">#             for i in indices:</span>
<span class="c1">#                 resname = curr_frame.lipidcom[i].type</span>
<span class="c1">#                 resnames.append(resname)</span>
<span class="c1">#                 com_i = curr_frame.lipidcom[i].com_unwrap[</span>
<span class="c1">#                     ba_settings[&#39;lateral&#39;]]</span>
<span class="c1">#                 com_j = prev_frame.lipidcom[i].com_unwrap[</span>
<span class="c1">#                     ba_settings[&#39;lateral&#39;]]</span>
<span class="c1">#                 com_j_w = prev_frame.lipidcom[i].com[ba_settings[&#39;lateral&#39;]]</span>
<span class="c1">#                 if self.settings[&#39;scale&#39;]:</span>
<span class="c1">#                     #print(&quot;scaling coordinates..&quot;)</span>
<span class="c1">#                     #print(self.settings[&#39;leaflet&#39;])</span>
<span class="c1">#                     #print(self.settings[&#39;scale&#39;])</span>
<span class="c1">#                     #print(type(self.settings[&#39;scale&#39;]))</span>
<span class="c1">#                     #print(type(self.settings[&#39;wrapped&#39;]))</span>
<span class="c1">#                     #quit()</span>
<span class="c1">#                     com_i[0]/=box_lateral[0]</span>
<span class="c1">#                     com_i[1]/=box_lateral[1]</span>
<span class="c1">#                     com_j[0]/=box_lateral[0]</span>
<span class="c1">#                     com_j[1]/=box_lateral[1]</span>
<span class="c1">#                     com_j_w[0]/=box_lateral[0]</span>
<span class="c1">#                     com_j_w[1]/=box_lateral[1]</span>
<span class="c1">#</span>
<span class="c1">#                 if self.settings[&#39;wrapped&#39;]:</span>
<span class="c1">#                     vec_ends[count, 0] = com_j_w[0]</span>
<span class="c1">#                     vec_ends[count, 1] = com_j_w[1]</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     vec_ends[count, 0] = com_j[0]</span>
<span class="c1">#                     vec_ends[count, 1] = com_j[1]</span>
<span class="c1">#                 vec_ends[count, 2] = com_i[0] - com_j[0]</span>
<span class="c1">#                 vec_ends[count, 3] = com_i[1] - com_j[1]</span>
<span class="c1">#</span>
<span class="c1">#                 #    vec_ends.append([com_j[0],com_j[0],com_i[0]-com_j[0],com_i[1]-com_j[1]])</span>
<span class="c1">#                 count += 1</span>
<span class="c1">#             self.analysis_output.append([vec_ends, resnames])</span>
<span class="c1">#             self.last_com_frame = ba_reps[&#39;com_frame&#39;]</span>
<span class="c1">#             self.last_frame = current_frame</span>
<span class="c1">#             return</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def save_data(self, path=None):</span>
<span class="c1">#         save_file = self.save_file_name</span>
<span class="c1">#         if path is not None:</span>
<span class="c1">#             save_file = path+self.save_file_name</span>
<span class="c1">#</span>
<span class="c1">#         with open(save_file, &#39;wb&#39;) as outfile:</span>
<span class="c1">#             pickle.dump(self.analysis_output, outfile)</span>
<span class="c1">#</span>
<span class="c1">#         return</span>
<span class="c1">#</span>
<span class="c1">#     def get_data(self):</span>
<span class="c1">#         return self.analysis_output</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># command_protocols[&#39;disp_vec&#39;] = DispVecProtocol</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Blake A. Wilson.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>