

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pybilt.bilayer_analyzer.analysis_protocols &mdash; PyBILT 0.0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="PyBILT 0.0.1 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> PyBILT
          

          
            
            <img src="../../../_static/PyBILT_logo_b.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html"><em>Py</em>thon based lipid <em>BIL</em>ayer molecular simulation analysis <em>T</em>oolkit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#install">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#quick-overview-of-pybilt">Quick overview of PyBILT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#additional-documentation-tutorials">Additional Documentation/Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#core-developers">Core Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#contact">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#license">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#acknowledgments">Acknowledgments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#built-with">Built With</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">pybilt</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PyBILT</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pybilt.bilayer_analyzer.analysis_protocols</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pybilt.bilayer_analyzer.analysis_protocols</h1><div class="highlight"><pre>
<span></span>
<span class="sd">&quot;&quot;&quot;Analysis Protocols</span>

<span class="sd">This is a support module that defines a set of classes used to contruct the &#39;analysis protocol&#39; and the &#39;analysis&#39; used</span>
<span class="sd">in the anlysis implemented by the pybilt.bilayer_analyzer.bilayer_anlayzer.BilayerAnalyzer class.</span>
<span class="sd">The AnalysisProtocol is the class used to organize and initial the the individual analysis functions/protocols. The</span>
<span class="sd">individual analysis functions/protocols are derived classes of AnalysisProtocol, and the availabel analysis can be</span>
<span class="sd">extended by simply defining a new protocol.</span>
<span class="sd">Example:</span>
<span class="sd">    # define a new analysis &#39;my_analysis&#39;</span>
<span class="sd">    # add it to the valid_analysis list</span>
<span class="sd">    valid_analysis.append(&#39;my_analysis&#39;)</span>
<span class="sd">    #add it to analysis_obj_name_dict dictionary with the buildable object (e.g. mda_frame)  needed for the analysis.</span>
<span class="sd">    #The buildables are built by the bilayer analyzer and can accessed from it for the analysisanalysis.</span>
<span class="sd">    analysis_obj_name_dict[&#39;my_analysis&#39;] = &#39;mda_frame&#39;</span>
<span class="sd">    class MyAnalysisProtocol(AnalysisFunctionProtocol):</span>
<span class="sd">        #minimal def the __init__ and run_analysisfuncions</span>
<span class="sd">        def __init__(self, args):</span>
<span class="sd">            #define the initialization</span>
<span class="sd">        #The run_analysis function should always take three inputs</span>
<span class="sd">        #    of data that is passed in from the BilayerAnalayzer instance</span>
<span class="sd">        #    that owns this instance of an analysis protocol. The values are:</span>
<span class="sd">        #       ba_settings = BilayerAnalyzer.settings --&gt; The adjustable</span>
<span class="sd">        #           settings dictionary which contains data like &#39;lateral&#39;, and</span>
<span class="sd">        #           &#39;norm&#39;.</span>
<span class="sd">        #       ba_reps = BilayerAnalyzer.reps --&gt; The dictionary container of</span>
<span class="sd">        #           frame representations. e.g. &#39;com_frame&#39; and &#39;lipid_grid&#39;</span>
<span class="sd">        #       ba_mda_data = BilayerAnalyzer.mda_data --&gt; An MDAData instance</span>
<span class="sd">        #           that contains data like the MDAnalysis universe, trajectory,</span>
<span class="sd">        #           bilayer_selection, etc.</span>
<span class="sd">        def run_analysis(self, ba_settings, ba_reps, ba_mda_data):</span>
<span class="sd">            #.............</span>
<span class="sd">            #doing my analysis</span>
<span class="sd">            #................</span>
<span class="sd">            return</span>

<span class="sd">        #redefine any other functions from AnalysisProtocol or add new ones.</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># imports</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span> <span class="k">as</span> <span class="nn">scicon</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1">#import ast</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cPickle</span> <span class="k">as</span> <span class="nn">pickle</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">cmath</span>
<span class="c1">#range/xrange fix</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
<div class="viewcode-block" id="range"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.range">[docs]</a>    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">xrange</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="c1"># PyBILT imports</span>
<span class="kn">from</span> <span class="nn">pybilt.common.running_stats</span> <span class="k">import</span> <span class="n">RunningStats</span>
<span class="kn">import</span> <span class="nn">pybilt.mda_tools.mda_density_profile</span> <span class="k">as</span> <span class="nn">mda_dp</span>
<span class="kn">import</span> <span class="nn">pybilt.lipid_grid.lipid_grid_curv</span> <span class="k">as</span> <span class="nn">lgc</span>
<span class="kn">from</span> <span class="nn">pybilt.common</span> <span class="k">import</span> <span class="n">distance_cutoff_clustering</span> <span class="k">as</span> <span class="n">dc_cluster</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">cdist</span>
<span class="c1">#need some containers for bookkeeping</span>
<span class="n">command_protocols</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">valid_analysis</span><span class="o">=</span> <span class="p">[]</span>
<span class="n">analysis_obj_name_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1"># obj_dict = {&quot;com_frame&quot;:COMFrame}</span>
<span class="c1">#define the buildable objects that are used by the analysisfunctions</span>
<span class="n">use_objects</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mda_frame&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;com_frame&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;lipid_grid&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
    <span class="s2">&quot;vector_frame&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>


<span class="c1"># TO DO:</span>
<span class="c1">#</span>


<div class="viewcode-block" id="word_list_to_string"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.word_list_to_string">[docs]</a><span class="k">def</span> <span class="nf">word_list_to_string</span><span class="p">(</span><span class="n">word_list</span><span class="p">,</span> <span class="n">delimeter</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates a single string from a list of strings</span>

<span class="sd">    This function can be used to combine words in a list into one long sentence</span>
<span class="sd">    string.</span>

<span class="sd">    Args:</span>
<span class="sd">        word_list (list/tuple): A list (or other container) of strings.</span>
<span class="sd">        delimeter (str, Optional): A string to delimit the strings in the list</span>
<span class="sd">            when combining the strings.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">word_list</span><span class="p">:</span>
        <span class="n">string</span><span class="o">+=</span><span class="n">word</span><span class="o">+</span><span class="n">delimeter</span>
    <span class="n">nchar</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nchar</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<span class="c1">#def _run_analysis_alias(protocol_analyzer):</span>
<span class="c1">#    protocol = protocol_analyzer[0]</span>
<span class="c1">#    protocol.run_analysis(protocol_analyzer[1])</span>
<span class="c1">#    return protocol</span>

<span class="k">def</span> <span class="nf">_run_analysis_alias</span><span class="p">(</span><span class="n">protocol_analyzer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; An alias function to pass to multiprocessing threads</span>

<span class="sd">    This function is used internally in the BilayerAnalyzer.run_analysis_mp</span>
<span class="sd">    function to pass to the multiprocessing threads.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">protocol_analyzer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">protocol_analyzer</span>

<span class="c1"># protocol for the analysis to run during the frame loop</span>
<div class="viewcode-block" id="Analyses"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses">[docs]</a><span class="k">class</span> <span class="nc">Analyses</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class to facilitate analysis of the bilayers via the BilayerAnalyzer</span>

<span class="sd">    This object stores all the analyses that are being performed  by the</span>
<span class="sd">    BilayerAnalyzer class, and it provides functionality to add and remove</span>
<span class="sd">    analyses.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        use_objects (dict): A dictionary of buildable objects that need to be</span>
<span class="sd">            contructed in the BilayerAnalyzer for the analysis defined in this</span>
<span class="sd">            protocol.</span>
<span class="sd">        in_commands (list): A list of the input strings for the analysis to be</span>
<span class="sd">            used.</span>
<span class="sd">        arguments (list): A list of the arguments for analysis.</span>
<span class="sd">        analysis_keys (list): A list of the keys assigned to analysis.</span>
<span class="sd">        command_protocol (dict): A dictionary of the analysis objects.</span>
<span class="sd">        analysis_ids (list): A list of the ids assigned to analysis.</span>
<span class="sd">        n_commands (int): The number of initialized analysis.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_commands</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits Analyses with input analysis_commands</span>

<span class="sd">        Args:</span>
<span class="sd">            analysis_commands (list): A list of the input strings for the</span>
<span class="sd">                analyses to be used. This is internally parsed together by</span>
<span class="sd">                the calling BilayerAnalyzer class object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span> <span class="o">=</span> <span class="n">use_objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_commands</span> <span class="o">=</span> <span class="n">analysis_commands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_commands</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># check analysis</span>

        <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">analysis_commands</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_analysis</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
        <span class="c1"># object dependencies</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="p">[</span><span class="s1">&#39;lipid_grid&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Define the getitem function &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Define the len function &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">)</span>

<div class="viewcode-block" id="Analyses.add_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses.add_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">add_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used to add a new analysis to the internal set of analyses</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs (str, list, tuple, or dict): The input to parsed for the</span>
<span class="sd">                type of analysis and its settings to be added to set of</span>
<span class="sd">                analyses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">basestring</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_analysis_from_string</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_analysis_from_list</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_analysis_from_dict</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">_add_analysis_from_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parses string inputs. &quot;&quot;&quot;</span>
        <span class="n">command</span> <span class="o">=</span> <span class="n">analysis_string</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">comp_key</span> <span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">comp_id</span> <span class="o">=</span> <span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">comp_args</span> <span class="o">=</span> <span class="n">word_list_to_string</span><span class="p">(</span><span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">comp_key</span> <span class="ow">in</span> <span class="n">valid_analysis</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">comp_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
                    <span class="n">comp_object</span> <span class="o">=</span> <span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="n">comp_key</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="p">[</span><span class="n">comp_object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_args</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_id</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_key</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">comp_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">command_protocols</span><span class="p">[</span>
                        <span class="n">comp_key</span><span class="p">](</span><span class="n">comp_args</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;analysisid &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                                       <span class="s2">&quot;has already been used!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_id</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;wrong number of arguments &quot;</span>
                                   <span class="s2">&quot;for analysis </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">command</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;invalid analysisid&quot;</span>
                               <span class="s2">&quot; &#39;</span><span class="si">{}</span><span class="s2">&#39; : </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_key</span><span class="p">,</span> <span class="n">command</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_commands</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_add_analysis_from_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parses list/tuple inputs. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">analysis_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">comp_key</span> <span class="o">=</span> <span class="n">analysis_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">comp_id</span> <span class="o">=</span> <span class="n">analysis_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">comp_args</span> <span class="o">=</span> <span class="n">analysis_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">comp_args</span><span class="p">[</span><span class="s1">&#39;analysis_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp_id</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">comp_key</span> <span class="ow">in</span> <span class="n">valid_analysis</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">comp_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
                    <span class="n">comp_object</span> <span class="o">=</span> <span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="n">comp_key</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="p">[</span><span class="n">comp_object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_args</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_id</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_key</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">comp_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">command_protocols</span><span class="p">[</span>
                        <span class="n">comp_key</span><span class="p">](</span><span class="n">comp_args</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;analysis_id &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                                       <span class="s2">&quot;has already been used!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_id</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;invalid analysis_key &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_key</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;wrong number of arguments in the input list/tuple. Should be three: [a_key, a_id, a_set_dict]&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_commands</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_add_analysis_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parses dict inputs. &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;analysis_key&#39;</span><span class="p">,</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">,</span> <span class="s2">&quot;analysis_settings&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">analysis_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;required key: </span><span class="si">{}</span><span class="s2"> , not in the input dictionary.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="n">comp_key</span> <span class="o">=</span> <span class="n">analysis_dict</span><span class="p">[</span><span class="s1">&#39;analysis_key&#39;</span><span class="p">]</span>
        <span class="n">comp_id</span> <span class="o">=</span> <span class="n">analysis_dict</span><span class="p">[</span><span class="s1">&#39;analysis_id&#39;</span><span class="p">]</span>
        <span class="n">comp_args</span> <span class="o">=</span> <span class="n">analysis_dict</span><span class="p">[</span><span class="s1">&#39;analysis_settings&#39;</span><span class="p">]</span>
        <span class="n">comp_args</span><span class="p">[</span><span class="s1">&#39;analysis_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp_id</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">comp_key</span> <span class="ow">in</span> <span class="n">valid_analysis</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">comp_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
                <span class="n">comp_object</span> <span class="o">=</span> <span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="n">comp_key</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="p">[</span><span class="n">comp_object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_args</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_id</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp_key</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">comp_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">command_protocols</span><span class="p">[</span>
                    <span class="n">comp_key</span><span class="p">](</span><span class="n">comp_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;analysisid &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                                   <span class="s2">&quot;has already been used!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_id</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;invalid analysis_key &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_key</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_commands</span><span class="o">+=</span><span class="mi">1</span>

        <span class="k">return</span>

<div class="viewcode-block" id="Analyses.remove_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses.remove_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">remove_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the analysis with the given id from the set of analyses.</span>

<span class="sd">        Args:</span>
<span class="sd">            analysis_id (str): The string analysis_id of the analysis that is</span>
<span class="sd">                to be removed from the internal set of analyses.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">analysis_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">analysis_id</span><span class="p">]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">analysis_id</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_commands</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;no analysis with id &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">analysis_id</span><span class="p">))</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Analyses.remove_all"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses.remove_all">[docs]</a>    <span class="k">def</span> <span class="nf">remove_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Removes all of the analyses from internal set. &quot;&quot;&quot;</span>

        <span class="n">a_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span>
        <span class="k">for</span> <span class="n">a_id</span> <span class="ow">in</span> <span class="n">a_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_analysis</span><span class="p">(</span><span class="n">a_id</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Analyses.print_protocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses.print_protocol">[docs]</a>    <span class="k">def</span> <span class="nf">print_protocol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Prints to std out the protocol of the analyses. &quot;&quot;&quot;</span>

        <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;build objects:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_objects</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="nb">print</span> <span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;with analysis:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">analysis_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">analysis_id</span><span class="p">]</span><span class="o">.</span><span class="n">print_protocol</span><span class="p">()</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Analyses.dump_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses.dump_data">[docs]</a>    <span class="k">def</span> <span class="nf">dump_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calls the individual save_data functions of each AnalysisProtocol.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, Optional): The string path where output files should be</span>
<span class="sd">                dumped to disc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;dumping analysis data to pickle files...&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">analysis_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;analysis id: </span><span class="si">{}</span><span class="s2"> ---&gt; </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">analysis_id</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">analysis_id</span><span class="p">]</span><span class="o">.</span><span class="n">save_file_name</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">analysis_id</span><span class="p">]</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Analyses.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.Analyses.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calls the individual rest functions for each AnalysisProtocol. &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">analysis_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">command_protocol</span><span class="p">[</span><span class="n">analysis_id</span><span class="p">]</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span></div></div>

<span class="c1">#base class for analysis protocols</span>
<div class="viewcode-block" id="AnalysisProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol">[docs]</a><span class="k">class</span> <span class="nc">AnalysisProtocol</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for analysis protocols.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        analysis_key (str): The key name of this analysis.</span>
<span class="sd">        analysis_id (str): The unique id assigned to this analyisis.</span>
<span class="sd">        save_file_name (str): The path and filename for the pickle file output of</span>
<span class="sd">            this analysis&#39; results.</span>
<span class="sd">        settings (dict): A dict of the internal settings of the analysis.</span>
<span class="sd">        analysis_output (list or list like): Used to store the ouptut of this</span>
<span class="sd">            analysis during the frame loop.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pickleable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Inits the AnalysisProtocol using the input args.</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of argument keys and values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;parent analysis protocol&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments</span>
    <span class="k">def</span> <span class="nf">_parse_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parses the setup arguments for this analysis.</span>
<span class="sd">        Args:</span>
<span class="sd">            args (list): List of argument keys and values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print args</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="n">basestring</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_string</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_dict</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Invalid input structure for arguments/settings to analysis type &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span><span class="p">)</span>
        <span class="k">return</span>
        <span class="c1"># required - a check protocol function which reports relevant settings</span>
    <span class="k">def</span> <span class="nf">_parse_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parses the input arguments from a string. &quot;&quot;&quot;</span>

        <span class="n">arg_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_str_to_dict</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="c1">#type cast setttings if needed</span>
        <span class="n">arg_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cast_settings</span><span class="p">(</span><span class="n">arg_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_dict</span><span class="p">(</span><span class="n">arg_dict</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_parse_str_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts the input argument str to dict. &quot;&quot;&quot;</span>
        <span class="n">arg_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">arg_dict</span><span class="p">[</span><span class="s1">&#39;analysis_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nargs</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">arg_key</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span>  <span class="n">arg_arg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

    <span class="c1"># cast the input string values of settings to appropriate types -- should be overwritten in derived classes to</span>
    <span class="c1"># properly type cast their own settings.</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cast the input arguments from str to the appropriate type (e.g. int).&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">dummy_setting_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

    <span class="k">def</span> <span class="nf">_parse_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parses the input arguments from a dict. &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;analysis_id&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;required key </span><span class="se">\&#39;</span><span class="s2">anlaysis_id</span><span class="se">\&#39;</span><span class="s2"> not assigned in input dict for analysis type: </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span>  <span class="n">arg_arg</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="n">arg_arg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="AnalysisProtocol.short_description"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.short_description">[docs]</a>    <span class="k">def</span> <span class="nf">short_description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the protocols short description.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span></div>

<div class="viewcode-block" id="AnalysisProtocol.pickleable"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.pickleable">[docs]</a>    <span class="k">def</span> <span class="nf">pickleable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether or not the protocol can be pickled.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pickleable</span></div>

<div class="viewcode-block" id="AnalysisProtocol.print_protocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.print_protocol">[docs]</a>    <span class="k">def</span> <span class="nf">print_protocol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prints to std out the internal data and settings for the protocol.&quot;&quot;&quot;</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Analysis: &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;  with analysis_id: </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">))</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;   and settings: &quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;    </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="AnalysisProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs the analysis that this protocol represents for the current</span>
<span class="sd">        frame in the external BilayerAnalyzer&#39;s run_analysis function.</span>

<span class="sd">        Args:</span>
<span class="sd">            ba_settings (dict): The settings stored in the external</span>
<span class="sd">                BilayerAnalyzer instance.</span>
<span class="sd">            ba_reps (dict): The representation objects stored in the external</span>
<span class="sd">                BilayerAnalyzer instance.</span>
<span class="sd">            ba_mda_data (MDAData instance): The instance of MDAData stored in</span>
<span class="sd">                the external BilayerAnalyzer instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># do some stuff</span>
        <span class="c1"># get an output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span><span class="p">)</span>
        <span class="n">dummy_ba_settings</span> <span class="o">=</span> <span class="n">ba_settings</span>
        <span class="n">dummy_ba_reps</span> <span class="o">=</span> <span class="n">ba_reps</span>
        <span class="n">dummy_ba_mda_data</span> <span class="o">=</span> <span class="n">ba_mda_data</span>
        <span class="c1"># save the output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="AnalysisProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dumps the outputs of this protocol to disc.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, Optional): The string containing the path to the location</span>
<span class="sd">                that the analysis results should be dumped to on disc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">),</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="AnalysisProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the analysis_output of this protocol. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnalysisProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AnalysisProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the analysis by resetting the outputs and any necessary</span>
<span class="sd">        internal variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span></div></div>


<span class="c1"># define a new analysis &#39;msd&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;msd&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;msd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="MSDProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDProtocol">[docs]</a><span class="k">class</span> <span class="nc">MSDProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the mean squared displacement from a single time origin.</span>

<span class="sd">        The MSDProtocol is used to compute the mean squared displacement (MSD)</span>
<span class="sd">        of the centers of mass of the specified lipids for a single time origin</span>
<span class="sd">        (i.e. the first frame in the trajectory analysis) The MSD is given by</span>
<span class="sd">        MSD_i = &lt;(r(t) - &lt;r_0)**2&gt;_i for lipid type i; the angle brackets denote</span>
<span class="sd">        averaging over all lipids of type i.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;msd&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">                leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">            resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">                this analysis. Default: &#39;all&#39;, averages over all lipid types.</span>

<span class="sd">        References:</span>
<span class="sd">            1. Preston B. Moore, Carlos F. Lopez, Michael L. Klein, Dynamical</span>
<span class="sd">                Properties of a Hydrated Lipid Bilayer from a Multinanosecond</span>
<span class="sd">                Molecular Dynamics Simulation, Biophysical Journal, Volume 81,</span>
<span class="sd">                Issue 5, 2001, Pages 2484-2494, ISSN 0006-3495,</span>
<span class="sd">                http://dx.doi.org/10.1016/S0006-3495(01)75894-8.</span>
<span class="sd">                (http://www.sciencedirect.com/science/article/pii/S0006349501758948)</span>

<span class="sd">            2. Yoshimichi Andoh, Susumu Okazaki, Ryuichi Ueoka, Molecular</span>
<span class="sd">                dynamics study of lipid bilayers modeling the plasma membranes</span>
<span class="sd">                of normal murine thymocytes and leukemic GRSL cells, Biochimica</span>
<span class="sd">                et Biophysica Acta (BBA) - Biomembranes, Volume 1828, Issue 4,</span>
<span class="sd">                April 2013, Pages 1259-1270, ISSN 0005-2736,</span>
<span class="sd">                https://doi.org/10.1016/j.bbamem.2013.01.005.</span>
<span class="sd">                (http://www.sciencedirect.com/science/article/pii/S0005273613000096)</span>

<span class="sd">            3. Section 8.7,</span>
<span class="sd">                http://manual.gromacs.org/documentation/5.1.4/manual-5.1.4.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Single time origin mean squared displacement.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;msd&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>


<div class="viewcode-block" id="MSDProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="nb">print</span> <span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">leaflet</span>
                <span class="nb">print</span> <span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">selcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">com_curr</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
            <span class="n">selcoords</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_curr</span><span class="p">[:]</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># initialize a numpy array to hold the msd for the selection</span>
        <span class="n">msd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># initialize a running stats object to do the averaging over resids</span>
        <span class="n">drs_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>

        <span class="n">ref_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">com_curr</span> <span class="o">=</span> \
                    <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;first_com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                        <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">ref_coords</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_curr</span><span class="p">[:]</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="n">ref_coords</span><span class="p">[:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span>
            <span class="c1"># get the current com frame list</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">tc</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">selcoords</span> <span class="o">-</span> <span class="n">ref_coords</span>
        <span class="n">drs</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">dr</span>
        <span class="c1"># loop over the selections for this frame</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">drs</span><span class="p">:</span>
            <span class="n">drs_curr</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:]</span>
            <span class="n">drs_mag</span> <span class="o">=</span> <span class="n">drs_curr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">drs_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">drs_mag</span><span class="p">)</span>
        <span class="c1"># get the msd for the current selection</span>
        <span class="n">msdcurr</span> <span class="o">=</span> <span class="n">drs_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">msd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="n">msd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">msdcurr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msd</span><span class="p">)</span>
        <span class="k">return</span></div></div>


<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;msd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSDProtocol</span>

<span class="c1"># define a new analysis &#39;msd&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;msd_multi&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;msd_multi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="MSDMultiProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDMultiProtocol">[docs]</a><span class="k">class</span> <span class="nc">MSDMultiProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the mean squared displacement using multiple time origins.</span>

<span class="sd">        The MSDMultiProtocol is used to compute the mean squared displacement</span>
<span class="sd">        (MSD) of the centers of mass of the specified lipids using multiple time</span>
<span class="sd">        origins and thus multiple time blocks.</span>
<span class="sd">        The MSD is given by</span>
<span class="sd">            MSD_i = &lt;&lt;(r(tau) - r_0)**2&gt;_i&gt;_tau</span>
<span class="sd">        for lipid type i; the inner angle</span>
<span class="sd">        brackets denote averaging over all lipids of type i and the</span>
<span class="sd">        outer brackets denote averaging over all time origins. The diffusion</span>
<span class="sd">        coefficient is estimated from the MSD using a simplified version</span>
<span class="sd">        Einstein&#39;s relation</span>
<span class="sd">            D_i ~ MSD_i/(4.0*tau)</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;msd_multi&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">                leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">            resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">                this analysis. Default: &#39;all&#39;, averages over all lipid types.</span>
<span class="sd">            n_tau (int): Specify the time block size in number of frames.</span>
<span class="sd">                Default: 50 ( 1000 picoseconds for timestep of 2 fs and frame</span>
<span class="sd">                output ever 100 timesteps).</span>
<span class="sd">            n_sigma (int): Specify the time between origins in number of frames.</span>
<span class="sd">                Default: 50.</span>
<span class="sd">        Note:</span>
<span class="sd">            According to results in Ref 3 the time blocks used to estimate the</span>
<span class="sd">                MSD should not be overlapping. Therefore, it is recommended to</span>
<span class="sd">                use n_sigma &gt;= n_tau.</span>

<span class="sd">        References:</span>
<span class="sd">            1. Christofer Hofsab, Erik Lindahl, and Olle Edholm, &quot;Molecular</span>
<span class="sd">                Dynamics Simulations of Phospholipid Bilayers with Cholesterol&quot;,</span>
<span class="sd">                Biophys J. 2003 Apr; 84(4): 2192-2206.</span>
<span class="sd">                doi:  10.1016/S0006-3495(03)75025-5</span>

<span class="sd">            2. Orsi, Mario, Julien Michel, and Jonathan W. Essex.</span>
<span class="sd">                &quot;Coarse-grain modelling of DMPC and DOPC lipid bilayers.&quot;</span>
<span class="sd">                Journal of Physics: Condensed Matter 22.15 (2010): 155106.</span>
<span class="sd">                http://iopscience.iop.org/article/10.1088/0953-8984/22/15/155106/meta</span>

<span class="sd">            3. Gaurav Pranami and Monica H. Lamm, Estimating Error in Diffusion</span>
<span class="sd">                Coefficients Derived from Molecular Dynamics Simulations,</span>
<span class="sd">                Journal of Chemical Theory and Computation 2015 11 (10),</span>
<span class="sd">                4586-4592, DOI: 10.1021/acs.jctc.5b00574,</span>
<span class="sd">                http://pubs.acs.org/doi/full/10.1021/acs.jctc.5b00574</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Multiple time origin mean squared displacement.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;msd_multi&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_tau&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tau_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_have_tau</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;n_tau&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;n_sigma&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="MSDMultiProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDMultiProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="c1">#determine the frame intervals</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="nb">print</span> <span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">leaflet</span>
                <span class="nb">print</span> <span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">indices</span>
            <span class="c1">#self.analysis_output.append([])</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">selcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">com_curr</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
            <span class="n">selcoords</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_curr</span><span class="p">[:]</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># initialize a running stats object to do the averaging over resids</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ref_coords</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">com_curr</span> <span class="o">=</span> \
                    <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;first_com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                        <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">ref_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">com_curr</span><span class="p">[:])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_coords</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># get the current com frame list</span>
        <span class="c1">#print(self._sigma_counter)</span>
        <span class="c1">#print(type(self.settings[&#39;n_sigma&#39;]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_counter</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_sigma&#39;</span><span class="p">]:</span>
            <span class="c1">#print(&quot;{} {}&quot;.format(self._sigma_counter, self.settings[&#39;n_sigma&#39;]))</span>
            <span class="c1">#print(&quot;{}&quot;.format(self._sigma_counter &lt; self.settings[&#39;n_sigma&#39;]))</span>
            <span class="n">n_blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tau_counter</span><span class="p">,</span> <span class="n">n_blocks</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_tau&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_tau&#39;</span><span class="p">]:</span>
                    <span class="n">drs_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
                    <span class="n">ref_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                    <span class="n">dr</span> <span class="o">=</span> <span class="n">selcoords</span> <span class="o">-</span> <span class="n">ref_coords</span>
                    <span class="n">drs</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">dr</span>
                    <span class="c1"># loop over the selections for this frame</span>
                    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">drs</span><span class="p">:</span>
                        <span class="n">drs_curr</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:]</span>
                        <span class="n">drs_mag</span> <span class="o">=</span> <span class="n">drs_curr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                        <span class="n">drs_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">drs_mag</span><span class="p">)</span>
                    <span class="c1"># get the msd for the current selection</span>
                    <span class="n">msdcurr</span> <span class="o">=</span> <span class="n">drs_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">msdcurr</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tau_counter</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_counter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_sigma&#39;</span><span class="p">]:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ref_coords</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">com_curr</span> <span class="o">=</span> \
                    <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                        <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">ref_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">com_curr</span><span class="p">[:])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_coords</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">n_blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tau_counter</span><span class="p">,</span> <span class="n">n_blocks</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_tau&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_tau&#39;</span><span class="p">]:</span>
                    <span class="n">drs_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
                    <span class="n">ref_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                    <span class="n">dr</span> <span class="o">=</span> <span class="n">selcoords</span> <span class="o">-</span> <span class="n">ref_coords</span>
                    <span class="n">drs</span> <span class="o">=</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">dr</span>
                    <span class="c1"># loop over the selections for this frame</span>
                    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">drs</span><span class="p">:</span>
                        <span class="n">drs_curr</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:]</span>
                        <span class="n">drs_mag</span> <span class="o">=</span> <span class="n">drs_curr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                        <span class="n">drs_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">drs_mag</span><span class="p">)</span>
                    <span class="c1"># get the msd for the current selection</span>
                    <span class="n">msdcurr</span> <span class="o">=</span> <span class="n">drs_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">msdcurr</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tau_counter</span><span class="o">+=</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_have_tau</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frame_counter</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_counter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_tau&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> \
                    <span class="o">-</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;first_com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_have_tau</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div>
    <span class="k">def</span> <span class="nf">_process_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_output</span><span class="p">):</span>
        <span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">analysis_output</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="c1">#print(analysis_output)</span>
        <span class="n">msd_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">analysis_output</span><span class="p">)</span>
        <span class="n">msd_average</span> <span class="o">=</span> <span class="n">msd_array</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">msd_std_err</span> <span class="o">=</span> <span class="n">msd_array</span><span class="o">.</span><span class="n">std</span><span class="p">()</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">msd_array</span><span class="p">))</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span>
        <span class="n">diffusion_coeff</span> <span class="o">=</span> <span class="n">msd_average</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">tau</span><span class="p">)</span>
        <span class="n">diffusion_coeff_std_err</span> <span class="o">=</span> <span class="n">msd_std_err</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">tau</span><span class="p">)</span>
        <span class="n">analysis_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">msd_average</span><span class="p">,</span> <span class="n">msd_std_err</span><span class="p">,</span>
                                    <span class="n">diffusion_coeff</span><span class="p">,</span> <span class="n">diffusion_coeff_std_err</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">analysis_output</span>

<div class="viewcode-block" id="MSDMultiProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDMultiProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>

        <span class="n">analysis_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">analysis_output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="MSDMultiProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDMultiProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">analysis_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">analysis_output</span></div>

<div class="viewcode-block" id="MSDMultiProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MSDMultiProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tau_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counters</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_have_tau</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span></div></div>

<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;msd_multi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSDMultiProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;apl_box&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;apl_box&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>


<div class="viewcode-block" id="APLBoxProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLBoxProtocol">[docs]</a><span class="k">class</span> <span class="nc">APLBoxProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the area per lipid using the lateral area.</span>

<span class="sd">        The APLBoxProtocol is used to estimate the area per lipid (APL)</span>
<span class="sd">        using the lateral box dimensions. This approach is only accurate for</span>
<span class="sd">        homogenous lipid bilayers. If the bilayer is inhomogenous then tbis</span>
<span class="sd">        estimate represents a composite average of the area per lipid.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;apl_box&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            None</span>

<span class="sd">        References:</span>
<span class="sd">            1. Preston B. Moore, Carlos F. Lopez, Michael L. Klein, Dynamical Properties of a Hydrated Lipid Bilayer</span>
<span class="sd">                from a Multinanosecond Molecular Dynamics Simulation, Biophysical Journal, Volume 81, Issue 5, 2001,</span>
<span class="sd">                Pages 2484-2494, ISSN 0006-3495, http://dx.doi.org/10.1016/S0006-3495(01)75894-8.</span>
<span class="sd">                (http://www.sciencedirect.com/science/article/pii/S0006349501758948)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Area per lipid using box dimensions.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;apl_box&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

<div class="viewcode-block" id="APLBoxProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLBoxProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">plane</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">2.0</span>
        <span class="n">nlipids</span> <span class="o">=</span> <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">n_residues</span>
        <span class="n">apl</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">nlipids</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">apl</span><span class="p">)</span>
        <span class="n">apl_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span><span class="p">)</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">apl</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">apl_t</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="APLBoxProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLBoxProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;apl_box&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">APLBoxProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;bilayer_thickness&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;bilayer_thickness&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;lipid_grid&#39;</span>


<div class="viewcode-block" id="BTGridProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.BTGridProtocol">[docs]</a><span class="k">class</span> <span class="nc">BTGridProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the bilayer thickness using a gridding procedure.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;bilayer_thickness&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            None</span>

<span class="sd">        References:</span>
<span class="sd">            1. Allen et al. Vol. 30, No. 12 Journal of Computational Chemistry</span>
<span class="sd">            2. Gapsys et al. J Comput Aided Mol Des (2013) 27:845-858</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Bilayer thickness using lipid_grid.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;bilayer_thickness&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>


<div class="viewcode-block" id="BTGridProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.BTGridProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">current_thickness</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;lipid_grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">average_thickness</span><span class="p">()</span>
        <span class="c1"># print (current_thickness)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1"># print (time)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">current_thickness</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">bt_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">bt_t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">bt_t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_thickness</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bt_t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">bt_t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bt_t</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="BTGridProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.BTGridProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;bilayer_thickness&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTGridProtocol</span>

<span class="c1"># define a new analysis &#39;apl_grid&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;apl_grid&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;apl_grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;lipid_grid&#39;</span>


<div class="viewcode-block" id="APLGridProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLGridProtocol">[docs]</a><span class="k">class</span> <span class="nc">APLGridProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the indvidual area per lipid for each lipid type using a</span>
<span class="sd">         gridding procedure.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;apl_grid&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            None</span>

<span class="sd">        References:</span>
<span class="sd">            1. Allen et al. Vol. 30, No. 12 Journal of Computational Chemistry</span>
<span class="sd">            2. Gapsys et al. J Comput Aided Mol Des (2013) 27:845-858</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Area per lipid using lipid_grid&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;apl_grid&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># parse input arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span>

<div class="viewcode-block" id="APLGridProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLGridProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">apl_grid_out</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;lipid_grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">area_per_lipid</span><span class="p">()</span>
        <span class="c1"># print (current_thickness)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1"># print (time)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">apl_grid_out</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;composite&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">apl_grid_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">running_res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">apl_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">apl_grid_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">apl_t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;composite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">apl_t</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">apl_grid_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running_res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">apl_grid_out</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">apl_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">apl_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
            <span class="n">apl_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">apl_grid_out</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">apl_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">apl_res</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_res</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">apl_res</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="APLGridProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLGridProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="APLGridProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLGridProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div>

<div class="viewcode-block" id="APLGridProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.APLGridProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;apl_grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">APLGridProtocol</span>

<span class="c1"># define a new analysis &#39;disp_vec&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;disp_vec&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;disp_vec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>

<span class="c1">#need to think more about box scaling (settings[&#39;scale&#39;]). currently if set True</span>
<span class="c1"># will scale by the box size of the reference frame</span>
<div class="viewcode-block" id="DispVecProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecProtocol">[docs]</a><span class="k">class</span> <span class="nc">DispVecProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Comute displacement vectors for each lipid in the specified</span>
<span class="sd">        leaflet(s) of bilayer.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;disp_vec&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">                leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">            resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">                this analysis. Default: &#39;all&#39;, includes all lipid types.</span>
<span class="sd">            wrapped (bool): Specify whether to use the wrapped (&#39;True&#39;) or</span>
<span class="sd">                un-wrapped (&#39;False&#39;) coordintes for the base of the vectors.</span>
<span class="sd">                Default: False</span>
<span class="sd">            interval (int): Sets the frame interval over which to compute the</span>
<span class="sd">                    displacement vectors. f</span>
<span class="sd">            scale (bool): Specify whether to scale the coordinates by the box</span>
<span class="sd">                dimensions of the reference frame. Default: False</span>

<span class="sd">        References:</span>
<span class="sd">            1. Emma Falck, Tomasz Rog, Mikko Karttunen, and Ilpo Vattulainen,</span>
<span class="sd">                Lateral Diffusion in Lipid Membranes through Collective Flows,</span>
<span class="sd">                Journal of the American Chemical Society, 2008 130 (1), 44-45</span>
<span class="sd">                DOI: 10.1021/ja7103558</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Displacement vectors.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;disp_vec&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1">#default settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.group = &#39;all&#39;</span>
        <span class="c1">#self.wrapped = False</span>
        <span class="c1">#self.interval = 10</span>
        <span class="c1"># parse input arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;interval&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;wrapped&#39;</span><span class="p">:</span>
                    <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">]</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_arg</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span>
                    <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">]</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_arg</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>


<div class="viewcode-block" id="DispVecProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;frame_range&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">frame</span>
        <span class="c1">#print(self.settings[&#39;leaflet&#39;])</span>
        <span class="c1">#print(self.settings[&#39;scale&#39;])</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_frame</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span><span class="p">)</span>
        <span class="c1">#print (interval, &quot; &quot;, self.settings[&#39;interval&#39;])</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;lower&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;bad setting for </span><span class="se">\&#39;</span><span class="s2">leaflet</span><span class="se">\&#39;</span><span class="s2"> in &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;. Using default </span><span class="se">\&#39;</span><span class="s2">both</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

            <span class="c1"># get the current frame</span>
            <span class="n">curr_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="n">prev_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span>

            <span class="c1">#get box dimensions for reference frame (i.e. prev_frame)</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">box</span>
            <span class="n">box_lateral</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
            <span class="c1"># get the coordinates for the selection at this frame</span>
            <span class="n">vec_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="c1"># vec_ends = []</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">resnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">resname</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                <span class="n">resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span>
                <span class="n">com_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]:</span>
                    <span class="c1">#print(&quot;scaling coordinates..&quot;)</span>
                    <span class="c1">#print(self.settings[&#39;leaflet&#39;])</span>
                    <span class="c1">#print(self.settings[&#39;scale&#39;])</span>
                    <span class="c1">#print(type(self.settings[&#39;scale&#39;]))</span>
                    <span class="c1">#print(type(self.settings[&#39;wrapped&#39;]))</span>
                    <span class="c1">#quit()</span>
                    <span class="n">com_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/=</span><span class="n">box_lateral</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">com_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/=</span><span class="n">box_lateral</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/=</span><span class="n">box_lateral</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/=</span><span class="n">box_lateral</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">com_j_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/=</span><span class="n">box_lateral</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">com_j_w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/=</span><span class="n">box_lateral</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1">#    vec_ends.append([com_j[0],com_j[0],com_i[0]-com_j[0],com_i[1]-com_j[1]])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">vec_ends</span><span class="p">,</span> <span class="n">resnames</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="n">current_frame</span>
            <span class="k">return</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;disp_vec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DispVecProtocol</span>

<span class="c1"># define a new analysis</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;mass_dens&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;mass_dens&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>


<div class="viewcode-block" id="MassDensProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MassDensProtocol">[docs]</a><span class="k">class</span> <span class="nc">MassDensProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="n">_pickleable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the mass density profile for the specified selection.</span>

<span class="sd">        This protocol is used to estimate the 1-dimensional mass density profile</span>
<span class="sd">        for a selection of atoms along the bilayer normal. The profile is</span>
<span class="sd">        automatically centered on the bilayer&#39;s center of mass along the</span>
<span class="sd">        bilayer normal.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;mass_dens&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            selection_string (str): Provide the MDAnalysis compatible selection</span>
<span class="sd">                for the atoms to include in this analysis. Default: &#39;BILAYER&#39;,</span>
<span class="sd">                use all the lipids of the bilayer as recovered from the</span>
<span class="sd">                selection given to the external BilayerAnalyzer.</span>
<span class="sd">            n_bins (int): Set the number of bins to divide the normal dimensions</span>
<span class="sd">                into for binning.</span>

<span class="sd">        References:</span>
<span class="sd">            1. Needed!</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Mass density profile.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;mass_dens&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;selection_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;BILAYER&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_bins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">25</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1">#self.selection_string = &#39;all&#39;</span>
        <span class="c1">#self.n_bins = 25</span>

        <span class="c1">#parse input arguments/settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>


        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>
        <span class="c1">#in this case the casting is taken care of in _parse_str_to_dict</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

    <span class="c1"># needed to overwrite the string parser to handle the selection string</span>
    <span class="k">def</span> <span class="nf">_parse_str_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="c1"># print args</span>
        <span class="n">arg_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">arg_dict</span><span class="p">[</span><span class="s1">&#39;analysis_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">read_sel_string</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">n_bins_arg</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nargs</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">arg_key</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1">#print (&#39;arg_key: &#39;, arg_key)</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;n_bins&#39;</span><span class="p">:</span>
                    <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="s1">&#39;n_bins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                    <span class="n">read_sel_string</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">n_bins_arg</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;selection&#39;</span><span class="p">:</span>
                    <span class="n">selection_words</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nargs</span><span class="p">)</span> <span class="k">if</span>
                                       <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">)]</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selection_words</span><span class="p">)</span>
                    <span class="n">selection_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">selection_words</span><span class="p">:</span>
                        <span class="n">selection_string</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">word</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="s1">&#39;selection_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">selection_string</span>
                    <span class="n">read_sel_string</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">n_bins_arg</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">read_sel_string</span> <span class="ow">or</span> <span class="n">n_bins_arg</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>


<div class="viewcode-block" id="MassDensProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MassDensProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="MassDensProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MassDensProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="nb">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;selection_string&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;selection_string&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;BILAYER&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bilayer_sel&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">bilayer_sel</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;non-bilayer&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">mda_universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;selection_string&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># print &quot;there are &quot;,len(indices),&quot; members&quot;</span>

        <span class="n">norm_axis</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;normal_dimension&#39;</span><span class="p">]</span>
        <span class="n">ref_sel</span> <span class="o">=</span> <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">bilayer_sel</span>
        <span class="c1"># mda_density_profile</span>
        <span class="n">centers_density</span> <span class="o">=</span> <span class="n">mda_dp</span><span class="o">.</span><span class="n">mass_density_profile</span><span class="p">(</span>
            <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">mda_trajectory</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">,</span>
            <span class="n">fstart</span><span class="o">=</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;frame_index&#39;</span><span class="p">],</span>
            <span class="n">fend</span><span class="o">=</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;frame_index&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">norm_axis</span><span class="p">,</span>
            <span class="n">nbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_bins&#39;</span><span class="p">],</span> <span class="n">refsel</span><span class="o">=</span><span class="n">ref_sel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="o">=</span> <span class="n">centers_density</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centers</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">+=</span> <span class="n">centers_density</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="MassDensProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MassDensProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="n">centers_density</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">centers_density</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="MassDensProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.MassDensProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">odict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">odict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">odict</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">odict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="n">in_dict</span></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;mass_dens&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MassDensProtocol</span>

<span class="c1"># define a new analysis &#39;nnf&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;nnf&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;nnf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>

<span class="c1">#Found in: M. Orsi and J. W. Essex, Faraday Discuss., 2013, 161, 249-272</span>
<span class="c1">#Originally described in: A. H. de Vries, A. E. Mark and S. J. Marrink, J. Phys. Chem. B, 2004, 108, 2454-2463</span>
<span class="c1">#similar method &#39;fractional interactions&#39; used in: Koldso H, Shorthouse D, He Lie Sansom MSP (2014) &quot;Lipid Clustering</span>
<span class="c1"># Correlates with Membrane Curvature as Revealed by Molecular Simulations of Complex Lipid Bilayers.&quot; PloS Comput Biol</span>
<span class="c1"># 10(10): e1003911. doi.10.1371/journal.pcbi.1003911</span>
<div class="viewcode-block" id="NNFProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NNFProtocol">[docs]</a><span class="k">class</span> <span class="nc">NNFProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the nearest neighbor fraction for one lipid type with</span>
<span class="sd">        another.</span>

<span class="sd">        This analysis picks a specified number (n_neighbors) of nearest</span>
<span class="sd">        neighbors centered on a lipid of reference lipid type and then counts</span>
<span class="sd">        the number of lipids (M) of target lipid type and estimates the</span>
<span class="sd">        fraction, nnf = M/n_neighbors. This metric is also referred to as</span>
<span class="sd">        fractional interations.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;nnf&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">                leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">            resname_1 (str): Specify the resname of the reference lipid type to</span>
<span class="sd">                include in this analysis. Default: &#39;first&#39;, the first lipid in</span>
<span class="sd">                the list pulled from the com_frame representation.</span>
<span class="sd">            resname_2 (str): Specify the resname of the target lipid type to</span>
<span class="sd">                include in this analysis. Default: &#39;first&#39;, the first lipid in</span>
<span class="sd">                the list pulled from the com_frame representation.</span>

<span class="sd">        References:</span>
<span class="sd">            1. A. H. de Vries, A. E. Mark and S. J. Marrink, J. Phys. Chem. B,</span>
<span class="sd">                2004, 108, 2454-2463</span>

<span class="sd">            2. M. Orsi and J. W. Essex, Faraday Discuss., 2013, 161, 249-272</span>

<span class="sd">            3. Koldso H, Shorthouse D, He Lie Sansom MSP (2014) &quot;Lipid</span>
<span class="sd">                Clustering Correlates with Membrane Curvature as Revealed by</span>
<span class="sd">                Molecular Simulations of Complex Lipid Bilayers.&quot; PloS Comput</span>
<span class="sd">                Biol 10(10): e1003911. doi.10.1371/journal.pcbi.1003911</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Lateral order nearest neighbor fraction.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;nnf&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1">#parse input arguments/settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># for outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="NNFProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NNFProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="NNFProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NNFProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="c1">#pass</span>
            <span class="c1"># build group/resname/lipid type list</span>
            <span class="n">lipid_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nlipids</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">leaflet_name</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">leaflet</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet_name</span><span class="p">]</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="n">nlipids</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaflet</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lipid_types</span><span class="p">:</span>
                        <span class="n">lipid_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nlipids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nlipids</span><span class="o">-</span><span class="mi">1</span>

            <span class="n">n_ltypes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lipid_types</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lipid_types</span> <span class="o">=</span> <span class="n">lipid_types</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_ltypes</span> <span class="o">=</span> <span class="n">n_ltypes</span>

        <span class="n">lipid_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipid_types</span>
        <span class="n">n_ltypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ltypes</span>
        <span class="c1">#print lipid_types</span>
        <span class="n">x_index</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_index</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">box_x</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">x_index</span><span class="p">]</span>
        <span class="n">box_y</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">y_index</span><span class="p">]</span>
        <span class="n">box_x_h</span> <span class="o">=</span> <span class="n">box_x</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">box_y_h</span> <span class="o">=</span> <span class="n">box_y</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">ltype_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span>
        <span class="n">ltype_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span>
        <span class="c1">#print &quot;ltype_a: &quot;,ltype_a,&quot; ltype_b: &quot;,ltype_b</span>
        <span class="n">avg_frac</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">leaflet_name</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
            <span class="n">leaflet</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet_name</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">has_group</span><span class="p">(</span><span class="n">ltype_a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">has_group</span><span class="p">(</span><span class="n">ltype_b</span><span class="p">):</span>
                <span class="n">ltype_a_indices</span> <span class="o">=</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">ltype_a</span><span class="p">)</span>
                <span class="n">all_index</span> <span class="o">=</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ltype_a_indices</span><span class="p">:</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">all_index</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                            <span class="n">pos_a</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span>
                            <span class="n">pos_b</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">com</span>
                            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pos_a</span><span class="p">[</span><span class="n">x_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos_b</span><span class="p">[</span><span class="n">x_index</span><span class="p">])</span>
                            <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pos_a</span><span class="p">[</span><span class="n">y_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos_b</span><span class="p">[</span><span class="n">y_index</span><span class="p">])</span>
                            <span class="c1"># minimum image for wrapped coordinates</span>
                            <span class="k">if</span> <span class="n">dx</span> <span class="o">&gt;</span> <span class="n">box_x_h</span><span class="p">:</span>
                                <span class="n">dx</span> <span class="o">=</span> <span class="n">box_x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">pos_a</span><span class="p">[</span><span class="n">x_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_x_h</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span>
                                    <span class="n">pos_b</span><span class="p">[</span><span class="n">x_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_x_h</span><span class="p">)</span>

                            <span class="k">if</span> <span class="n">dy</span> <span class="o">&gt;</span> <span class="n">box_y_h</span><span class="p">:</span>
                                <span class="n">dy</span> <span class="o">=</span> <span class="n">box_y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">pos_a</span><span class="p">[</span><span class="n">y_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_y_h</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span>
                                    <span class="n">pos_b</span><span class="p">[</span><span class="n">y_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_y_h</span><span class="p">)</span>
                            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                            <span class="n">ltype</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                            <span class="c1">#print &quot;ltype: &quot;,ltype,&quot; dist &quot;,dist</span>
                            <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">j</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">ltype</span><span class="p">])</span>
                    <span class="n">neighbors</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">nn_neighbors</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]]</span>
                    <span class="c1">#print neighbors</span>
                    <span class="c1">#print nn_neighbors</span>
                    <span class="c1">#quit()</span>
                    <span class="n">n_type_b</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">nn_neighbors</span><span class="p">:</span>
                        <span class="n">ntype</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">ntype</span> <span class="o">==</span> <span class="n">ltype_b</span><span class="p">:</span>
                            <span class="n">n_type_b</span> <span class="o">+=</span> <span class="mf">1.0</span>
                    <span class="n">frac</span> <span class="o">=</span> <span class="n">n_type_b</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">]</span>
                    <span class="c1">#print &quot;frac &quot;,frac,&quot; n_type_b: &quot;,n_type_b,&quot; set_n_neighbors: &quot;,self.settings[&#39;n_neighbors&#39;]</span>

                    <span class="n">avg_frac</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">frac</span><span class="p">)</span>

        <span class="n">f_current</span> <span class="o">=</span> <span class="n">avg_frac</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">f_current</span><span class="p">)</span>
        <span class="n">f_run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">f_run_dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tc</span><span class="p">,</span> <span class="n">f_current</span><span class="p">,</span> <span class="n">f_run</span><span class="p">,</span> <span class="n">f_run_dev</span><span class="p">])</span>
        <span class="k">return</span></div></div>

    <span class="c1"># def run_analysis(self, ba_settings, ba_reps, ba_mda_data):</span>
    <span class="c1">#</span>
    <span class="c1">#     if self._first_frame:</span>
    <span class="c1">#         pass</span>
    <span class="c1">#         #build group/resname/lipid type list</span>
    <span class="c1">#         lipid_types = []</span>
    <span class="c1">#         for leaflet in ba_reps[&#39;leaflets&#39;]:</span>
    <span class="c1">#             groups = leaflet.get_group_names()</span>
    <span class="c1">#             for group in groups:</span>
    <span class="c1">#                 if group not in lipid_types:</span>
    <span class="c1">#                     lipid_types.append(group)</span>
    <span class="c1">#         n_ltypes = len(lipid_types)</span>
    <span class="c1">#         self.lipid_types = lipid_types</span>
    <span class="c1">#         self.n_ltypes = n_ltypes</span>
    <span class="c1">#</span>
    <span class="c1">#     lipid_types = self.lipid_types</span>
    <span class="c1">#     n_ltypes = self.n_ltypes</span>
    <span class="c1">#</span>
    <span class="c1">#     x_index = ba_settings[&#39;lateral&#39;][0]</span>
    <span class="c1">#     y_index = ba_settings[&#39;lateral&#39;][1]</span>
    <span class="c1">#     box = ba_reps[&#39;current_mda_frame&#39;].dimensions[0:3]</span>
    <span class="c1">#     box_x = box[x_index]</span>
    <span class="c1">#     box_y = box[y_index]</span>
    <span class="c1">#     box_x_h = box_x/2.0</span>
    <span class="c1">#     box_y_h = box_y/2.0</span>
    <span class="c1">#</span>
    <span class="c1">#     for leaflet in ba_reps[&#39;leaflets&#39;]:</span>
    <span class="c1">#         all_indices = leaflet.get_member_indices()</span>
    <span class="c1">#</span>
    <span class="c1">#         #X-X types</span>
    <span class="c1">#         for lipid_type in lipid_types:</span>
    <span class="c1">#             if leaflet.has_group(lipid_type):</span>
    <span class="c1">#                 ltype_indices = leaflet.get_group_indices(lipid_type)</span>
    <span class="c1">#                 nlip = len(ltype_indices)</span>
    <span class="c1">#                 neigbors = dict()</span>
    <span class="c1">#                 for lindex in ltype_indices:</span>
    <span class="c1">#                     neigbors[lindex] = []</span>
    <span class="c1">#                     for lindex_b in ltype_indices:</span>
    <span class="c1">#</span>
    <span class="c1">#                         if lindex_b != lindex:</span>
    <span class="c1">#                             pos_a = ba_reps[&#39;com_frame&#39;].lipidcom[lindex].com</span>
    <span class="c1">#                             pos_b = ba_reps[&#39;com_frame&#39;].lipidcom[lindex_b].com</span>
    <span class="c1">#                             dx = np.abs(pos_a[x_index] - pos_b[x_index])</span>
    <span class="c1">#                             dy = np.abs(pos_a[y_index] - pos_b[y_index])</span>
    <span class="c1">#                             #minimum image for wrapped coordinates</span>
    <span class="c1">#                             if dx &gt; box_x_h:</span>
    <span class="c1">#                                dx = box_x - np.absolute(pos_a[x_index]-box_x_h) - np.absolute(pos_b[x_index]-box_x_h)</span>
    <span class="c1">#</span>
    <span class="c1">#                             if dy &gt; box_yy_h:</span>
    <span class="c1">#                                dy = box_y - np.absolute(pos_a[y_index]-box_y_h) - np.absolute(pos_b[y_index]-box_y_h)</span>
    <span class="c1">#                             dist = np.sqrt(dx**2 + dy**2)</span>
    <span class="c1">#                             neigbors[lindex_b].append([lindex_b, dist])</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#         #X-Y types</span>
    <span class="c1">#         for i in range(n_ltypes-1):</span>
    <span class="c1">#             for j in range(i+1, n_ltypes):</span>
    <span class="c1">#             ltype_i = lipid_types[i]</span>
    <span class="c1">#             ltype_j = lipid_types[j]</span>
    <span class="c1">#             if leaflet.has_group(ltype_i) and leaflet.has_group(ltype_j):</span>
    <span class="c1">#</span>
    <span class="c1">#                 ltype_indices = leaflet.get_group_indices()</span>
    <span class="c1">#                 for lipid_type_b in lipid_types:</span>
    <span class="c1">#                     if leaflet.has_group(lipid_type_b):</span>
    <span class="c1">#                         ltype_b_indices</span>
    <span class="c1">#     tc = ba_reps[&#39;com_frame&#39;].time</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#     return</span>


<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;nnf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NNFProtocol</span>

<span class="c1"># define a new analysis &#39;disp_vec&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;disp_vec_corr&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;disp_vec_corr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="DispVecCorrelationProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationProtocol">[docs]</a><span class="k">class</span> <span class="nc">DispVecCorrelationProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Comute the pair-wise cross correlation matrix for the displacement</span>
<span class="sd">        vectors for each lipid in the specified leaflet(s) of bilayer.</span>

<span class="sd">        This analysis computes the displacement vectors as in DispVecProtocol,</span>
<span class="sd">        but then continues to compute the pair-wise cross correlation matrix</span>
<span class="sd">        between each vector. i.e. the cos(theta) for the angle theta between the</span>
<span class="sd">        vectors.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;disp_vec_corr&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">                leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">            resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">                this analysis. Default: &#39;all&#39;, includes all lipid types.</span>
<span class="sd">            wrapped (bool): Specify whether to use the wrapped (&#39;True&#39;) or</span>
<span class="sd">                un-wrapped (&#39;False&#39;) coordintes for the base of the vectors.</span>
<span class="sd">                Default: False</span>
<span class="sd">            interval (int): Sets the frame interval over which to compute the</span>
<span class="sd">                    displacement vectors. f</span>

<span class="sd">        References:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Displacement vector correlation matrix.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;disp_vec_corr&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;interval&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;wrapped&#39;</span><span class="p">:</span>
                    <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">]</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_arg</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="DispVecCorrelationProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecCorrelationProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">frame</span>

        <span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_frame</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span><span class="p">)</span>
        <span class="c1">#print (interval, &quot; &quot;, self.settings[&#39;interval&#39;])</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;lower&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;bad setting for </span><span class="se">\&#39;</span><span class="s2">leaflet</span><span class="se">\&#39;</span><span class="s2"> in &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;. Using default </span><span class="se">\&#39;</span><span class="s2">both</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

            <span class="c1"># get the current frame</span>
            <span class="n">curr_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="n">prev_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span>
            <span class="c1"># get the coordinates for the selection at this frame</span>
            <span class="n">vec_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="c1"># vec_ends = []</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">resnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">resname</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                <span class="n">resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span>
                <span class="n">com_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#    vec_ends.append([com_j[0],com_j[0],com_i[0]-com_j[0],com_i[1]-com_j[1]])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">corr_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="n">n_com</span><span class="p">))</span>
            <span class="c1">#loop over vectors</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com</span><span class="p">):</span>
                <span class="n">corr_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">vec_end_a</span> <span class="o">=</span> <span class="n">vec_ends</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vec_a</span> <span class="o">=</span> <span class="n">vec_end_a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec_end_a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_com</span><span class="p">):</span>
                    <span class="n">vec_end_b</span> <span class="o">=</span> <span class="n">vec_ends</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">vec_b</span> <span class="o">=</span> <span class="n">vec_end_b</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec_end_b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_a</span><span class="p">,</span> <span class="n">vec_b</span><span class="p">)</span>
                    <span class="n">cos_t</span> <span class="o">=</span> <span class="n">dot</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_a</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_b</span><span class="p">))</span>
                    <span class="n">corr_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_t</span>
                    <span class="n">corr_mat</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_t</span>



            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">corr_mat</span><span class="p">,</span> <span class="n">resnames</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="n">current_frame</span>
            <span class="c1">#return vec_ends</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecCorrelationProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecCorrelationProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecCorrelationProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;disp_vec_corr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DispVecCorrelationProtocol</span>

<span class="c1"># define a new analysis &#39;disp_vec&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;disp_vec_nncorr&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;disp_vec_nncorr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="DispVecNNCorrelationProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecNNCorrelationProtocol">[docs]</a><span class="k">class</span> <span class="nc">DispVecNNCorrelationProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Comute the pair-wise cross correlations for the displacement</span>
<span class="sd">        vectors for each lipid in the specified leaflet(s) of bilayer and its</span>
<span class="sd">        nearest neighbor.</span>

<span class="sd">        This analysis computes the displacement vectors as in DispVecProtocol,</span>
<span class="sd">        but then continues to compute the pair-wise cross correlation between</span>
<span class="sd">        each vector and its nearest neighbor. i.e. the cos(theta) for the angle</span>
<span class="sd">        theta between the vectors.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;disp_vec_nncorr&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">                leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">            resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">                this analysis. Default: &#39;all&#39;, includes all lipid types.</span>
<span class="sd">            wrapped (bool): Specify whether to use the wrapped (&#39;True&#39;) or</span>
<span class="sd">                un-wrapped (&#39;False&#39;) coordintes for the base of the vectors.</span>
<span class="sd">                Default: False</span>
<span class="sd">            interval (int): Sets the frame interval over which to compute the</span>
<span class="sd">                    displacement vectors. f</span>

<span class="sd">        References:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Displacement vector nearest neigbor correlations.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;disp_vec_nncorr&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;interval&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;wrapped&#39;</span><span class="p">:</span>
                    <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">]</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_arg</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="DispVecNNCorrelationProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecNNCorrelationProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecNNCorrelationProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecNNCorrelationProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">frame</span>

        <span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_frame</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span><span class="p">)</span>
        <span class="c1">#print (interval, &quot; &quot;, self.settings[&#39;interval&#39;])</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interval&#39;</span><span class="p">]:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;lower&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;bad setting for </span><span class="se">\&#39;</span><span class="s2">leaflet</span><span class="se">\&#39;</span><span class="s2"> in &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;. Using default </span><span class="se">\&#39;</span><span class="s2">both</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

            <span class="c1"># get the current frame</span>
            <span class="n">curr_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="n">prev_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span>
            <span class="c1">#get the vector ends</span>

            <span class="c1"># get the coordinates for the selection at this frame</span>
            <span class="n">vec_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
            <span class="c1"># vec_ends = []</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">resnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">resname</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                <span class="n">resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span>
                <span class="n">com_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">com_j_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;wrapped&#39;</span><span class="p">]:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j_w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#    vec_ends.append([com_j[0],com_j[0],com_i[0]-com_j[0],com_i[1]-com_j[1]])</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="c1">#loop over vectors</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com</span><span class="p">):</span>
                <span class="n">vec_end_a</span> <span class="o">=</span> <span class="n">vec_ends</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vec_a</span> <span class="o">=</span> <span class="n">vec_end_a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec_end_a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1">#now loop over again and find nearest neighbor at vector bases</span>
                <span class="n">nn_vec</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">nn_dist</span> <span class="o">=</span> <span class="mf">1000000.0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">vec_end_b</span> <span class="o">=</span> <span class="n">vec_ends</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">vec_b</span> <span class="o">=</span> <span class="n">vec_end_b</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">vec_end_b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_end_b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">vec_end_a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">nn_dist</span><span class="p">:</span>
                            <span class="n">nn_dist</span> <span class="o">=</span> <span class="n">dist</span>
                            <span class="n">nn_vec</span> <span class="o">=</span> <span class="n">vec_b</span>
                <span class="c1">#now analysis the correlation (cos(theta))</span>
                <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_a</span><span class="p">,</span> <span class="n">nn_vec</span><span class="p">)</span>
                <span class="n">cos_t</span> <span class="o">=</span> <span class="n">dot</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec_a</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">nn_vec</span><span class="p">))</span>
                <span class="n">corr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_t</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">corr</span><span class="p">,</span> <span class="n">resnames</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_frame</span> <span class="o">=</span> <span class="n">current_frame</span>
            <span class="c1">#return vec_ends</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecNNCorrelationProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecNNCorrelationProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DispVecNNCorrelationProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DispVecNNCorrelationProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div></div>


<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;disp_vec_nncorr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DispVecNNCorrelationProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ndcorr&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;ndcorr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>

<div class="viewcode-block" id="NDCorrProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NDCorrProtocol">[docs]</a><span class="k">class</span> <span class="nc">NDCorrProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Correlation between bilayer surfucace curvature and the clustering of</span>
<span class="sd">        lipid molecules.</span>

<span class="sd">        This protocol is used to estimate the cross correlation between the</span>
<span class="sd">        normal dimension deflection of lipids and the lipid types in local</span>
<span class="sd">        blocks of the bilayer. This serves as a measure of the correlation</span>
<span class="sd">        between the local curvature and composition of the bilayer.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;ndcorr&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            None</span>

<span class="sd">        Note:</span>
<span class="sd">            Automatically estimates the correlations with each lipid type in the</span>
<span class="sd">            bilayer selection provided to the external BilayerAnalyzer object.</span>

<span class="sd">        References:</span>
<span class="sd">            1. Koldso H, Shorthouse D, He Lie Sansom MSP (2014) &quot;Lipid</span>
<span class="sd">                Clustering Correlates with Membrane Curvature as Revealed by</span>
<span class="sd">                Molecular Simulations of Complex Lipid Bilayers.&quot; PloS Comput</span>
<span class="sd">                Biol 10(10): e1003911. doi.10.1371/journal.pcbi.1003911</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Normal dimension displacement-lipid type cross correlation.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;ndcorr&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># default function settings</span>

        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="c1">#save file name for pickle dump of results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1">#for analysis and outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">return</span>


<div class="viewcode-block" id="NDCorrProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NDCorrProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="c1">#construct the grids</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="n">lgc</span><span class="o">.</span><span class="n">LipidGrids</span><span class="p">(</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">],</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">],</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">leafs</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">leaf_grid</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">all_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leafs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_types</span><span class="p">:</span>
                        <span class="n">all_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leafs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l_type</span> <span class="ow">in</span> <span class="n">all_types</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#analysis the correlations</span>
        <span class="n">correlations</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">norm_displacement_cross_correlation</span><span class="p">()</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1">#extract the data</span>
        <span class="n">leafs</span> <span class="o">=</span> <span class="n">correlations</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leafs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l_type</span> <span class="ow">in</span> <span class="n">correlations</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">corr</span> <span class="o">=</span> <span class="n">correlations</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>
                <span class="n">corr_run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">corr_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">leaf</span><span class="p">][</span><span class="n">l_type</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">time</span><span class="p">,</span> <span class="n">corr</span><span class="p">,</span> <span class="n">corr_run</span><span class="p">,</span> <span class="n">corr_std</span><span class="p">]))</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="NDCorrProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NDCorrProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="NDCorrProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.NDCorrProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">tkey</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">tkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">tkey</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;ndcorr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NDCorrProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;dc_cluster&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;dc_cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>

<span class="c1">#</span>
<div class="viewcode-block" id="DCClusterProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DCClusterProtocol">[docs]</a><span class="k">class</span> <span class="nc">DCClusterProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A type of hiearchical clustering where points (lipid centers of mass)</span>
<span class="sd">        are are added to a cluster if they are within a specified distance</span>
<span class="sd">        of any other point within the cluster.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;dc_cluster&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">                leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">            resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">                this analysis. Default: &#39;all&#39;, includes all lipid types.</span>
<span class="sd">            cutoff (float): The cutoff distance to use for the clustering.</span>
<span class="sd">                Default: 12.0</span>

<span class="sd">        Note:</span>
<span class="sd">            Only finds the self clusters for a single lipid type as specified by</span>
<span class="sd">            the &#39;resname&#39; setting.</span>

<span class="sd">        References:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Distance cutoff clustering.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;dc_cluster&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cutoff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">12.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># default function settings</span>

        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="c1">#save file name for pickle dump of results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1">#for analysis and outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;nclusters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;min_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;avg_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;nclusters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;min_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;avg_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;cutoff&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>

<div class="viewcode-block" id="DCClusterProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DCClusterProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="c1">#pass</span>
            <span class="c1"># build group/resname/lipid type list</span>
            <span class="n">lipid_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">leaflet_name</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">leaflet</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet_name</span><span class="p">]</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
        <span class="c1">#        nlipids += len(leaflet.get_member_indices())</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lipid_types</span><span class="p">:</span>
                        <span class="n">lipid_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]])</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
        <span class="n">dist_func</span> <span class="o">=</span> <span class="n">dc_cluster</span><span class="o">.</span><span class="n">distance_euclidean_pbc</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">dc_cluster</span><span class="o">.</span><span class="n">distance_cutoff_clustering</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cutoff&#39;</span><span class="p">],</span> <span class="n">dist_func</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;box_half&#39;</span><span class="p">)</span>

        <span class="n">nclusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
        <span class="n">min_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">avg_size</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">max_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">min_size</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">elif</span> <span class="n">max_size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">max_size</span><span class="p">:</span>
                <span class="n">min_size</span> <span class="o">=</span> <span class="n">n</span>
            <span class="n">avg_size</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="c1">#protect for divide by zero</span>
        <span class="k">if</span> <span class="n">nclusters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">avg_size</span> <span class="o">/=</span> <span class="n">nclusters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;nclusters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">nclusters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">max_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;min_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">min_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;avg_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">avg_size</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;nclusters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span><span class="n">nclusters</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;nclusters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;nclusters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">deviation</span><span class="p">()])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span><span class="n">max_size</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">deviation</span><span class="p">()])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;min_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span><span class="n">min_size</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;min_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;min_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">deviation</span><span class="p">()])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="s1">&#39;avg_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span><span class="n">avg_size</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;avg_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="s1">&#39;avg_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">deviation</span><span class="p">()])</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="DCClusterProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DCClusterProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">running_stats</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">converted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="DCClusterProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.DCClusterProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">converted</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;clusters&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">converted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;dc_cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DCClusterProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;vcm&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;vcm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>

<div class="viewcode-block" id="VolumeCompressibilityModulusProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.VolumeCompressibilityModulusProtocol">[docs]</a><span class="k">class</span> <span class="nc">VolumeCompressibilityModulusProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the isothermal volume compressibility modulus.</span>

<span class="sd">        This protocol is used to estimate the volume compressibility modulus,</span>
<span class="sd">            K_V = (&lt;V&gt;kT) / var(V),</span>
<span class="sd">        where V is the volume.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;vcm&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            temperature (float): The absolute temperature that the simulation</span>
<span class="sd">                was run at (i.e. in Kelvin). Default: 298.15 K</span>

<span class="sd">        References:</span>
<span class="sd">            1. Christofer Hofsab, Erik Lindahl, and Olle Edholm, &quot;Molecular</span>
<span class="sd">                Dynamics Simulations of Phospholipid Bilayers with Cholesterol&quot;,</span>
<span class="sd">                Biophys J. 2003 Apr; 84(4): 2192-2206.</span>
<span class="sd">                doi:  10.1016/S0006-3495(03)75025-5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Volume compressibility modulus.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;vcm&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">298.15</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># parse input arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1">#output filename for pickle dump of results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>


        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;temperature&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>


<div class="viewcode-block" id="VolumeCompressibilityModulusProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.VolumeCompressibilityModulusProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume_run</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="VolumeCompressibilityModulusProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.VolumeCompressibilityModulusProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">dimensions</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
        <span class="c1">#print(area)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>

        <span class="n">Kv</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># return</span>
            <span class="n">Kv</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Kv</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">*</span> <span class="n">scicon</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">])</span>
                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume_run</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span> <span class="n">Kv</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;vcm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">VolumeCompressibilityModulusProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;acm&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;acm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>

<div class="viewcode-block" id="AreaCompressibilityModulusProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaCompressibilityModulusProtocol">[docs]</a><span class="k">class</span> <span class="nc">AreaCompressibilityModulusProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the isothermal area compressibility modulus.</span>

<span class="sd">        This protocol is used to estimate the area compressibility modulus,</span>
<span class="sd">            K_A = (&lt;A&gt;kT) / var(A),</span>
<span class="sd">        where A is the area in the lateal dimension of the bilayer.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;acm&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            temperature (float): The absolute temperature that the simulation</span>
<span class="sd">                was run at (i.e. in Kelvin). Default: 298.15 K</span>

<span class="sd">        References:</span>
<span class="sd">            1. Christofer Hofsab, Erik Lindahl, and Olle Edholm, &quot;Molecular</span>
<span class="sd">                Dynamics Simulations of Phospholipid Bilayers with Cholesterol&quot;,</span>
<span class="sd">                Biophys J. 2003 Apr; 84(4): 2192-2206.</span>
<span class="sd">                doi:  10.1016/S0006-3495(03)75025-5</span>
<span class="sd">            2. L. Janosi and A. A. Gorfe, J. Chem. Theory Comput. 2010, 6,</span>
<span class="sd">                3267-3273</span>
<span class="sd">            3. D. Aguayo, F. D. Gonzalez-Nilo, and C. Chipot, J. Chem. Theory</span>
<span class="sd">                Comput. 2012, 8, 1765-1773</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Area compressibility modulus.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;acm&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">298.15</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># parse input arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1">#output filename for pickle dump of results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>


        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;temperature&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>


<div class="viewcode-block" id="AreaCompressibilityModulusProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaCompressibilityModulusProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="AreaCompressibilityModulusProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaCompressibilityModulusProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">dimensions</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span><span class="o">/</span><span class="n">dimensions</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]]</span>
        <span class="c1">#print(area)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
        <span class="n">Ka</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="o">+=</span><span class="mi">1</span>
            <span class="c1">#return</span>
            <span class="n">Ka</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ka</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">*</span><span class="n">scicon</span><span class="o">.</span><span class="n">k</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">variance</span><span class="p">()</span>
        <span class="c1">#print &quot;&lt;A&gt;: &quot;, self.area_run.mean(), &quot; var(A): &quot;,self.area_run.variance()</span>
        <span class="c1">#print &quot;T: &quot;,self.settings[&#39;temperature&#39;],&quot; k: &quot;,scicon.k</span>
        <span class="c1">#conversion factor for Joules/Angstrom^2 to milliNewtons/meter</span>
        <span class="n">Ka</span><span class="o">*=</span><span class="mf">10.0</span><span class="o">**</span><span class="mi">23</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span> <span class="n">Ka</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;acm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">AreaCompressibilityModulusProtocol</span>

<span class="c1"># define a new analysis &#39;msd&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ald&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;ald&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>

<span class="c1">#ALD From:</span>
<span class="c1">#Kenichiro Koshiyama, Tetsuya Kodama, Takeru Yano, Shigeo Fujikawa,</span>
<span class="c1"># &quot;Molecular dynamics simulation of structural changes of lipid bilayers</span>
<span class="c1"># induced by shock waves: Effects of incident angles&quot;, Biochimica et Biophysica</span>
<span class="c1"># Acta (BBA) - Biomembranes, Volume 1778, Issue 6, June 2008, Pages 1423-1428</span>
<div class="viewcode-block" id="ALDProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.ALDProtocol">[docs]</a><span class="k">class</span> <span class="nc">ALDProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the average lateral displacement of lipids.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;ald&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">                leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">            resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">                this analysis. Default: &#39;all&#39;, includes all lipid types.</span>

<span class="sd">        References:</span>
<span class="sd">            1. Kenichiro Koshiyama, Tetsuya Kodama, Takeru Yano, Shigeo</span>
<span class="sd">                Fujikawa, &quot;Molecular dynamics simulation of structural changes</span>
<span class="sd">                of lipid bilayers induced by shock waves: Effects of incident</span>
<span class="sd">                angles&quot;, Biochimica et Biophysica Acta (BBA) - Biomembranes,</span>
<span class="sd">                Volume 1778, Issue 6, June 2008, Pages 1423-1428</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Average lateral displacement.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;ald&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>


<div class="viewcode-block" id="ALDProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.ALDProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="nb">print</span> <span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">leaflet</span>
                <span class="nb">print</span> <span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">selcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">com_curr</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
            <span class="n">selcoords</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_curr</span><span class="p">[:]</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># initialize a numpy array to hold the msd for the selection</span>
        <span class="n">msd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># initialize a running stats object to do the averaging over resids</span>
        <span class="c1">#drs_stat = RunningStats()</span>

        <span class="n">ref_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">com_curr</span> <span class="o">=</span> \
                    <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;first_com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span>
                        <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">]]</span>
                <span class="n">ref_coords</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">com_curr</span><span class="p">[:]</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="n">ref_coords</span><span class="p">[:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span>
            <span class="c1"># get the current com frame list</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">tc</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">selcoords</span> <span class="o">-</span> <span class="n">ref_coords</span>
        <span class="n">m_dr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dr</span><span class="p">:</span>
            <span class="n">m_dr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">)))</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">m_dr</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">m_dr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="c1"># get the msd for the current selection</span>
        <span class="n">Lcurr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">msd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="n">msd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Lcurr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msd</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="ALDProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.ALDProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L_stat</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div></div>
<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;ald&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ALDProtocol</span>

<span class="c1"># define a new analysis &#39;apl_box&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ac&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;ac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>
<span class="c1">#Yoshimichi Andoha, Susumu Okazakia, Ryuichi Ueokab, &quot;Molecular dynamics</span>
<span class="c1"># study of lipid bilayers modeling the plasma membranes of normal murine</span>
<span class="c1"># thymocytes and leukemic GRSL cells&quot;, Biochimica et Biophysica Acta (BBA)</span>
<span class="c1"># - Biomembranes, Volume 1828, Issue 4, April 2013, Pages 1259-1270.</span>
<span class="c1"># https://doi.org/10.1016/j.bbamem.2013.01.005</span>
<span class="c1"># Note: Area Compressibility is a defined in the reference is the inverse of</span>
<span class="c1"># area compressibility modulus.</span>
<div class="viewcode-block" id="AreaCompressibilityProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaCompressibilityProtocol">[docs]</a><span class="k">class</span> <span class="nc">AreaCompressibilityProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>

        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Isothermal area compressibility.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;ac&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">298.15</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># parse input arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1">#output filename for pickle dump of results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>


        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_fluctuation</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span>

    <span class="c1"># required- function to parse the input arguments from string</span>
    <span class="k">def</span> <span class="nf">_cast_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_dict</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="n">arg_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">arg_arg</span> <span class="o">=</span> <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;temperature&#39;</span><span class="p">:</span>
                    <span class="n">arg_dict</span><span class="p">[</span><span class="n">arg_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arg_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arg_key</span> <span class="o">==</span> <span class="s1">&#39;analysis_id&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;ignoring invalid argument key &quot;</span> <span class="o">+</span> <span class="n">arg_key</span> <span class="o">+</span> <span class="s2">&quot; for analysis&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg_dict</span>


<div class="viewcode-block" id="AreaCompressibilityProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaCompressibilityProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_fluctuation</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="AreaCompressibilityProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.AreaCompressibilityProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">dimensions</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span><span class="o">/</span><span class="n">dimensions</span><span class="p">[</span><span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
        <span class="n">area_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">fluctuation</span> <span class="o">=</span> <span class="p">(</span><span class="n">area</span> <span class="o">-</span> <span class="n">area_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_fluctuation</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">fluctuation</span><span class="p">)</span>
        <span class="n">X_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_run</span><span class="o">.</span><span class="n">variance</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">area_mean</span> <span class="o">*</span> <span class="n">scicon</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">])</span>
        <span class="c1">#conversion factor for Angstrom^2/Joules to meter^2/Joule</span>
        <span class="n">X_T</span><span class="o">*=</span><span class="mf">10.0</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">23</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">time</span><span class="p">,</span> <span class="n">X_T</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;ac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">AreaCompressibilityProtocol</span>

<span class="c1"># define a new analysis</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lop&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;lop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>
<span class="c1">#Based on P-N vector-normal angle:</span>
<span class="c1">#Zheng Li, Richard M. Venable, Laura A. Rogers, Diana Murray,</span>
<span class="c1"># and Richard W. Pastor, &quot;Molecular Dynamics Simulations of PIP2 and PIP3</span>
<span class="c1"># in Lipid Bilayers: Determination of Ring Orientation, and the Effects of</span>
<span class="c1"># Surface Roughness on a Poisson-Boltzmann Description&quot;, Biophys J. 2009 Jul 8;</span>
<span class="c1"># 97(1): 155-163.</span>
<span class="c1"># doi:  10.1016/j.bpj.2009.04.037</span>
<div class="viewcode-block" id="LateralOrientationParameterProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LateralOrientationParameterProtocol">[docs]</a><span class="k">class</span> <span class="nc">LateralOrientationParameterProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Lateral orientation parameter.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;lop&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;P&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;N&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="LateralOrientationParameterProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LateralOrientationParameterProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="c1">#norm_vec = np.zeros(3)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm_vec</span><span class="p">[</span><span class="n">norm</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">res_com</span> <span class="o">=</span> <span class="n">com_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">res_com</span><span class="o">.</span><span class="n">resid</span>

                <span class="n">sel_string</span> <span class="o">=</span> <span class="s2">&quot;resname &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot; and resid &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span>
                <span class="n">res_sel</span> <span class="o">=</span> <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">mda_universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel_string</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">res_sel</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">+=</span> <span class="n">res_sel</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="o">.</span><span class="n">residues</span>
        <span class="n">cos_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
            <span class="n">atom_1</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;residue.</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_1&#39;</span><span class="p">]))</span>
            <span class="n">atom_2</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;residue.</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_2&#39;</span><span class="p">]))</span>
            <span class="c1">#atom_1 = ast.literal_eval(&quot;residue.{}&quot;.format(self.settings[&#39;ref_atom_1&#39;]))</span>
            <span class="c1">#atom_2 = ast.literal_eval(&quot;residue.{}&quot;.format(self.settings[&#39;ref_atom_2&#39;]))</span>
            <span class="n">atom_1_i</span> <span class="o">=</span> <span class="n">atom_1</span><span class="o">.</span><span class="n">index</span>
            <span class="n">atom_2_i</span> <span class="o">=</span> <span class="n">atom_2</span><span class="o">.</span><span class="n">index</span>
            <span class="n">atom_1_coord</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atom_1_i</span><span class="p">]</span>
            <span class="n">atom_2_coord</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atom_2_i</span><span class="p">]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">atom_2_coord</span> <span class="o">-</span> <span class="n">atom_1_coord</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">diff</span><span class="p">))</span>
            <span class="n">cos_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_vec</span><span class="p">)</span><span class="o">/</span><span class="n">dist</span>
            <span class="n">cos_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">cos_t</span><span class="p">)</span>
        <span class="n">cos_t_avg</span> <span class="o">=</span> <span class="n">cos_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">cos_t_avg</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1">#self.running.push(ap</span>
        <span class="n">cos_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span><span class="p">)</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_t_avg</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cos_t</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="LateralOrientationParameterProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LateralOrientationParameterProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;lop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LateralOrientationParameterProtocol</span>

<span class="c1"># define a new analysis</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;loa&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;loa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;mda_frame&#39;</span>
<span class="c1">#Based on P-N vector-normal angle:</span>
<span class="c1">#Zheng Li, Richard M. Venable, Laura A. Rogers, Diana Murray,</span>
<span class="c1"># and Richard W. Pastor, &quot;Molecular Dynamics Simulations of PIP2 and PIP3</span>
<span class="c1"># in Lipid Bilayers: Determination of Ring Orientation, and the Effects of</span>
<span class="c1"># Surface Roughness on a Poisson-Boltzmann Description&quot;, Biophys J. 2009 Jul 8;</span>
<span class="c1"># 97(1): 155-163.</span>
<span class="c1"># doi:  10.1016/j.bpj.2009.04.037</span>
<div class="viewcode-block" id="LateralOrientationAngleProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LateralOrientationAngleProtocol">[docs]</a><span class="k">class</span> <span class="nc">LateralOrientationAngleProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Lateral orientation angle.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;lop&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1">#define adjustable settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;P&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;N&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># default function settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>

        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="LateralOrientationAngleProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LateralOrientationAngleProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="c1">#norm_vec = np.zeros(3)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm_vec</span><span class="p">[</span><span class="n">norm</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">res_com</span> <span class="o">=</span> <span class="n">com_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">res_com</span><span class="o">.</span><span class="n">resid</span>

                <span class="n">sel_string</span> <span class="o">=</span> <span class="s2">&quot;resname &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot; and resid &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span>
                <span class="n">res_sel</span> <span class="o">=</span> <span class="n">ba_mda_data</span><span class="o">.</span><span class="n">mda_universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel_string</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">res_sel</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">+=</span> <span class="n">res_sel</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="o">.</span><span class="n">residues</span>
        <span class="n">cos_run</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
            <span class="n">atom_1</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;residue.&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_1&#39;</span><span class="p">])</span>
            <span class="n">atom_2</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;residue.&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_atom_2&#39;</span><span class="p">])</span>
            <span class="n">atom_1_i</span> <span class="o">=</span> <span class="n">atom_1</span><span class="o">.</span><span class="n">index</span>
            <span class="n">atom_2_i</span> <span class="o">=</span> <span class="n">atom_2</span><span class="o">.</span><span class="n">index</span>
            <span class="n">atom_1_coord</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atom_1_i</span><span class="p">]</span>
            <span class="n">atom_2_coord</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atom_2_i</span><span class="p">]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">atom_2_coord</span> <span class="o">-</span> <span class="n">atom_1_coord</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">diff</span><span class="p">))</span>
            <span class="n">cos_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_vec</span><span class="p">)</span><span class="o">/</span><span class="n">dist</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="mf">90.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cos_t</span><span class="p">)</span><span class="o">*</span><span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

            <span class="n">cos_run</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">cos_t_avg</span> <span class="o">=</span> <span class="n">cos_run</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">cos_t_avg</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;current_mda_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1">#self.running.push(ap</span>
        <span class="n">cos_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span><span class="p">)</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_t_avg</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">cos_t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cos_t</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="LateralOrientationAngleProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LateralOrientationAngleProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_comp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div></div>

<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;loa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LateralOrientationAngleProtocol</span>

<span class="c1"># define a new analysis &#39;flip_flop&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;flip_flop&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;flip_flop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="FlipFlopProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.FlipFlopProtocol">[docs]</a><span class="k">class</span> <span class="nc">FlipFlopProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Count any lipid flips flops between the leaflets.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;flip_flop&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            None</span>

<span class="sd">        References:</span>
<span class="sd">            1. Andrey A. Gurtovenko, and Ilpo Vattulainen, Molecular Mechanism</span>
<span class="sd">                for Lipid Flip-Flops, The Journal of Physical Chemistry B, 2007</span>
<span class="sd">                111 (48), 13554-13559, DOI: 10.1021/jp077094k</span>
<span class="sd">                http://pubs.acs.org/doi/abs/10.1021/jp077094k?journalCode=jpcbfk</span>

<span class="sd">            2. Nicolas Sapay, W. F. Drew Bennett, and D. Peter Tieleman,</span>
<span class="sd">                Molecular Simulations of Lipid Flip-Flop in the Presence of</span>
<span class="sd">                Model Transmembrane Helices, Biochemistry, 2010 49 (35),</span>
<span class="sd">                7665-7673, DOI: 10.1021/bi100878q</span>
<span class="sd">                http://pubs.acs.org/doi/abs/10.1021/bi100878q</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Count lipid flip flops.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;flip_flop&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_leaf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span>


<div class="viewcode-block" id="FlipFlopProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.FlipFlopProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reference_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reference_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">leaflet</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">resnames</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">resname</span> <span class="ow">in</span> <span class="n">resnames</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">resname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resnames</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">resname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resnames</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">resname</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;events&#39;</span><span class="p">:[]}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>
        <span class="n">curr_leaflets</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">leaflet</span> <span class="ow">in</span> <span class="n">curr_leaflets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">o_leaf</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">curr_leaflets</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">leaf</span> <span class="o">!=</span> <span class="n">leaflet</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_leaf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">o_leaf</span> <span class="o">=</span> <span class="n">o_leaf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">o_leaf</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">curr_leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reference_leaf</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>
            <span class="c1"># o_leaf -&gt; leaflet</span>
            <span class="n">forward_diff</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="c1"># leaflet -&gt; o_leaf</span>
            <span class="n">backward_diff</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">forward_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">forward_diff</span><span class="p">:</span>
                    <span class="n">resname</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                    <span class="n">resid</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">resid</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
                    <span class="n">frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mdnumber</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">resname</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">resname</span><span class="p">][</span><span class="s1">&#39;events&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">frame</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span>
                                                            <span class="n">o_leaf</span><span class="p">,</span> <span class="n">leaflet</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">backward_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">backward_diff</span><span class="p">:</span>
                    <span class="n">resname</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                    <span class="n">resid</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">resid</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
                    <span class="n">frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mdnumber</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">resname</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">[</span><span class="n">resname</span><span class="p">][</span><span class="s1">&#39;events&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">frame</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span>
                                                            <span class="n">leaflet</span><span class="p">,</span> <span class="n">o_leaf</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">forward_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">backward_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reference_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reference_com_frame</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span>
            <span class="k">break</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="FlipFlopProtocol.save_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.FlipFlopProtocol.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dumps the outputs of this protocol to disc.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str, Optional): The string containing the path to the location</span>
<span class="sd">                that the analysis results should be dumped to on disc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">save_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_file</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="FlipFlopProtocol.get_data"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.FlipFlopProtocol.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the analysis_output of this protocol. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span></div>

<div class="viewcode-block" id="FlipFlopProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.FlipFlopProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the analysis by resetting the outputs and any necessary</span>
<span class="sd">        internal variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_leaf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_com_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span></div></div>
<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;flip_flop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FlipFlopProtocol</span>

<span class="c1"># define a new analysis &#39;lipid_length&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lipid_length&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;lipid_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;vector_frame&#39;</span>

<div class="viewcode-block" id="LipidLengthProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LipidLengthProtocol">[docs]</a><span class="k">class</span> <span class="nc">LipidLengthProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the lipids length using the defined lipid vector.</span>

<span class="sd">        The LipidLengthProtocol is used to compute the mean lipid length using</span>
<span class="sd">        the vector represetation of the specified lipids.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;lipid_length&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            leaflet (str: &#39;both&#39;, &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">                leaflet to include in the estimate. Default: &#39;both&#39;</span>
<span class="sd">            resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">                this analysis. Default: &#39;all&#39;, averages over all lipid types.</span>

<span class="sd">        References:</span>
<span class="sd">            1. Anton O. Chugunov,  Pavel E. Volynsky, Nikolay A. Krylov,</span>
<span class="sd">                Ivan A. Boldyrev, and Roman G. Efremov,  Liquid but Durable:</span>
<span class="sd">                Molecular Dynamics Simulations Explain the Unique Properties of</span>
<span class="sd">                Archaeal-Like Membranes, Scientific Reports, 4:7462, 2014,</span>
<span class="sd">                doi:10.1038/srep07462</span>
<span class="sd">                (https://www.nature.com/articles/srep07462)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Estimate of lipid length using the lipid vectors.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;lipid_length&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>


<div class="viewcode-block" id="LipidLengthProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LipidLengthProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="nb">print</span> <span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">leaflet</span>
                <span class="nb">print</span> <span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">vec_curr</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>
            <span class="n">lengths</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_curr</span><span class="p">,</span> <span class="n">vec_curr</span><span class="p">))</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># get the current com frame list</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1"># get the msd for the current selection</span>
        <span class="n">mean_length</span> <span class="o">=</span> <span class="n">lengths</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">lipid_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tc</span><span class="p">,</span> <span class="n">mean_length</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lipid_length</span><span class="p">)</span>
        <span class="k">return</span></div></div>


<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;lipid_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LipidLengthProtocol</span>

<span class="c1"># define a new analysis</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lipid_tilt&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;lipid_tilt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;vector_frame&#39;</span>

<div class="viewcode-block" id="LipidTiltProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LipidTiltProtocol">[docs]</a><span class="k">class</span> <span class="nc">LipidTiltProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the lipids tilt angles using the defined lipid vector.</span>

<span class="sd">        The LipidTiltProtocol is used to compute the mean lipid tilt using</span>
<span class="sd">        the vector represetation of the specified lipids in reference to</span>
<span class="sd">        a particular axis, typically the bilayer normal.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;lipid_tilt&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            leaflet (str: &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">                leaflet to include in the estimate. Default: &#39;upper&#39;</span>
<span class="sd">            resname (str): Specify the resname of the lipid type to include in</span>
<span class="sd">                this analysis. Default: &#39;all&#39;, averages over all lipid types.</span>
<span class="sd">            style (str: &#39;angle&#39;, &#39;order&#39;): Specify whether to compute the</span>
<span class="sd">                tilt angle (&#39;angle&#39;) or the tilt angle order parameter (&#39;order&#39;).</span>
<span class="sd">                Default: &#39;angle&#39;</span>
<span class="sd">            ref_axis (str: &#39;x&#39;, &#39;y&#39;, or &#39;z&#39;): Specify the reference axis that</span>
<span class="sd">                should be used to estimate the tilt. This is typically the</span>
<span class="sd">                axis along the bilayer normal. Default: &#39;z&#39;</span>

<span class="sd">        References:</span>
<span class="sd">            1. Anton O. Chugunov,  Pavel E. Volynsky, Nikolay A. Krylov,</span>
<span class="sd">                Ivan A. Boldyrev, and Roman G. Efremov,  Liquid but Durable:</span>
<span class="sd">                Molecular Dynamics Simulations Explain the Unique Properties of</span>
<span class="sd">                Archaeal-Like Membranes, Scientific Reports, 4:7462, 2014,</span>
<span class="sd">                doi:10.1038/srep07462</span>
<span class="sd">                (https://www.nature.com/articles/srep07462)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Estimate of lipid tilt using the lipid vectors.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;lipid_tilt&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;angle&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;z&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>


<div class="viewcode-block" id="LipidTiltProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LipidTiltProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
        <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="nb">print</span> <span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">leaflet</span>
                <span class="nb">print</span> <span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">indices</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_axis&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_axis&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;ref_axis&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">vec_curr</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span>
                <span class="n">vec_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_curr</span><span class="p">,</span> <span class="n">vec_curr</span><span class="p">))</span>
                <span class="n">angle_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_curr</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span><span class="p">)</span><span class="o">/</span><span class="n">vec_length</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="mf">90.0</span> <span class="o">-</span> <span class="n">angle_rad</span><span class="o">*</span><span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;order&#39;</span><span class="p">:</span>
                <span class="n">vec_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_curr</span><span class="p">,</span> <span class="n">vec_curr</span><span class="p">))</span>
                <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_curr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span><span class="p">)</span><span class="o">/</span><span class="n">vec_length</span>

            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># get the current com frame list</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1"># get the msd for the current selection</span>
        <span class="n">mean_value</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">lipid_tilt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tc</span><span class="p">,</span> <span class="n">mean_value</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lipid_tilt</span><span class="p">)</span>
        <span class="k">return</span></div></div>


<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;lipid_tilt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LipidTiltProtocol</span>

<span class="c1"># define a new analysis</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lipid_collinearity&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;lipid_collinearity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;vector_frame&#39;</span>

<div class="viewcode-block" id="LipidCollinearityProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LipidCollinearityProtocol">[docs]</a><span class="k">class</span> <span class="nc">LipidCollinearityProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the lipid-lipid collinearity angles.</span>

<span class="sd">        The LipidCollinearityProtocol is used to compute the mean lipid-lipid</span>
<span class="sd">        collinearity angle (or order parameter) using the vector represetation</span>
<span class="sd">        of the specified lipids.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;lipid_collinearity&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            leaflet (str: &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">                leaflet to include in the estimate. Default: &#39;upper&#39;</span>
<span class="sd">            resname_1 (str): Specify the resname of the reference lipid type to</span>
<span class="sd">                include in this analysis. Default: &#39;first&#39;, the first lipid in</span>
<span class="sd">                the list pulled from the com_frame representation.</span>
<span class="sd">            resname_2 (str): Specify the resname of the target lipid type to</span>
<span class="sd">                include in this analysis. Default: &#39;first&#39;, the first lipid in</span>
<span class="sd">                the list pulled from the com_frame representation.</span>
<span class="sd">            style (str: &#39;angle&#39;, &#39;order&#39;): Specify whether to compute the</span>
<span class="sd">                tilt angle (&#39;angle&#39;) or the tilt angle order parameter (&#39;order&#39;).</span>
<span class="sd">                Default: &#39;angle&#39;</span>

<span class="sd">        References:</span>
<span class="sd">            1. Anton O. Chugunov,  Pavel E. Volynsky, Nikolay A. Krylov,</span>
<span class="sd">                Ivan A. Boldyrev, and Roman G. Efremov,  Liquid but Durable:</span>
<span class="sd">                Molecular Dynamics Simulations Explain the Unique Properties of</span>
<span class="sd">                Archaeal-Like Membranes, Scientific Reports, 4:7462, 2014,</span>
<span class="sd">                doi:10.1038/srep07462</span>
<span class="sd">                (https://www.nature.com/articles/srep07462)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Estimate of lipid-lipid collinearity.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;lipid_collinearity&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;first&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;angle&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices_1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices_2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

<div class="viewcode-block" id="LipidCollinearityProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.LipidCollinearityProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;leaflet: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">leaflet</span><span class="p">))</span>
            <span class="n">group_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span>
            <span class="n">group_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span>
            <span class="n">lipid_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nlipids</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">leaflet_name</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet_name</span><span class="p">]</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="n">nlipids</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lipid_types</span><span class="p">:</span>
                        <span class="n">lipid_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lipid_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">indices_1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">indices_2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices_1</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_1</span><span class="p">)</span>
                    <span class="n">indices_2</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices_1</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_1</span><span class="p">)</span>
                <span class="n">indices_2</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices_1</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_1</span><span class="p">)</span>
                <span class="n">indices_2</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># unknown option--use default &quot;both&quot;</span>
                <span class="nb">print</span> <span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">leaflet</span>
                <span class="nb">print</span> <span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">]:</span>
                    <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflets</span><span class="p">]</span>
                    <span class="n">indices_1</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_1</span><span class="p">)</span>
                    <span class="n">indices_2</span> <span class="o">+=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group_2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices_1</span> <span class="o">=</span> <span class="n">indices_1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices_2</span> <span class="o">=</span> <span class="n">indices_2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">indices_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_1</span>
        <span class="n">indices_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_2</span>
        <span class="n">n_com_1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_1</span><span class="p">)</span>
        <span class="n">n_com_2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_2</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;resname_2&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com_1</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">indices_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vec_i</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidvec</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>
                <span class="n">vec_i_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="n">vec_i</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_com_1</span><span class="p">):</span>
                    <span class="n">jj</span> <span class="o">=</span> <span class="n">indices_1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">vec_j</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidvec</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>
                    <span class="n">vec_j_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_j</span><span class="p">,</span> <span class="n">vec_j</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span>
                        <span class="n">angle_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="n">vec_j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vec_i_l</span><span class="o">*</span><span class="n">vec_j_l</span><span class="p">))</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle_rad</span><span class="o">*</span><span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;order&#39;</span><span class="p">:</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="n">vec_j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vec_i_l</span><span class="o">*</span><span class="n">vec_j_l</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com_1</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">indices_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vec_i</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidvec</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>
                <span class="n">vec_i_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="n">vec_i</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_com_2</span><span class="p">):</span>
                    <span class="n">jj</span> <span class="o">=</span> <span class="n">indices_2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">vec_j</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lipidvec</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span>
                    <span class="n">vec_j_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_j</span><span class="p">,</span> <span class="n">vec_j</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span>
                        <span class="n">angle_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="n">vec_j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vec_i_l</span><span class="o">*</span><span class="n">vec_j_l</span><span class="p">))</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle_rad</span><span class="o">*</span><span class="mf">180.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;order&#39;</span><span class="p">:</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_i</span><span class="p">,</span> <span class="n">vec_j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">vec_i_l</span><span class="o">*</span><span class="n">vec_j_l</span><span class="p">))</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="c1"># get the current com frame list</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;vector_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
        <span class="c1"># get the msd for the current selection</span>
        <span class="n">mean_value</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">lipid_collinearity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tc</span><span class="p">,</span> <span class="n">mean_value</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lipid_collinearity</span><span class="p">)</span>
        <span class="k">return</span></div></div>


<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;lipid_collinearity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LipidCollinearityProtocol</span>


<span class="c1"># define a new analysis &#39;msd&#39;</span>
<span class="n">valid_analysis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;halperin_nelson&#39;</span><span class="p">)</span>
<span class="n">analysis_obj_name_dict</span><span class="p">[</span><span class="s1">&#39;halperin_nelson&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;com_frame&#39;</span>


<div class="viewcode-block" id="HalperinNelsonProtocol"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.HalperinNelsonProtocol">[docs]</a><span class="k">class</span> <span class="nc">HalperinNelsonProtocol</span><span class="p">(</span><span class="n">AnalysisProtocol</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the mean Halperin and Nelson&#39;s rotational invariant.</span>

<span class="sd">        The HalperinNelsonProtocol is used to compute the mean Halperin and</span>
<span class="sd">        Nelson&#39;s rotational invariant. The value for lipid l is given by:</span>
<span class="sd">            phi_l = | (1/6) * sum_{j element nn(l)} exp(6i*theta_{lj}) |^2</span>
<span class="sd">        where i is complex and nn(l) are the 6 nearest neighbors of lipid</span>
<span class="sd">        l; theta_{lj} is the angle between the vector formed by beads</span>
<span class="sd">        representing lipid l and j and an arbitrary axis. The value is unity</span>
<span class="sd">        for perfect hexagonal packing, and it is zero to the extent that</span>
<span class="sd">        hexagonal packing is entirely absent. This protocol uses the &#39;com_frame&#39;</span>
<span class="sd">        representation of the bilayer.</span>

<span class="sd">        This protocol is identified by the analysis key: &#39;halperin_nelson&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            args (list): list of string keys and arguments</span>

<span class="sd">        Settings (parsed from args to settings dict):</span>
<span class="sd">            leaflet (str: &#39;upper&#39;, or &#39;lower&#39;): Specifies the bilayer</span>
<span class="sd">                leaflet to include in the estimate. Default: &#39;upper&#39;</span>

<span class="sd">        References:</span>
<span class="sd">            1. Shachi Katira, Kranthi K. Mandadapu, Suriyanarayanan</span>
<span class="sd">                Vaikuntanathan, Berend Smit, and David Chandler, The</span>
<span class="sd">                order-disorder transition in model lipid bilayers is a</span>
<span class="sd">                first-order hexatic to liquid phase transition, arXiv preprint</span>
<span class="sd">                [cond-mat.soft] 2015, arXiv:1506.04310.</span>
<span class="sd">                https://arxiv.org/pdf/1506.04310.pdf</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_short_description</span> <span class="o">=</span> <span class="s2">&quot;Halperin and Nelson&#39;s rotational invariant.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return_length</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_key</span> <span class="o">=</span> <span class="s1">&#39;halperin_nelson&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
        <span class="c1"># default function settings</span>
        <span class="c1"># adjustable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1">#self.leaflet = &#39;both&#39;</span>
        <span class="c1">#self.resname = &#39;all&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="c1"># parse input arguments if given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis_id</span> <span class="o">+</span> <span class="s2">&quot;.pickle&quot;</span>
        <span class="c1"># storage for output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_distance_euclidean_pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_a</span><span class="p">,</span> <span class="n">v_b</span><span class="p">,</span> <span class="n">box_lengths</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;box_half&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">basestring</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">center</span> <span class="o">==</span> <span class="s1">&#39;zero&#39;</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v_a</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">center</span> <span class="o">==</span> <span class="s1">&#39;box_half&#39;</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">box_lengths</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="c1">#shift center to zero for minimum image</span>
        <span class="n">v_a</span> <span class="o">=</span> <span class="n">v_a</span> <span class="o">-</span> <span class="n">center</span>
        <span class="n">v_b</span> <span class="o">=</span> <span class="n">v_b</span> <span class="o">-</span> <span class="n">center</span>
        <span class="c1">#difference</span>
        <span class="n">d_v</span> <span class="o">=</span> <span class="n">v_a</span> <span class="o">-</span> <span class="n">v_b</span>
        <span class="n">d_v_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">d_v</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_a</span><span class="p">)</span>
        <span class="c1">#check for minimum image</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">v_i</span> <span class="o">=</span> <span class="n">d_v_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">box_i</span> <span class="o">=</span> <span class="n">box_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">box_i_h</span> <span class="o">=</span> <span class="n">box_i</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="k">if</span> <span class="n">v_i</span> <span class="o">&gt;</span> <span class="n">box_i_h</span><span class="p">:</span>
                <span class="n">d_v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_i</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">v_a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">v_b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d_v</span><span class="p">,</span> <span class="n">d_v</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d_v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_6nn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">com_frame</span><span class="p">,</span> <span class="n">lateral</span><span class="p">):</span>
        <span class="n">k</span><span class="o">=</span><span class="mi">6</span>
        <span class="c1">#initialize knn dict</span>
        <span class="n">knn</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">}</span>
        <span class="c1">#make sure X has the right shape for the cdist function</span>
        <span class="n">nX</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">[[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>\
         <span class="bp">self</span><span class="o">.</span><span class="n">_distance_euclidean_pbc</span><span class="p">(</span><span class="n">com_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">lateral</span><span class="p">],</span>\
         <span class="n">com_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">lateral</span><span class="p">],</span> <span class="n">com_frame</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">lateral</span><span class="p">],</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;box_half&#39;</span><span class="p">)]</span> \
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nX</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nX</span><span class="p">)]</span>
        <span class="c1">#sort distances</span>
        <span class="n">distances</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1">#pick up the k nearest</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">knn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">knn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">j</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="o">-</span><span class="n">vec</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">knn</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">knn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">vec</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">knn</span>

<div class="viewcode-block" id="HalperinNelsonProtocol.run_analysis"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.HalperinNelsonProtocol.run_analysis">[docs]</a>    <span class="k">def</span> <span class="nf">run_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ba_settings</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">,</span> <span class="n">ba_mda_data</span><span class="p">):</span>
        <span class="n">leaflet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;leaflet&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>
            <span class="c1">#determine the frame intervals</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># parse the leaflet and group inputs</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="n">leaflet</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;leaflets&#39;</span><span class="p">][</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">indices</span>
            <span class="c1">#self.analysis_output.append([])</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="c1"># initialize a running stats object to do the averaging over resids</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_6nn</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">],</span>
                                    <span class="n">ba_settings</span><span class="p">[</span><span class="s1">&#39;lateral&#39;</span><span class="p">])</span>
        <span class="n">hn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">nn</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">nn_curr</span> <span class="o">=</span> <span class="n">nn</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">nn_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nn_curr</span><span class="p">:</span>
                <span class="n">n_ind</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">vec_l</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_axis</span><span class="p">)</span><span class="o">/</span><span class="n">vec_l</span>
                <span class="n">nn_sum</span><span class="o">+=</span><span class="n">cmath</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">6</span><span class="n">j</span><span class="o">*</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">hn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">nn_sum</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1">#for val in hn:</span>
        <span class="c1">#    print(&quot;hn: {}&quot;.format(val))</span>
        <span class="n">hn_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hn</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ba_reps</span><span class="p">[</span><span class="s1">&#39;com_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">hn_mean</span><span class="p">])</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="HalperinNelsonProtocol.reset"><a class="viewcode-back" href="../../../pybilt.bilayer_analyzer.html#pybilt.bilayer_analyzer.analysis_protocols.HalperinNelsonProtocol.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_frame</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span></div></div>

<span class="c1"># update the command_protocols dictionary</span>
<span class="n">command_protocols</span><span class="p">[</span><span class="s1">&#39;halperin_nelson&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HalperinNelsonProtocol</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Blake A. Wilson.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>