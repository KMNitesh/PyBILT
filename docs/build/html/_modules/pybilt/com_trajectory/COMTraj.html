

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pybilt.com_trajectory.COMTraj &mdash; PyBILT 0.1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> PyBILT
          

          
            
            <img src="../../../_static/PyBILT_logo_b.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html"><em>Py</em>thon based lipid <em>BIL</em>ayer molecular simulation analysis <em>T</em>oolkit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#install">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#quick-overview-of-pybilt">Quick overview of PyBILT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#additional-documentation-tutorials">Additional Documentation/Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#contact">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#contributing">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#license">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#acknowledgments">Acknowledgments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#built-with">Built With</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html#core-developers">Core Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ba_analyses.html">Analyses available to the BilayerAnalyzer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">pybilt</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PyBILT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pybilt.com_trajectory.COMTraj</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pybilt.com_trajectory.COMTraj</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Center of Mass based bilayer analysis tools</span>

<span class="sd">This module defines various classes and functions used to process and analyze a lipid</span>
<span class="sd">bilayer trajectory. This module assumes the structure and trajectory are initiallaly stored in MDAnalysis</span>
<span class="sd">objects and therefore processes MDAnalysis objects. The lipids constituting the bilayer are read in from</span>
<span class="sd">the MDAnalysis objects and are converted to center of mass (COM) representations. Lipids are partitioned</span>
<span class="sd">into an &#39;upper&#39; and a &#39;lower&#39; leaflet based on the z-position of the COM. The built-in analysis functions</span>
<span class="sd">then operate on the COM representations to compute quantities such as the lateral mean squared displacement.</span>
<span class="sd">Many analysis functions allow specification of the leaflet and type of lipid to perform the the analysis on.</span>
<span class="sd">The primary (parent class) is the MemSys class. The analysis functions are members of the MemSys class.</span>

<span class="sd">Example:</span>
<span class="sd">    &gt;&gt; import MemSys as ms</span>
<span class="sd">    &gt;&gt; mem_sys = ms.MemSys(mda_universe.trajectory,mda_selection_of_bilayer_lipids)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#imports</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">object</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">shelve</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">Voronoi</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">Delaunay</span>
<span class="c1">#import copy</span>

<span class="c1">#import running stats class</span>
<span class="kn">from</span> <span class="nn">pybilt.common.running_stats</span> <span class="k">import</span> <span class="o">*</span>
<span class="c1"># import the coordinate wrapping function--for unwrapping</span>
<span class="kn">from</span> <span class="nn">pybilt.mda_tools.mda_unwrap</span> <span class="k">import</span> <span class="n">wrap_coordinates</span><span class="p">,</span><span class="n">wrap_coordinates_parallel</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">range</span>


<span class="c1"># This function is incomplete!</span>
<div class="viewcode-block" id="colorize_step_vector_clusters"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.colorize_step_vector_clusters">[docs]</a><span class="k">def</span> <span class="nf">colorize_step_vector_clusters</span><span class="p">(</span><span class="n">vectors</span><span class="p">):</span>
    <span class="c1">#nvecs = len(vectors)</span>
    <span class="c1">#np.zeros(nvecs,dtype=np.int)</span>
    <span class="c1">#colors_out = np.zeros(nvecs)</span>
    <span class="c1">#return &quot;nothing yet!&quot;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="LipidCOM"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.LipidCOM">[docs]</a><span class="k">class</span> <span class="nc">LipidCOM</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A lipid center of mass (COM) object.</span>

<span class="sd">    This object stores the COM coordinates of a lipid (or other molecule or group</span>
<span class="sd">    of atoms) computed from both the wrapped and unwrapped atomic coordinates. This</span>
<span class="sd">    object also stores information about the type of lipid as well as the total mass</span>
<span class="sd">    of the lipid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;LipidCOM initialization</span>

<span class="sd">        Attributes:</span>
<span class="sd">            type (str): The lipid type (e.g. the lipid could be typed b resname).</span>
<span class="sd">            com (np.array): The length three vector holding the wrapped xyz coordinates.</span>
<span class="sd">            com_unwrap (np.array): The length three vector holding the unwrapped xyz coordinates.</span>
<span class="sd">            mass (float): The total mass of the atoms used to define LipidCOM.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># lipid type/resname or other name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">=</span><span class="s2">&quot;UNK&quot;</span>
        <span class="c1"># wrapped coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">com</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># unwrapped coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">com_unwrap</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># total mass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="o">=</span><span class="mf">1.0</span>
        <span class="k">return</span>
    <span class="c1"># The name of this function could be changed to be more desriptive, e.g.</span>
    <span class="c1"># extract_com_mda_residue</span>
<div class="viewcode-block" id="LipidCOM.extract"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.LipidCOM.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mda_residue</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the center of mass coordinates from an MDAnalysis residue</span>

<span class="sd">        This function calls the MDAnalysis member function center_of_mass() of the residue</span>
<span class="sd">        to compute the center of mass of the atoms constituting the residue.</span>

<span class="sd">        Args:</span>
<span class="sd">            mda_residue (MDAnalysis.residue): An MDAnalysis residue object from which to extract</span>
<span class="sd">                a center of masss coordinates.</span>
<span class="sd">            unwrap (bool, optional): Define which com container to store coordiates in.</span>
<span class="sd">                False (default) - The COM coordinates are stored in the</span>
<span class="sd">                container designated for the wrapped coordinate representation.</span>
<span class="sd">                True - The COM coordinates are stored in the container designated</span>
<span class="sd">                for the unwrapped coordinate representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">mda_residue</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">if</span> <span class="n">unwrap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">com_unwrap</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">box</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">com</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">com_unwrap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">com</span><span class="p">[:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">com</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">com_unwrap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">com</span><span class="p">[:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">=</span><span class="n">mda_residue</span><span class="o">.</span><span class="n">resname</span>
        <span class="k">return</span></div></div>

<span class="c1"># a frame object</span>
<div class="viewcode-block" id="Frame"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.Frame">[docs]</a><span class="k">class</span> <span class="nc">Frame</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A molecular dynamics style Frame object. &quot;&quot;&quot;</span>

    <span class="c1"># does not check that nlipids is an int</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nlipids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Frame initialization.</span>

<span class="sd">        Args:</span>
<span class="sd">            nlipids (int): The number of lipids (LipidCOM objects) that this frame will hold</span>

<span class="sd">        Atrributes:</span>
<span class="sd">            lipidcom (list of obj:LipidCOM): A list of the LipidCOM objects assigned to the Frame.</span>
<span class="sd">            box (np.array): A 3 element vector containing the (rectangular) xyz box edge lengths.</span>
<span class="sd">            time (float): The simulation time that this Frame represents.</span>
<span class="sd">            number (int): The frame number of this Frame.</span>
<span class="sd">            mdnumber (int): The corresponding frame number in the original MD trajectory</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># list to store the nlipids LipidCOM objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lipidcom</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># box dimensions -- assumes the box originates a 0,0,0</span>
        <span class="c1"># It might be worth adding functionality to specifiy the box origin (or center)</span>
        <span class="c1"># This also assumes a rectangular box</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># simulation time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># frame number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="c1"># frame number in the MD trajectory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mdnumber</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="c1"># initialize all the LipidCOM objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lipidcom</span> <span class="o">=</span> <span class="p">[</span><span class="n">LipidCOM</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlipids</span><span class="p">)]</span>

        <span class="k">return</span>

<div class="viewcode-block" id="Frame.set_box"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.Frame.set_box">[docs]</a>    <span class="k">def</span> <span class="nf">set_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box_lengths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the rectangular xyz box edge lengths.</span>

<span class="sd">        Args:</span>
<span class="sd">            box_lengths (numpy.array): A 1d, 3 element numpy.array containing the x,y,z box sizes (or edge lengths)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box</span> <span class="o">=</span> <span class="n">box_lengths</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Frame.set_time"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.Frame.set_time">[docs]</a>    <span class="k">def</span> <span class="nf">set_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the simulation time.</span>

<span class="sd">        Args:</span>
<span class="sd">            time (float): The simulation time to assign to this Frame.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the number of LipidCOM objects assigned to this Frame</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Number of LipidCOM objects currently assigned to this Frame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">)</span>

<span class="c1">#    def COG(self,unwrapped=False):</span>
<span class="c1">#        cog_out = np.zeros(3)</span>
<span class="c1">#        for lipid in self.lipidcom:</span>
<span class="c1">#            if not unwrapped:</span>
<span class="c1">#                cog_out+=lipid.com</span>
<span class="c1">#            else:</span>
<span class="c1">#                cog_out+=lipid.com_unwrap</span>
<span class="c1">#        cog_out/=len(self)</span>
<span class="c1">#        return com_out</span>

<div class="viewcode-block" id="Frame.com"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.Frame.com">[docs]</a>    <span class="k">def</span> <span class="nf">com</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the center of mass (COM) for the Frame</span>

<span class="sd">        This member function is used to compute the overall center of mass (COM) of the</span>
<span class="sd">        Frame using the LipidCOM object coordinates and masses.</span>

<span class="sd">        Args:</span>
<span class="sd">            wrapped (bool, optional): Define which set of coordinates to use in the computation.</span>
<span class="sd">                True (default) - The wrapped LipidCOM coordinates are used to compute</span>
<span class="sd">                the COM of the frame.</span>
<span class="sd">                False - The unwrapped LipidCOM coordinates are used to compute</span>
<span class="sd">                the COM of the frame.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.array: A 3 element vector containing the xyz coordinates of the Frame&#39;s COM</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">com_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">total_mass</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">lipid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wrapped</span><span class="p">:</span>
                <span class="n">com_out</span><span class="o">+=</span><span class="n">lipid</span><span class="o">.</span><span class="n">com</span><span class="o">*</span><span class="n">lipid</span><span class="o">.</span><span class="n">mass</span>
                <span class="n">total_mass</span><span class="o">+=</span><span class="n">lipid</span><span class="o">.</span><span class="n">mass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">com_out</span><span class="o">+=</span><span class="n">lipid</span><span class="o">.</span><span class="n">com_unwrap</span><span class="o">*</span><span class="n">lipid</span><span class="o">.</span><span class="n">mass</span>
                <span class="n">total_mass</span><span class="o">+=</span><span class="n">lipid</span><span class="o">.</span><span class="n">mass</span>
        <span class="n">com_out</span><span class="o">/=</span><span class="n">total_mass</span>
        <span class="k">return</span> <span class="n">com_out</span></div>

<div class="viewcode-block" id="Frame.write_xyz"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.Frame.write_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">write_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz_name</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># Open up the file to write to</span>
        <span class="n">xyz_out</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">xyz_name</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>

        <span class="n">comment</span> <span class="o">=</span> <span class="s2">&quot;Memsys Frame &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; MD Frame &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdnumber</span><span class="p">)</span>
        <span class="n">xyz_out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">)))</span>
        <span class="n">xyz_out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">xyz_out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
        <span class="n">xyz_out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">)):</span>
            <span class="c1">#get the coordinates</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">wrapped</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#z = self.lipidcom[i].com_unwrap[2]</span>

            <span class="c1">#get the lipid resname</span>
            <span class="n">oname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>

            <span class="c1">#write to file</span>
            <span class="n">line</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">oname</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">xyz_out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">xyz_out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>

        <span class="n">xyz_out</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span></div></div>



<span class="c1">#frame wrapper - the name of this class may be changed. e.g. FrameShelve</span>
<div class="viewcode-block" id="FrameShelve"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.FrameShelve">[docs]</a><span class="k">class</span> <span class="nc">FrameShelve</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Container for Frame objects</span>
<span class="sd">    This class object serves as a container to store a set of Frame objects</span>
<span class="sd">    corresponding to a molecular dynamics trajectory. This class saves the Frame objects</span>
<span class="sd">    on disk using the shelve module and provides an interface to access instances of</span>
<span class="sd">    those saved Frames. The Frames are saved in the shelve database with integer index keys</span>
<span class="sd">    0 -&gt; (nframes-1) and can accessed by indexing the instance of the frames object.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#define a non-instance type error message</span>
    <span class="n">_type_error</span> <span class="o">=</span><span class="s2">&quot;Instance of object MemSys.FrameShelve only excepts instances of MemSys.Frame.&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;/tmp/&#39;</span><span class="p">,</span><span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialization of the frames object.</span>

<span class="sd">        Args:</span>
<span class="sd">            prefix (str, optional): The location/path to store the &quot;shelve&quot;d Frame data.</span>
<span class="sd">                &#39;/tmp/&#39; (default) - The data is stored in the unix/linux tmp directory.</span>
<span class="sd">            save (bool, optional): Set whether to save the shelved Frame data after frames object deletion.</span>
<span class="sd">                False (default) - the shelved Frame data is deleted upon calling __del__</span>
<span class="sd">                True  - the shelved Frame data is not deleted when __del__ is called</span>

<span class="sd">        Attributes:</span>
<span class="sd">            nframes (int): The number Frame objects being stored.</span>
<span class="sd">            pid (int): The process id that the frames object is created in.</span>
<span class="sd">            path (str): The path to where the shelved Frame data is stored.</span>
<span class="sd">            save (bool): Set whether to save the shelved Frame data after frames object deletion.</span>
<span class="sd">            fs_name (str): The base name of the shelve database file used to store Frame objects.</span>
<span class="sd">            frame_shelf (shelve.Shelf): The Shelf that will hold the Frame objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>

        <span class="k">if</span>    <span class="n">prefix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span><span class="s1">&#39;/&#39;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="k">if</span>    <span class="n">save</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="s1">&#39;mem_sys_frames&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">+</span><span class="s1">&#39;.mem_sys_frames_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save</span> <span class="o">=</span> <span class="n">save</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="mo">0o755</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">+</span><span class="s1">&#39;/shelf_frames.db&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_shelf</span> <span class="o">=</span> <span class="n">shelve</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_name</span><span class="p">,</span><span class="n">flag</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Non-standard implementation for the __del__ built-in for frames.</span>

<span class="sd">        Closes the Frame shelve database file and deletes the shelved Frame</span>
<span class="sd">        data if the frames.save parameter is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_shelf</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">):</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="FrameShelve.append"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.FrameShelve.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Append a Frame.</span>

<span class="sd">        The new Frame is added to the shelve database with a key &#39;self.nframes&#39;,</span>
<span class="sd">        which is then incremented (self.nframe+=1).</span>

<span class="sd">        Args:</span>
<span class="sd">            item (obj:Frame): The instance of a Frame object to be appended.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If item is not an instance of Frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Frame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame_shelf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">)]</span> <span class="o">=</span> <span class="n">item</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame_shelf</span><span class="o">.</span><span class="n">sync</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_error</span><span class="p">)</span>
        <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get a copy of Frame from the database at key</span>

<span class="sd">        The frames object is indexed with an integer key.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (int): The index of the Frame object being called.</span>

<span class="sd">        Returns:</span>

<span class="sd">        obj:Frame : This is an instance of the Frame object stored at index key (pulled from the Shelf database).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span>
        <span class="k">while</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_shelf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the Frame at key in the Shelf database</span>

<span class="sd">        Args:</span>
<span class="sd">            key (int): The index where the input Frame should be stored.</span>
<span class="sd">            item (obj:Frame): This is an instance of a Frame object to be stored at index key.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError : If the input item is not an instance of the Frame object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Frame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_error</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="o">+=</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_shelf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span><span class="o">=</span><span class="n">item</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_shelf</span><span class="o">.</span><span class="n">sync</span><span class="p">()</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the number of Frame objects being stored.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The number of Frame objects this instance of frames.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Use += operator to append Frame objects</span>
<span class="sd">        Appends by calling the append() function.</span>
<span class="sd">        Args:</span>
<span class="sd">            item (obj:Frame): An instance of Frame to be appended.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<span class="c1"># the multiprocessor parallelized functions that get copies of this object</span>
<span class="c1"># still return:</span>
<span class="c1">#    Exception OSError: OSError(2, &#39;No such file or directory&#39;) in  ignored</span>
<span class="c1"># I&#39;m not sure why, but it is marked as ignored and it doesn&#39;t seem to cause any problems with the Frame shelve</span>
<span class="c1"># database file.</span>
<div class="viewcode-block" id="ParFrames"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.ParFrames">[docs]</a><span class="k">class</span> <span class="nc">ParFrames</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Read-Only version of frames object</span>
<span class="sd">    This class is effectively used to generate read-only copies of the frames class, which can be passed</span>
<span class="sd">    to functions that do parallelized computations over the number of frames.  Unlike frames ParFrames</span>
<span class="sd">    does not create a new Shelf database. It must be passed an existing Shelf of Frame objects. ParFrames</span>
<span class="sd">    also does not have any functions defined to modify the Shelf (add/remove Frame objects). This is to</span>
<span class="sd">    avoid conflicts from multiple processor accesses to the Shelf database.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># fs_name does not actually get used, so it should probably be removed.</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nframes</span><span class="p">,</span> <span class="n">fs_name</span><span class="p">,</span> <span class="n">frame_shelve</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialize the ParFrames object</span>

<span class="sd">        Args:</span>
<span class="sd">        nframes (int): The number of Frames stored in the shelve database.</span>
<span class="sd">        fs_name (string): The base name (prefix) of the shelve database files.</span>
<span class="sd">        frame_shelve (shelve.Shelf): The Shelf object containing the Frame objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span> <span class="o">=</span> <span class="n">nframes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs_name</span> <span class="o">=</span> <span class="n">fs_name</span>
        <span class="c1">#print &quot;ParFrames instance&quot;</span>
        <span class="c1">#print &quot;self.nframes &quot;,self.nframes</span>
        <span class="c1">#print &quot;self.fs_name &quot;,self.fs_name</span>
        <span class="c1">#self.frame_shelf = shelve.open(self.fs_name,flag=&quot;r&quot;, protocol=2)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_shelf</span> <span class="o">=</span> <span class="n">frame_shelve</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get a copy of the Frame object stored at key.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (int): The index of the Frame object being called.</span>

<span class="sd">        Returns:</span>

<span class="sd">        obj:Frame : This is an instance of the Frame object stored at index key (pulled from the shelve database)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span>
        <span class="k">while</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_shelf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the number of Frame objects being stored.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The number of Frame objects this instance of frames.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span></div>


<span class="c1"># leaflet object</span>
<div class="viewcode-block" id="Leaflet"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.Leaflet">[docs]</a><span class="k">class</span> <span class="nc">Leaflet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create a bilayer Leaflet representation.</span>
<span class="sd">    This class object is used to group lipids together according to their bilayer leaflet. It is primarily meant to</span>
<span class="sd">    store the indices of LipidCOMs as they are in a Frame.lipidcom list. This class also</span>
<span class="sd">    creates sub-groups within the Leaflet based on the LipidCOM.type using LipidGroup objects. Instances of Leaflet</span>
<span class="sd">    are created by the MemSys class.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes an instance of a Leaflet object.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): The name of the bilayer leaflet being initialized (&#39;upper&#39; and &#39;lower&#39; are used by the MemSys class).</span>

<span class="sd">        Attributes:</span>
<span class="sd">            name (str): The name of the Leaflet (e.g. &#39;upper&#39; or &#39;lower&#39;).</span>
<span class="sd">            members (list of int): A list containing the integer indices associated with the LipidCOM objects within</span>
<span class="sd">                a Frame that are assigned to the Leaflet instance.</span>
<span class="sd">            groups (list of obj:LipidGroup): A list of the LipidGroup objects (uniquely named) that are created by the Leaflet instance</span>
<span class="sd">                as new members are added.</span>
<span class="sd">            group_dict (dict): A dictionary keyed according to the names of the LipidGroup objects created, which stores the</span>
<span class="sd">                corresponding index of that LipidGroup in self.groups.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#the name of the leaflet - e.g. &#39;upper&#39; or &#39;lower&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="c1">#initialize a list to store the indices of lipids assigned to this leaflet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">members</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#initialize a list to hold the LipidGroup objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#initialize a dictionary to store the self.groups index of LipidGroup objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> leaflet of a Center of mass trajectory with </span><span class="si">%s</span><span class="s1"> members and </span><span class="si">%s</span><span class="s1"> lipid groups&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> leaflet of a Center of mass trajectory with </span><span class="si">%s</span><span class="s1"> members and </span><span class="si">%s</span><span class="s1"> lipid groups&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Have len(Leaflet) return the number of lipids that have been added to the Leaflet instance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Number of lipids in the Leaflet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">)</span>

    <span class="c1">#consider changing var name of input &#39;resname&#39; to something that doesn&#39;t conflict with LipidCOM.type</span>
<div class="viewcode-block" id="Leaflet.add_member"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.Leaflet.add_member">[docs]</a>    <span class="k">def</span> <span class="nf">add_member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">resname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add new lipids to the Leaflet.</span>

<span class="sd">        This function is meant to be used to add new lipids according to their Frame.lipidcom index</span>
<span class="sd">        to the Leaflet and to a LipidGroup according resname/type/name.</span>
<span class="sd">        Args:</span>
<span class="sd">            index (int): The index of the lipid being added to the Leaflet.</span>
<span class="sd">            resname (str): The resname (or LipidCOM.type) of the lipid being added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">index</span><span class="p">,</span> <span class="n">resname</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LipidGroup</span><span class="p">(</span><span class="n">resname</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add_member</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">group_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">resname</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">index</span><span class="p">,</span> <span class="n">resname</span><span class="p">])</span>
            <span class="n">addgroup</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">group_ind</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">rn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">resname</span> <span class="o">==</span> <span class="n">rn</span><span class="o">.</span><span class="n">lg_name</span><span class="p">:</span>
                    <span class="n">addgroup</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
                <span class="n">group_ind</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">addgroup</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LipidGroup</span><span class="p">(</span><span class="n">resname</span><span class="p">))</span>
                <span class="n">ng</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">ng</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add_member</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">group_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">resname</span><span class="p">:</span> <span class="n">ng</span><span class="o">-</span><span class="mi">1</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">group_ind</span><span class="p">]</span><span class="o">.</span><span class="n">add_member</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

            <span class="c1">#self.members=sorted(self.members,key=lambda self.members:self.members[1])</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Leaflet.get_group_indices"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.Leaflet.get_group_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_group_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the indices of lipids in the Leaflet belonging to a specific LipidGroup.</span>

<span class="sd">        Args:</span>
<span class="sd">        group_name (string): The name of the LipidGroup pull LipidCOM indices from.</span>
<span class="sd">            Passing the string &#39;all&#39; will return indices of all the lipids assigned to</span>
<span class="sd">            the Leaflet instance. If the group_name is not recognised (i.e. is not in the group_dict)</span>
<span class="sd">            The function defaults to &#39;all&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of int: A list containing the integer indices of lipids in the Leaflet that</span>
<span class="sd">                belong to the specified LipidGroup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">group_name</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_dict</span><span class="p">:</span>
                <span class="n">gindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">gindex</span><span class="p">]</span><span class="o">.</span><span class="n">lg_members</span>
        <span class="k">elif</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_dict</span><span class="p">:</span>
            <span class="n">gindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_dict</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">gindex</span><span class="p">]</span><span class="o">.</span><span class="n">lg_members</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#unkwown group name- print warning and use the default &quot;all&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown Lipid Group </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">group_name</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> from the &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="s2">&quot; leaflet&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! using the default </span><span class="se">\&quot;</span><span class="s2">all</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_dict</span><span class="p">:</span>
                <span class="n">gindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">gindex</span><span class="p">]</span><span class="o">.</span><span class="n">lg_members</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span></div>

<div class="viewcode-block" id="Leaflet.get_member_indices"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.Leaflet.get_member_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_member_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the indices of all lipids (LipidCOM) in the Leaflet.</span>
<span class="sd">        This member function Returns: the list of indices for the lipids grouped in the Leaflet instance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of int: A list of integer indices of the lipids associated with the Leaflet instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span></div>

<div class="viewcode-block" id="Leaflet.has_group"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.Leaflet.has_group">[docs]</a>    <span class="k">def</span> <span class="nf">has_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check if there is a LipidGroup with the specified name.</span>

<span class="sd">        Args:</span>
<span class="sd">            group_name (str): The name to checked against the names of existing LipidGroup objects.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if there is a LipidGroup with name group_name, and False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="Leaflet.num_groups"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.Leaflet.num_groups">[docs]</a>    <span class="k">def</span> <span class="nf">num_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the number of LipidGroups in the Leaflet.</span>

<span class="sd">        Returns:</span>
<span class="sd">        int: The number of unique LipidGroups.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span></div>

<div class="viewcode-block" id="Leaflet.get_group_names"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.Leaflet.get_group_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_group_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the names of all the LipidGroup objects in the Leaflet</span>

<span class="sd">        Returns:</span>
<span class="sd">        list of str: A list of the names of current LipidGroup objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">group</span><span class="o">.</span><span class="n">lg_name</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="LipidGroup"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.LipidGroup">[docs]</a><span class="k">class</span> <span class="nc">LipidGroup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Object to group lipid indices by type/resname/name.</span>
<span class="sd">        Instances of this object are created by the Leaflet class.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initializes LipidGroup object.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): The name/type/resname of the lipids being grouped in this object.</span>

<span class="sd">        Attributes:</span>
<span class="sd">            lg_members (list of int): A list to hold the indices of lipids added to this</span>
<span class="sd">                this LipidGroup.</span>
<span class="sd">            lg_name (str): The name/type/resname of the lipids being grouped in this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#initialize a list to hold the member indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lg_members</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># the name of this lipid group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lg_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span>

<div class="viewcode-block" id="LipidGroup.add_member"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.LipidGroup.add_member">[docs]</a>    <span class="k">def</span> <span class="nf">add_member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_mem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add lipid index to to the LipidGroup.</span>

<span class="sd">         Args:</span>
<span class="sd">            new_mem (int): The index of the lipid being added to this LipidGroup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lg_members</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_mem</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="LipidGroup.name"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.LipidGroup.name">[docs]</a>    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the name associated with this LipidGroup.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The name of the lipid group (i.e. lg_name)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lg_name</span></div></div>

<div class="viewcode-block" id="msd_frames"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.msd_frames">[docs]</a><span class="k">def</span> <span class="nf">msd_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">fstart</span><span class="p">,</span> <span class="n">fend</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">refframe</span><span class="p">,</span> <span class="n">plane</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute the mean squared displacement for range of Frame objects in frames.</span>

<span class="sd">    This function allows the mean squared displacement (MSD) to be computed</span>
<span class="sd">    for a specified subset of the Frame objects in a frames (or ParFrames) object.</span>
<span class="sd">    This function was created to be called from the function MemSys.CalcMSD_parallel</span>
<span class="sd">    as a function to be passed to the multiprocessor threads.</span>

<span class="sd">    Args:</span>
<span class="sd">        frames (obj:frames or obj:ParFrames): The object containing all the Frames of the trajectory.</span>
<span class="sd">        fstart (int): The index of the first frame to start the analysis on.</span>
<span class="sd">        fend (int): The index of the last frame to analyze.</span>
<span class="sd">        indices (list of int): List of integer indices of the LipidCOMs to include in the computation.</span>
<span class="sd">        refframe (int): The index of the frame that is to be taken as the reference for the MSD computation.</span>
<span class="sd">        plane (list of int): The list of the indices corresponding to the coordinate planes (x: 0,y 1,z :2)</span>
<span class="sd">            to be included in the MSD computation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.array: This is a nx2 numpy array (of floats) containing the</span>
<span class="sd">            results of the MSD computation for the specified frames.</span>
<span class="sd">            msd_results[i,0] = simulation time for frame f = i + fstart.</span>
<span class="sd">            msd_results[i,1] = the configurational average MSD over the specified LipidCOMs for frame f = i + fstart.</span>
<span class="sd">            for i in range( (fend-fstart)+1 ).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#initialize an array to hold the ouptut</span>
    <span class="n">nfc</span> <span class="o">=</span> <span class="n">fend</span> <span class="o">-</span> <span class="n">fstart</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfc</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="c1"># number of lipids in the selection</span>
    <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="c1">#initialize a running stats object to do the configuration averaging</span>
    <span class="n">drs_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
    <span class="c1"># initialize an np array to hold coordinates for the selection</span>
    <span class="c1"># at the reference frame</span>
    <span class="n">com_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">ref_frame</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">refframe</span><span class="p">]</span>
    <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
    <span class="c1"># get the coordinates</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
        <span class="n">com_i</span> <span class="o">=</span> <span class="n">ref_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="n">plane</span><span class="p">]</span>
        <span class="n">com_ref</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">=</span><span class="n">com_i</span><span class="p">[:]</span>
        <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
    <span class="c1"># now begin loop over the frames for this process</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fstart</span><span class="p">,</span> <span class="p">(</span><span class="n">fend</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
        <span class="c1"># get the current frame</span>
        <span class="n">curr_frame</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
        <span class="c1"># get the coordinates for the selection at this frame</span>
        <span class="n">com_curr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">com_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="n">plane</span><span class="p">]</span>
            <span class="n">com_curr</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">=</span><span class="n">com_i</span><span class="p">[:]</span>
            <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
        <span class="c1">#current time</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">time</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">com_curr</span> <span class="o">-</span> <span class="n">com_ref</span>
        <span class="n">drs</span> <span class="o">=</span> <span class="n">dr</span><span class="o">*</span><span class="n">dr</span>
        <span class="c1">#loop over the selections for this frame</span>
        <span class="k">for</span>    <span class="n">val</span> <span class="ow">in</span> <span class="n">drs</span><span class="p">:</span>
            <span class="n">drs_curr</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:]</span>
            <span class="n">drs_mag</span> <span class="o">=</span> <span class="n">drs_curr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">drs_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">drs_mag</span><span class="p">)</span>
        <span class="c1">#get the msd for the current selection</span>
        <span class="n">msdcurr</span> <span class="o">=</span> <span class="n">drs_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="c1">#devcurr = drs_stat.deviation()</span>
        <span class="n">drs_stat</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="n">findex</span> <span class="o">=</span> <span class="n">f</span><span class="o">-</span><span class="n">fstart</span>
        <span class="n">output</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">tc</span>
        <span class="n">output</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">msdcurr</span>
<span class="c1">#        output[findex,2]=devcurr</span>
<span class="c1">#        dt = tc - time_ref</span>
<span class="c1">#        DiffCon = 0.0</span>
<span class="c1">#        if f != 0:</span>
<span class="c1">#            DiffCon = msdcurr/(4.0*dt)</span>
<span class="c1">#        output[findex,3]=DiffCon</span>
    <span class="c1">#    print &quot;msdcurr &quot;,msdcurr,&quot; DiffCon &quot;,DiffCon</span>
    <span class="k">return</span> <span class="n">output</span></div>

<span class="c1">#function to compute the thickness of the membrane (in the normal direction). The algorithm is based on</span>
<span class="c1"># the GridMAT-MD bilayer thickness calculation (except without the gridding procedure)</span>
<div class="viewcode-block" id="thickness_frames"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.thickness_frames">[docs]</a><span class="k">def</span> <span class="nf">thickness_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">fstart</span><span class="p">,</span> <span class="n">fend</span><span class="p">,</span> <span class="n">leaflets</span><span class="p">,</span> <span class="n">nlipids</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">norm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute the bilayer thickness for a range of Frame objects in frames.</span>
<span class="sd">    Computes the thickness of the bilayer (along the normal direction). The algorithm is based on</span>
<span class="sd">    the GridMAT-MD bilayer thickness calculation.</span>
<span class="sd">    This function was created to be called used in MemSys.CalcThickness_parallel</span>
<span class="sd">    as a function to be passed to the multiprocessor threads.</span>

<span class="sd">    Args:</span>
<span class="sd">        frames (obj:frames or obj:ParFrames): Object containing all the Frame objects of the trajectory.</span>
<span class="sd">        fstart (int): The index of the first frame to start the analysis on.</span>
<span class="sd">        fend (int): The index of the last frame to analyze.</span>
<span class="sd">        leaflets (dict of Leaflet): A dict containing the Leaflet instances used to define the upper and lower</span>
<span class="sd">            bilayer leaflets for this calculation. This dict should contain the two keys, &#39;upper&#39; and &#39;lower&#39;, corresponding</span>
<span class="sd">            to instances of the Leaflet class.</span>
<span class="sd">        nlipids (int): The total number of LipidCOMs (or lipids) in the two Leaflet instances.</span>
<span class="sd">        plane (list of int): A list of the integer indices corresponding to the bilayer lateral</span>
<span class="sd">            coordinate planes (0 for x,1 for y, and 2 for z)</span>
<span class="sd">        norm (int): The integer index corresponding to the bilayer normal coordinate plane</span>
<span class="sd">            (0 for x,1 for y, or 2 for z).</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple of numpy.array: This is a two element tuple containing numpy arrays of the computation results.</span>
<span class="sd">            tuple[0] =&gt; thickness: A nx3 numpy array containing the</span>
<span class="sd">            results of the thickness computation for the specified frames. Specifically:</span>
<span class="sd">                thickness[i,0] = simulation time for frame f = i + fstart.</span>
<span class="sd">                thickness[i,1] = the configurational average thickness for frame f = i + fstart.</span>
<span class="sd">                thickness[i,2] = the standard deviation of the configurational average thickness for frame f = i + fstart.</span>
<span class="sd">                For i in range( (fend-fstar) + 1).</span>
<span class="sd">            tuple[1] =&gt; thickness_map: A nxNx6 numpy array containing the thickness data that can be</span>
<span class="sd">            used to generate a 3d thickness map/plot. Specifically:</span>
<span class="sd">                thickness[i,j,0] = simulation time for frame f = i + fstart and lipid j.</span>
<span class="sd">                thickness[i,j,1] = the average x position for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                thickness[i,j,2] = the average y position for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                thickness[i,j,3] = the lower z position for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                thickness[i,j,4] = the upper z position for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                thickness[i,j,5] = the difference between the upper and lower z positions</span>
<span class="sd">                for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                For i in range((fend-fstar) + 1) and For j in range(nlipids).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#upper_match = []</span>
    <span class="c1">#lower_match = []</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">norm</span>
    <span class="n">comcup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">comclo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">dcom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">nfc</span> <span class="o">=</span> <span class="n">fend</span> <span class="o">-</span> <span class="n">fstart</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">nlc</span> <span class="o">=</span> <span class="n">nlipids</span>
    <span class="n">zdists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfc</span><span class="p">,</span> <span class="n">nlc</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">zmaps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfc</span><span class="p">,</span> <span class="n">nlc</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="c1">#dcoms = np.zeros(3)</span>
    <span class="n">f</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nfc</span><span class="p">)</span>

    <span class="k">for</span>    <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fstart</span><span class="p">,(</span><span class="n">fend</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
        <span class="n">n</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
        <span class="n">boxc</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">box</span>
        <span class="n">boxc_xh</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">boxc_yh</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">time</span>
        <span class="n">findex</span> <span class="o">=</span> <span class="n">f</span><span class="o">-</span><span class="n">fstart</span>
        <span class="n">times</span><span class="p">[</span><span class="n">findex</span><span class="p">]</span><span class="o">=</span><span class="n">dt</span>
        <span class="k">for</span> <span class="n">memu</span> <span class="ow">in</span> <span class="n">leaflets</span><span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
            <span class="n">idu</span> <span class="o">=</span> <span class="n">memu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">comcup</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">idu</span><span class="p">]</span><span class="o">.</span><span class="n">com</span>
            <span class="n">distxy</span> <span class="o">=</span> <span class="mf">10000.0</span>
            <span class="n">distz</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1">#mindex = 0</span>
            <span class="n">zlom</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">zhim</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">xavgm</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">yavgm</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">meml</span> <span class="ow">in</span> <span class="n">leaflets</span><span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
                <span class="n">idl</span> <span class="o">=</span> <span class="n">meml</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">comclo</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">idl</span><span class="p">]</span><span class="o">.</span><span class="n">com</span>
                <span class="n">dcom</span> <span class="o">=</span> <span class="n">comcup</span><span class="o">-</span><span class="n">comclo</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">dcom</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">dcom</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span>
                <span class="n">dz</span> <span class="o">=</span> <span class="n">dcom</span><span class="p">[</span><span class="n">zi</span><span class="p">]</span>
                <span class="c1">#Minimum image -- coordinates must be pre-wrapped</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">boxc_xh</span><span class="p">:</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comcup</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_xh</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comclo</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_xh</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">boxc_yh</span><span class="p">:</span>
                    <span class="n">dy</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comcup</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_yh</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comclo</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_yh</span><span class="p">)</span>
                <span class="n">rxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="c1">#get 4d map values</span>
                <span class="n">comavg</span> <span class="o">=</span> <span class="p">(</span><span class="n">comcup</span><span class="o">+</span><span class="n">comclo</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">xavg</span> <span class="o">=</span> <span class="n">comavg</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                <span class="n">yavg</span> <span class="o">=</span> <span class="n">comavg</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span>
                <span class="n">zlo</span> <span class="o">=</span> <span class="n">comclo</span><span class="p">[</span><span class="n">zi</span><span class="p">]</span>
                <span class="n">zhi</span> <span class="o">=</span> <span class="n">comcup</span><span class="p">[</span><span class="n">zi</span><span class="p">]</span>
                <span class="k">if</span>    <span class="n">rxy</span><span class="o">&lt;</span><span class="n">distxy</span><span class="p">:</span>
                    <span class="n">distxy</span><span class="o">=</span><span class="n">rxy</span>
                    <span class="n">distz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>
                    <span class="n">mindex</span><span class="o">=</span><span class="n">meml</span>
                    <span class="n">xavgm</span> <span class="o">=</span> <span class="n">xavg</span>
                    <span class="n">yavgm</span> <span class="o">=</span> <span class="n">yavg</span>
                    <span class="n">zlom</span> <span class="o">=</span> <span class="n">zlo</span>
                    <span class="n">zhim</span> <span class="o">=</span> <span class="n">zhi</span>

            <span class="c1">#upper_match.append([mindex,distz])</span>
            <span class="c1">#print &quot;n &quot;,n,&quot; xvg &quot;, xavgm,&quot; yvg &quot;, yavgm</span>

            <span class="n">zdists</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">distz</span>
            <span class="c1">#maps</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">dt</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">xavgm</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">yavgm</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">zlom</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="n">zhim</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="n">distz</span>

            <span class="n">n</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">meml</span> <span class="ow">in</span> <span class="n">leaflets</span><span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
            <span class="n">idl</span> <span class="o">=</span> <span class="n">meml</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">comclo</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">idl</span><span class="p">]</span><span class="o">.</span><span class="n">com</span>
            <span class="n">distxy</span> <span class="o">=</span> <span class="mf">10000.0</span>
            <span class="n">distz</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">mindex</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">zlom</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">zhim</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">xavgm</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">yavgm</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">memu</span> <span class="ow">in</span> <span class="n">leaflets</span><span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
                <span class="n">idu</span> <span class="o">=</span> <span class="n">memu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">comcup</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">idu</span><span class="p">]</span><span class="o">.</span><span class="n">com</span>
                <span class="n">dcom</span> <span class="o">=</span> <span class="n">comclo</span><span class="o">-</span><span class="n">comcup</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">dcom</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">dcom</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span>
                <span class="n">dz</span> <span class="o">=</span> <span class="n">dcom</span><span class="p">[</span><span class="n">zi</span><span class="p">]</span>
                <span class="c1">#Minimum image -- coordinates must be pre-wrapped</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">boxc_xh</span><span class="p">:</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comclo</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_xh</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comcup</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_xh</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">boxc_yh</span><span class="p">:</span>
                    <span class="n">dy</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comclo</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_yh</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comcup</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_yh</span><span class="p">)</span>
                <span class="n">rxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="c1">#get 4d map values</span>
                <span class="n">comavg</span> <span class="o">=</span> <span class="p">(</span><span class="n">comcup</span><span class="o">+</span><span class="n">comclo</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">xavg</span> <span class="o">=</span> <span class="n">comavg</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                <span class="n">yavg</span> <span class="o">=</span> <span class="n">comavg</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span>
                <span class="n">zlo</span> <span class="o">=</span> <span class="n">comclo</span><span class="p">[</span><span class="n">zi</span><span class="p">]</span>
                <span class="n">zhi</span> <span class="o">=</span> <span class="n">comcup</span><span class="p">[</span><span class="n">zi</span><span class="p">]</span>
                <span class="k">if</span>    <span class="n">rxy</span><span class="o">&lt;</span><span class="n">distxy</span><span class="p">:</span>
                    <span class="n">distxy</span><span class="o">=</span><span class="n">rxy</span>
                    <span class="n">distz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>
                    <span class="c1">#mindex=meml</span>
                    <span class="n">xavgm</span> <span class="o">=</span> <span class="n">xavg</span>
                    <span class="n">yavgm</span> <span class="o">=</span> <span class="n">yavg</span>
                    <span class="n">zlom</span> <span class="o">=</span> <span class="n">zlo</span>
                    <span class="n">zhim</span> <span class="o">=</span> <span class="n">zhi</span>
            <span class="c1">#upper_match.append([mindex,distz])</span>
            <span class="c1">#print &quot;n &quot;,n,&quot; xvg &quot;, xavgm,&quot; yvg &quot;, yavgm</span>
            <span class="n">zdists</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">distz</span>
            <span class="c1">#maps</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">dt</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">xavgm</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">yavgm</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">zlom</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="n">zhim</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">findex</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="n">distz</span>
            <span class="n">n</span><span class="o">+=</span><span class="mi">1</span>

        <span class="c1">#break</span>
    <span class="n">zavgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfc</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="c1">#zdtstat = RunningStats()</span>
    <span class="k">for</span> <span class="n">fr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfc</span><span class="p">):</span>
        <span class="n">currtime</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">fr</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">currtime</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">zdists</span><span class="p">[</span><span class="n">fr</span><span class="p">,:]</span>
        <span class="n">zavgcurr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">zdevcurr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
<span class="c1">#        zdtstat.push(zavgcurr)</span>
<span class="c1">#        zdtcurr = zdtstat.mean()</span>
<span class="c1">#        zdtdcurr = zdtstat.deviation()</span>
        <span class="n">zavgs</span><span class="p">[</span><span class="n">fr</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">dt</span>
        <span class="n">zavgs</span><span class="p">[</span><span class="n">fr</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">zavgcurr</span>
        <span class="n">zavgs</span><span class="p">[</span><span class="n">fr</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">zdevcurr</span>
<span class="c1">#        zavgs[fr,3]=zdtcurr</span>
<span class="c1">#        zavgs[fr,4]=zdtdcurr</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">zavgs</span><span class="p">,</span> <span class="n">zmaps</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span></div>
    <span class="c1">#return zavgs</span>
    <span class="c1">#return zmaps</span>


<span class="c1">## this is the main class - the Center of mass trajectory (MemSys) object</span>
<span class="c1"># The lipids are assumed to be separate residues, so the input selection (mem_sel)</span>
<span class="c1"># is split according to residues with each (full) residue assigned as a LipidCOM. However,</span>
<span class="c1"># it would nice to make it possible to something like a list of selections. That way</span>
<span class="c1"># you could for example use selections of the lipid headgroups as the LipidCOMs representation.</span>
<div class="viewcode-block" id="COMTraj"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj">[docs]</a><span class="k">class</span> <span class="nc">COMTraj</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This is the main class object.</span>
<span class="sd">    An instance of this class reads in the trajectory and a selection (both MDAnalysis objects)</span>
<span class="sd">    and creates/reduces the lipids to center of mass (COM) representations; i.e. a center of mass trajectory. There are several member</span>
<span class="sd">    functions to perform various types of analyses based on the COM representations.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pass the mda anaylis trajectory object and a selection with the membrane (i.e. w/o water and ions)</span>
    <span class="c1"># optional - specify the plane that the membrane is in - default is xy with normal in z</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mda_traj</span><span class="p">,</span> <span class="n">mem_sel</span><span class="p">,</span> <span class="n">plane</span><span class="o">=</span><span class="s2">&quot;xy&quot;</span><span class="p">,</span><span class="n">fstart</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fend</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">fskip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">frame_path</span><span class="o">=</span><span class="s1">&#39;Default&#39;</span><span class="p">,</span><span class="n">frame_save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">nprocs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; COMTraj initialization.</span>

<span class="sd">        Each lipid in the system is assumed to be its own residue. It is also assumed that the coordinates</span>
<span class="sd">        in the MDAnalysis trajectory are wrapped, so when this object is initialized it computes COMs using</span>
<span class="sd">        the wrapped coordinates. It then unwraps the raw coordinates and removes the system COM motion before</span>
<span class="sd">        recomputing another set of lipid COMs (now based on the unwrapped coordinates).</span>
<span class="sd">        Both representations are stored and are used in the various analyses.</span>


<span class="sd">        Args:</span>
<span class="sd">            mda_traj (MDAnalysi.Universe.trajectory): The MDAnalysis trajectory object containg the</span>
<span class="sd">                the molecular dynamics trajectory data for the system.</span>
<span class="sd">            mem_sel (MDAnalysis.AtomGroup): The MDAnalysis atom selection (AtomGroup) containing</span>
<span class="sd">                the bilayer lipids.</span>
<span class="sd">            plane (str, optional): Defines the lateral plane of the bilayer. The default is &#39;xy&#39;.</span>
<span class="sd">                The other options are &#39;yz&#39; or &#39;xz&#39;, or their equivalent &#39;zy&#39; or &#39;zx&#39;.</span>
<span class="sd">            fstart (int, optional): The index of the initial frame to use from the MDAnalysis trajectory.</span>
<span class="sd">                The default is 0.</span>
<span class="sd">            fstart (int, optional): The index of the final frame to use from the MDAnalysis trajectory.</span>
<span class="sd">                The default is -1 (i.e. the last frame).</span>
<span class="sd">            fskip (int, optional): Use every fskip frame in mda_traj.</span>
<span class="sd">                The default is 1 (i.e. use all frames in mda_traj).</span>
<span class="sd">            frame_path (str, optional): Path in which to store the Shelf database of the Frame objects</span>
<span class="sd">                created for the COM representations. The default is &#39;Default&#39; which uses the &#39;/tmp/&#39; dir.</span>
<span class="sd">            frame_save (bool, optional): Preserve the Shelf database files of Frame objects for this</span>
<span class="sd">                MemSys after deletion. The default is False (i.e. the Shelf database files are deleted).</span>
<span class="sd">                If True then the Shelf database files are not removed when this MemSys object is deleted.</span>
<span class="sd">            nprocs (int, optional): Define the number of processors to use when unwrapping the coordinates.</span>
<span class="sd">                The default is 1 (i.e. no paralellization). Greater than 1 uses a parallelized version</span>
<span class="sd">                of the unwrap function when uwrapping coordinates. nprocs should not exceed the</span>
<span class="sd">                the number of cores on your machine.</span>


<span class="sd">        Atrributes:</span>
<span class="sd">           plane (list of int): A two element list of the integer indices corresponding to the bilayer lateral</span>
<span class="sd">               coordinate planes (0 for x,1 for y, and 2 for z). Determined by the value of Args:plane.</span>
<span class="sd">           norm (int): The integer index corresponding to the bilayer normal coordinate plane</span>
<span class="sd">               (0 for x,1 for y, or 2 for z). Determined by the value of Args:plane.</span>
<span class="sd">           leaflets (dict of Leaflet): A dict containing the Leaflet instances used to define the upper and lower</span>
<span class="sd">               bilayer leaflets for this system. This dict will contain the two keys, &#39;upper&#39; and &#39;lower&#39;, upper</span>
<span class="sd">               and lower Leaflet objects respectively.</span>
<span class="sd">           com_leaflet (list of str): A list of leaflet name strings that maps the lipid index</span>
<span class="sd">               to the Leaflet (&#39;upper&#39; or &#39;lower&#39;) it has been assigned to.</span>
<span class="sd">               E.g.</span>
<span class="sd">               &gt;&gt;&gt; com_leaf[0]</span>
<span class="sd">               &gt;&gt;&gt; &#39;upper&#39;</span>
<span class="sd">               means lipid index 0 was assigned to the &#39;upper&#39; leaflet.</span>
<span class="sd">           nlipids (int): The number of lipids in the system. Each MDAnalysis residue in Args:mem_sel is</span>
<span class="sd">               treated as a lipid.</span>
<span class="sd">           clusters (list of list of list int): This is initialized as an empty list. It is used by the function</span>
<span class="sd">               CheckClustering() as a persistent container to store the list of clusters for each frame. clusters is</span>
<span class="sd">                overwritten after each call to CheckClustering().</span>
<span class="sd">           frame (obj:frames): An instance of the Frame container object (frames) to hold the COM trajectory data</span>
<span class="sd">               for this system.</span>
<span class="sd">           nframes (int): The total number of frames processed and stored for the MemSys instance.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#defaults - xy plane with z normal</span>
        <span class="n">ii</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">jj</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">kk</span><span class="o">=</span><span class="mi">2</span>
        <span class="k">if</span>    <span class="n">plane</span><span class="o">==</span><span class="s2">&quot;yz&quot;</span> <span class="ow">or</span> <span class="n">plane</span><span class="o">==</span><span class="s2">&quot;zy&quot;</span><span class="p">:</span>
            <span class="n">ii</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">jj</span><span class="o">=</span><span class="mi">2</span>
            <span class="n">kk</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">if</span>    <span class="n">plane</span><span class="o">==</span><span class="s2">&quot;xz&quot;</span> <span class="ow">or</span> <span class="n">plane</span><span class="o">==</span><span class="s2">&quot;zx&quot;</span><span class="p">:</span>
            <span class="n">ii</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">jj</span><span class="o">=</span><span class="mi">2</span>
            <span class="n">kk</span><span class="o">=</span><span class="mi">1</span>
        <span class="c1">#parallelize loading -- currently just applies to unwrapping</span>
        <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">if</span> <span class="n">nprocs</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span>
        <span class="c1">#store the indices of the plane directions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plane</span> <span class="o">=</span> <span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
        <span class="c1"># store the index of the normal direction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">kk</span>

        <span class="c1">#initialize leaflet objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;upper&#39;</span><span class="p">:</span><span class="n">Leaflet</span><span class="p">(</span><span class="s1">&#39;upper&#39;</span><span class="p">),</span><span class="s1">&#39;lower&#39;</span><span class="p">:</span><span class="n">Leaflet</span><span class="p">(</span><span class="s1">&#39;lower&#39;</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">com_leaflet</span> <span class="o">=</span> <span class="p">[]</span>


        <span class="c1">#get the number of lipids (residues)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nlipids</span><span class="o">=</span><span class="n">mem_sel</span><span class="o">.</span><span class="n">n_residues</span>
        <span class="c1">#initialize an empty cluster list - used to store the clusters built in the last call of &#39;CheckClustering&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># after &#39;CheckClustering&#39; is called, the outersize len(self.clusters) should equal self.nframes</span>
        <span class="c1">#initialize empty frame list</span>
        <span class="c1">#self.frame=[]</span>
        <span class="k">if</span> <span class="n">frame_path</span> <span class="o">==</span> <span class="s1">&#39;Default&#39;</span><span class="p">:</span>
            <span class="n">frame_path</span> <span class="o">=</span> <span class="s1">&#39;/tmp/&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">FrameShelve</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">frame_path</span><span class="p">,</span><span class="n">save</span><span class="o">=</span><span class="n">frame_save</span><span class="p">)</span>
        <span class="c1">#adjust for slicing index</span>
        <span class="n">len_mda_traj</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mda_traj</span><span class="p">)</span>
        <span class="c1">#adjust for negative indexing</span>
        <span class="k">while</span> <span class="n">fstart</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fstart</span><span class="o">+=</span><span class="n">len_mda_traj</span>
        <span class="k">while</span> <span class="n">fend</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fend</span><span class="o">+=</span><span class="n">len_mda_traj</span>

        <span class="c1">#adjust endpoint for slicing</span>
        <span class="n">fend</span><span class="o">+=</span><span class="mi">1</span>

        <span class="c1">#loop over the frames</span>
        <span class="n">f</span><span class="o">=</span><span class="mi">0</span>
        <span class="c1">#fskip-=1</span>
        <span class="c1"># you can slice the MDAnalysis trajectory in a loop</span>
        <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">mda_traj</span><span class="p">[</span><span class="n">fstart</span><span class="p">:</span><span class="n">fend</span><span class="p">:</span><span class="n">fskip</span><span class="p">]:</span>
            <span class="n">mdframe</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">frame</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;doing full trajectory frame &quot;</span><span class="p">,</span> <span class="n">mdframe</span><span class="p">,</span> <span class="s2">&quot;, COM trajectory frame &quot;</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
            <span class="c1">#add the frame object for this frame</span>
            <span class="n">cframe</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlipids</span><span class="p">)</span>
            <span class="c1"># set the box dimensions and the time for this frame</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dimensions</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="n">f</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">[:]</span>
            <span class="n">cframe</span><span class="o">.</span><span class="n">set_box</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
            <span class="n">cframe</span><span class="o">.</span><span class="n">set_time</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;time &quot;</span><span class="p">,</span><span class="n">mda_traj</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            <span class="n">cframe</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">f</span>
            <span class="n">cframe</span><span class="o">.</span><span class="n">mdnumber</span> <span class="o">=</span> <span class="n">mdframe</span>
            <span class="c1"># loop over the residues (lipids) and get the centers of mass</span>
            <span class="n">r</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">mem_sel</span><span class="o">.</span><span class="n">residues</span><span class="p">:</span>
                <span class="n">cframe</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">dimensions</span><span class="p">)</span>
                <span class="n">masses</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">masses</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">masses</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">cframe</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">masses</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">masses</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">cframe</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">masses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1">#print(cframe.lipidcom[r].mass)</span>
                <span class="n">r</span><span class="o">+=</span><span class="mi">1</span>
            <span class="c1">#append the frame</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cframe</span><span class="p">)</span>
            <span class="n">f</span><span class="o">+=</span><span class="mi">1</span>
        <span class="c1">#get the number of frames from the trajectory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span> <span class="o">=</span> <span class="n">f</span>
        <span class="c1">#now we need to unwrap the coordinates</span>
        <span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mem_sel</span><span class="p">)</span>
        <span class="n">oldcoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">natoms</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">currcoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">natoms</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">wrapcoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">natoms</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">mem_sel</span><span class="o">.</span><span class="n">indices</span>

        <span class="n">firstframe</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># loop over the trajectory again to get unwrapped coordinates</span>
        <span class="c1"># unwrap the raw residue coordinates - then get the COMs</span>
        <span class="n">f</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">mda_traj</span><span class="p">[</span><span class="n">fstart</span><span class="p">:</span><span class="n">fend</span><span class="p">:</span><span class="n">fskip</span><span class="p">]:</span>
            <span class="c1">#first we unwrapp</span>
            <span class="c1">#print &quot;unwrapping frame &quot;,frame.frame</span>
            <span class="n">currcoord</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">firstframe</span><span class="p">:</span>
                <span class="n">oldcoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">currcoord</span><span class="p">)</span>
                <span class="n">firstframe</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">abc</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
                    <span class="n">wrapcoord</span> <span class="o">=</span> <span class="n">wrap_coordinates_parallel</span><span class="p">(</span><span class="n">abc</span><span class="p">,</span> <span class="n">currcoord</span><span class="p">,</span> <span class="n">oldcoord</span><span class="p">,</span><span class="n">nprocs</span><span class="o">=</span><span class="n">nprocs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">wrapcoord</span> <span class="o">=</span> <span class="n">wrap_coordinates</span><span class="p">(</span><span class="n">abc</span><span class="p">,</span> <span class="n">currcoord</span><span class="p">,</span> <span class="n">oldcoord</span><span class="p">)</span>
                <span class="n">frame</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrapcoord</span><span class="p">[:]</span>
                <span class="n">oldcoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">wrapcoord</span><span class="p">)</span>
            <span class="c1">#now we need to adjust for the center of mass motion of the membrane -- for simplicity set all frames to (0,0,0)</span>
            <span class="c1"># to remove center of mass motion of the membrane</span>
            <span class="n">mem_com</span> <span class="o">=</span> <span class="n">mem_sel</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span>
            <span class="n">frame</span><span class="o">.</span><span class="n">_pos</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-=</span> <span class="n">mem_com</span>
            <span class="n">r</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">cframe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">mem_sel</span><span class="o">.</span><span class="n">residues</span><span class="p">:</span>
                <span class="n">cframe</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">r</span><span class="o">+=</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">=</span><span class="n">cframe</span>
            <span class="n">f</span><span class="o">+=</span><span class="mi">1</span>

        <span class="c1"># now we can assign the lipids to the leaflets</span>
        <span class="c1"># NOTE: Lipids are only assigned to leaflets once based on the</span>
        <span class="c1">#       first frame of the trajectory</span>

        <span class="c1">#first- compute the average position along the normal direction</span>
        <span class="n">zstat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">lipcom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">:</span>
            <span class="n">zstat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">lipcom</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">])</span>
        <span class="n">zavg</span> <span class="o">=</span> <span class="n">zstat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="c1"># now loop over the lipids</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">lipcom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="c1"># decide which leaflet</span>
            <span class="k">if</span> <span class="n">lipcom</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">]</span><span class="o">&gt;</span><span class="n">zavg</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
            <span class="k">elif</span> <span class="n">lipcom</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">]</span><span class="o">&lt;</span><span class="n">zavg</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span>
            <span class="c1">#add to the chosen leaflet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">com_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">add_member</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">lipcom</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
            <span class="n">l</span><span class="o">+=</span><span class="mi">1</span>
        <span class="c1">#complete</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Center of mass trajectory with </span><span class="si">%s</span><span class="s1"> frames and </span><span class="si">%s</span><span class="s1"> lipids/components&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlipids</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Center of mass trajectory with </span><span class="si">%s</span><span class="s1"> frames and </span><span class="si">%s</span><span class="s1"> lipids/components&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlipids</span><span class="p">)</span>

<div class="viewcode-block" id="COMTraj.number_of_unique_groups"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.number_of_unique_groups">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_unique_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the number of uniquely named LipidGroups within both Leaflet objects.</span>

<span class="sd">        Returns:</span>
<span class="sd">        int: The number of uniquely named LipidGroup objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">leaflet</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">leaflet</span><span class="o">.</span><span class="n">groups</span><span class="p">:</span>
                <span class="n">gname</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">gname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">resnames</span><span class="p">:</span>
                    <span class="n">resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gname</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">resnames</span><span class="p">)</span></div>
    <span class="c1">#def LeafletCOM(leaflet_name,frame_num):</span>


    <span class="c1"># function to compute the mean squared displace (msd) along with the diffusion constant of a group</span>
    <span class="c1"># Possibly add functionality to specify the range of trajectory frames to include int computaton.</span>
<div class="viewcode-block" id="COMTraj.calc_msd"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.calc_msd">[docs]</a>    <span class="k">def</span> <span class="nf">calc_msd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaflet</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the configurational average mean squared displacement for select lipids in a select leaflet(s).</span>

<span class="sd">        This function allows the mean squared displacement (MSD) to be computed</span>
<span class="sd">        for a specified leaflet (&#39;upper&#39;, &#39;lower&#39;, or &#39;both&#39;) and for a specified LipidGroup within the</span>
<span class="sd">        chosen Leaflet. This calculation is over the whole trajectory and assumes the first frame is the</span>
<span class="sd">        reference frame for computing the displacement.</span>

<span class="sd">        Args:</span>
<span class="sd">            leaflet (str): A string designating which Leaflet to include in the computation.</span>
<span class="sd">            group (str): A string with the name of a specific LipidGroup to in the computation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: This is a nframesx2 numpy array (of floats) containing the</span>
<span class="sd">                results of the MSD computation across all frames.</span>
<span class="sd">                msd_results[i,0] = simulation time for frame i.</span>
<span class="sd">                msd_results[i,1] = the configurational average MSD over the specified LipidCOMs for frame f = i.</span>
<span class="sd">                For i in range( nframes ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># initialize a list to hold the indices of LipidCOMs to be included in this computaton.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#diffusion dimension - assume lateral so, dim=2 -- Although this could made an optional parameter.</span>
        <span class="n">dim</span><span class="o">=</span><span class="mi">2</span>
        <span class="c1"># parse the leaflet and group inputs</span>
        <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#unknown option--use default &quot;both&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">leaflet</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> from the &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="s2">&quot; leaflet&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="c1">#store the coordinates of the selected LipidCOMs in a single numpy array</span>
        <span class="n">selcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span><span class="n">n_com</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">):</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">com_curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">]</span>
                <span class="n">selcoords</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">count</span><span class="p">]</span><span class="o">=</span><span class="n">com_curr</span><span class="p">[:]</span>
                <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>

        <span class="c1">#initialize a numpy array to hold the msd for the selection</span>
        <span class="n">msd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1">#initialize a running stats object to do the averaging</span>
        <span class="n">drs_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="c1">#initialize a running stats object for the diffusion constant (frame/time average)</span>
        <span class="n">diff_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="c1">#running stats object for time averaging</span>
        <span class="n">msd_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="c1">#loop over the frames starting at index 1</span>
        <span class="c1">#print comlist</span>
        <span class="c1">#print len(comlist)</span>
        <span class="n">coml0</span> <span class="o">=</span> <span class="n">selcoords</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>
        <span class="c1">#print coml0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">):</span>
            <span class="c1"># get the current com frame list</span>
            <span class="n">tc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">tc</span>
            <span class="n">comlcurr</span> <span class="o">=</span> <span class="n">selcoords</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="n">comlcurr</span> <span class="o">-</span> <span class="n">coml0</span>
            <span class="n">drs</span> <span class="o">=</span> <span class="n">dr</span><span class="o">*</span><span class="n">dr</span>
            <span class="c1">#loop over the selections for this frame</span>
            <span class="k">for</span>    <span class="n">val</span> <span class="ow">in</span> <span class="n">drs</span><span class="p">:</span>
                <span class="n">drs_curr</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:]</span>
                <span class="n">drs_mag</span> <span class="o">=</span> <span class="n">drs_curr</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">drs_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">drs_mag</span><span class="p">)</span>
            <span class="c1">#get the msd for the current selection</span>
            <span class="n">msdcurr</span> <span class="o">=</span> <span class="n">drs_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="c1">#devcurr = drs_stat.deviation()</span>
            <span class="n">drs_stat</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="n">msd_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">msdcurr</span><span class="p">)</span>
            <span class="n">msd_tavg</span> <span class="o">=</span> <span class="n">msd_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="c1">#msd_dev = msd_stat.deviation()</span>
            <span class="c1">#dt = times[i]-times[0]</span>
            <span class="n">DiffCon</span> <span class="o">=</span> <span class="n">msd_tavg</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">dim</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">diff_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">DiffCon</span><span class="p">)</span>
            <span class="c1">#print &quot;msdcurr &quot;,msdcurr</span>
            <span class="c1">#push to the msd array</span>

            <span class="n">msd</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">dt</span>
            <span class="n">msd</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">msdcurr</span>
<span class="c1">#            msd[i,2]=msd_tavg</span>
<span class="c1">#            msd[i,3]=msd_dev</span>
<span class="c1">#            msd[i,4]=DiffCon</span>
<span class="c1">#            msd[i,5]=diff_stat.mean()</span>
<span class="c1">#            msd[i,6]=diff_stat.deviation()</span>
        <span class="c1">#return msd array</span>
        <span class="k">return</span> <span class="n">msd</span></div>

    <span class="c1">#function to compute the thickness of the membrane (in the normal direction). The algorithm is based on</span>
    <span class="c1"># the GridMAT-MD bilayer thickness calculation (except without the gridding procedure)</span>
<div class="viewcode-block" id="COMTraj.calc_membrane_thickness"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.calc_membrane_thickness">[docs]</a>    <span class="k">def</span> <span class="nf">calc_membrane_thickness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the bilayer thickness across the trajectory.</span>
<span class="sd">        Computes the thickness of the bilayer (along the normal direction). The algorithm is based on</span>
<span class="sd">        the GridMAT-MD bilayer thickness calculation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple of numpy.array: This is a two element tuple containing numpy arrays of the computation results.</span>
<span class="sd">                tuple[0] =&gt; thickness: A nx5 numpy array containing the</span>
<span class="sd">                results of the thickness computation for the specified frames. Specifically:</span>
<span class="sd">                    thickness[i,0] = simulation time for frame f = i + fstart.</span>
<span class="sd">                    thickness[i,1] = the configurational average thickness for frame f = i + fstart.</span>
<span class="sd">                    thickness[i,2] = the standard deviation of the configurational average thickness for frame f = i + fstart.</span>
<span class="sd">                    thickness[i,3] = the running time average of the configurational average thickness for frame f = i + fstart.</span>
<span class="sd">                    thickness[i,4] = the running standard deviation of the time averaged configurational average thickness for frame f = i + fstart.</span>
<span class="sd">                    For i in range( (fend-fstar) + 1).</span>
<span class="sd">                tuple[1] =&gt; thickness_map: A nxNx6 numpy array containing the thickness data that can be</span>
<span class="sd">                used to generate a 3d thickness map/plot. Specifically:</span>
<span class="sd">                    thickness[i,j,0] = simulation time for frame f = i + fstart and lipid j.</span>
<span class="sd">                    thickness[i,j,1] = the average x position for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                    thickness[i,j,2] = the average y position for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                    thickness[i,j,3] = the lower z position for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                    thickness[i,j,4] = the upper z position for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                    thickness[i,j,5] = the difference between the upper and lower z positions</span>
<span class="sd">                    for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                    For i in range((fend-fstar) + 1) and For j in range(nlipids).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#upper_match = []</span>
        <span class="c1">#lower_match = []</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span>
        <span class="n">comcup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">comclo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">dcom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">zdists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlipids</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">zmaps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlipids</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="c1">#dcoms = np.zeros(3)</span>
        <span class="n">f</span><span class="o">=</span><span class="mi">0</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">):</span>
            <span class="n">n</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">fr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
            <span class="n">boxc</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">box</span>
            <span class="n">boxc_xh</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="n">boxc_yh</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">time</span>
            <span class="k">for</span> <span class="n">memu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
                <span class="n">idu</span> <span class="o">=</span> <span class="n">memu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">comcup</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">idu</span><span class="p">]</span><span class="o">.</span><span class="n">com</span>
                <span class="n">distxy</span> <span class="o">=</span> <span class="mf">10000.0</span>
                <span class="n">distz</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="c1">#mindex = 0</span>
                <span class="n">zlom</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">zhim</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">xavgm</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">yavgm</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">meml</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
                    <span class="n">idl</span> <span class="o">=</span> <span class="n">meml</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">comclo</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">idl</span><span class="p">]</span><span class="o">.</span><span class="n">com</span>
                    <span class="n">dcom</span> <span class="o">=</span> <span class="n">comcup</span><span class="o">-</span><span class="n">comclo</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">dcom</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                    <span class="n">dy</span> <span class="o">=</span> <span class="n">dcom</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span>
                    <span class="n">dz</span> <span class="o">=</span> <span class="n">dcom</span><span class="p">[</span><span class="n">zi</span><span class="p">]</span>
                    <span class="c1">#Minimum image -- coordinates must be pre-wrapped</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">boxc_xh</span><span class="p">:</span>
                        <span class="n">dx</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comcup</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_xh</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comclo</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_xh</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">boxc_yh</span><span class="p">:</span>
                        <span class="n">dy</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comcup</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_yh</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comclo</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_yh</span><span class="p">)</span>
                    <span class="n">rxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="c1">#get 4d map values</span>
                    <span class="n">comavg</span> <span class="o">=</span> <span class="p">(</span><span class="n">comcup</span><span class="o">+</span><span class="n">comclo</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
                    <span class="n">xavg</span> <span class="o">=</span> <span class="n">comavg</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                    <span class="n">yavg</span> <span class="o">=</span> <span class="n">comavg</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span>
                    <span class="n">zlo</span> <span class="o">=</span> <span class="n">comclo</span><span class="p">[</span><span class="n">zi</span><span class="p">]</span>
                    <span class="n">zhi</span> <span class="o">=</span> <span class="n">comcup</span><span class="p">[</span><span class="n">zi</span><span class="p">]</span>
                    <span class="k">if</span>    <span class="n">rxy</span><span class="o">&lt;</span><span class="n">distxy</span><span class="p">:</span>
                        <span class="n">distxy</span><span class="o">=</span><span class="n">rxy</span>
                        <span class="n">distz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>
                        <span class="n">mindex</span><span class="o">=</span><span class="n">meml</span>
                        <span class="n">xavgm</span> <span class="o">=</span> <span class="n">xavg</span>
                        <span class="n">yavgm</span> <span class="o">=</span> <span class="n">yavg</span>
                        <span class="n">zlom</span> <span class="o">=</span> <span class="n">zlo</span>
                        <span class="n">zhim</span> <span class="o">=</span> <span class="n">zhi</span>

                <span class="c1">#upper_match.append([mindex,distz])</span>
                <span class="c1">#print &quot;n &quot;,n,&quot; xvg &quot;, xavgm,&quot; yvg &quot;, yavgm</span>
                <span class="n">zdists</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">distz</span>
                <span class="c1">#maps</span>
                <span class="n">zmaps</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">dt</span>
                <span class="n">zmaps</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">xavgm</span>
                <span class="n">zmaps</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">yavgm</span>
                <span class="n">zmaps</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">zlom</span>
                <span class="n">zmaps</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="n">zhim</span>
                <span class="n">zmaps</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="n">distz</span>

                <span class="n">n</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">meml</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
                <span class="n">idl</span> <span class="o">=</span> <span class="n">meml</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">comclo</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">idl</span><span class="p">]</span><span class="o">.</span><span class="n">com</span>
                <span class="n">distxy</span> <span class="o">=</span> <span class="mf">10000.0</span>
                <span class="n">distz</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">mindex</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">zlom</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">zhim</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">xavgm</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">yavgm</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">memu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">members</span><span class="p">:</span>
                    <span class="n">idu</span> <span class="o">=</span> <span class="n">memu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">comcup</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">idu</span><span class="p">]</span><span class="o">.</span><span class="n">com</span>
                    <span class="n">dcom</span> <span class="o">=</span> <span class="n">comclo</span><span class="o">-</span><span class="n">comcup</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">dcom</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                    <span class="n">dy</span> <span class="o">=</span> <span class="n">dcom</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span>
                    <span class="n">dz</span> <span class="o">=</span> <span class="n">dcom</span><span class="p">[</span><span class="n">zi</span><span class="p">]</span>
                    <span class="c1">#Minimum image -- coordinates must be pre-wrapped</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">boxc_xh</span><span class="p">:</span>
                        <span class="n">dx</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comclo</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_xh</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comcup</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_xh</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">boxc_yh</span><span class="p">:</span>
                        <span class="n">dy</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comclo</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_yh</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comcup</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_yh</span><span class="p">)</span>
                    <span class="n">rxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="c1">#get 4d map values</span>
                    <span class="n">comavg</span> <span class="o">=</span> <span class="p">(</span><span class="n">comcup</span><span class="o">+</span><span class="n">comclo</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
                    <span class="n">xavg</span> <span class="o">=</span> <span class="n">comavg</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                    <span class="n">yavg</span> <span class="o">=</span> <span class="n">comavg</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span>
                    <span class="n">zlo</span> <span class="o">=</span> <span class="n">comclo</span><span class="p">[</span><span class="n">zi</span><span class="p">]</span>
                    <span class="n">zhi</span> <span class="o">=</span> <span class="n">comcup</span><span class="p">[</span><span class="n">zi</span><span class="p">]</span>
                    <span class="k">if</span>    <span class="n">rxy</span><span class="o">&lt;</span><span class="n">distxy</span><span class="p">:</span>
                        <span class="n">distxy</span><span class="o">=</span><span class="n">rxy</span>
                        <span class="n">distz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>
                        <span class="c1">#mindex=meml</span>
                        <span class="n">xavgm</span> <span class="o">=</span> <span class="n">xavg</span>
                        <span class="n">yavgm</span> <span class="o">=</span> <span class="n">yavg</span>
                        <span class="n">zlom</span> <span class="o">=</span> <span class="n">zlo</span>
                        <span class="n">zhim</span> <span class="o">=</span> <span class="n">zhi</span>
                <span class="c1">#upper_match.append([mindex,distz])</span>
                <span class="c1">#print &quot;n &quot;,n,&quot; xvg &quot;, xavgm,&quot; yvg &quot;, yavgm</span>
                <span class="n">zdists</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">distz</span>
                <span class="c1">#maps</span>
                <span class="n">zmaps</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">dt</span>
                <span class="n">zmaps</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">xavgm</span>
                <span class="n">zmaps</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">yavgm</span>
                <span class="n">zmaps</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">zlom</span>
                <span class="n">zmaps</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="n">zhim</span>
                <span class="n">zmaps</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="n">distz</span>
                <span class="n">n</span><span class="o">+=</span><span class="mi">1</span>

            <span class="c1">#break</span>
        <span class="n">zavgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="n">zdtstat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">):</span>
            <span class="n">currtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">fr</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">currtime</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">zdists</span><span class="p">[</span><span class="n">fr</span><span class="p">,:]</span>
            <span class="n">zavgcurr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">zdevcurr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
            <span class="n">zdtstat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">zavgcurr</span><span class="p">)</span>
            <span class="n">zdtcurr</span> <span class="o">=</span> <span class="n">zdtstat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">zdtdcurr</span> <span class="o">=</span> <span class="n">zdtstat</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
            <span class="n">zavgs</span><span class="p">[</span><span class="n">fr</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">dt</span>
            <span class="n">zavgs</span><span class="p">[</span><span class="n">fr</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">zavgcurr</span>
            <span class="n">zavgs</span><span class="p">[</span><span class="n">fr</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">zdevcurr</span>
            <span class="n">zavgs</span><span class="p">[</span><span class="n">fr</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">zdtcurr</span>
            <span class="n">zavgs</span><span class="p">[</span><span class="n">fr</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="n">zdtdcurr</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">zavgs</span><span class="p">,</span> <span class="n">zmaps</span><span class="p">)</span></div>
        <span class="c1">#return zmaps</span>

    <span class="c1"># a simple cluster/chain analysis routine</span>
<div class="viewcode-block" id="COMTraj.check_clustering"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.check_clustering">[docs]</a>    <span class="k">def</span> <span class="nf">check_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaflet</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mf">15.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Determine physical cluster for select lipid COMs in a select leaflet(s).</span>

<span class="sd">        This function determines physical clusters based on Cartesian distance criteria</span>
<span class="sd">        in a specified leaflet (&#39;upper&#39;, &#39;lower&#39;, or &#39;both&#39;) and for a specified LipidGroup within the</span>
<span class="sd">        chosen Leaflet. The routine determines the physical clusters for each frame in the trajectory</span>
<span class="sd">        and computes properties of these clusters, e.g. number of clusters, which are time averaged over the trajectory.</span>
<span class="sd">        The information on the clusters is stored in MemSys.clusters which can then be used by other functions</span>
<span class="sd">        (like MemSys.ExportClustersForPlotting).</span>

<span class="sd">        Args:</span>
<span class="sd">            leaflet (str, optional): A string designating which Leaflet to include in the computation.</span>
<span class="sd">            group (str, optional): A string with the name of a specific LipidGroup to in the computation.</span>
<span class="sd">            dist (float, optional): The distance cutoff for determining clusters.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: This is a nframesx5 numpy array (of floats) containing the</span>
<span class="sd">                results of this computation across all frames.</span>
<span class="sd">                cluster_results[i,0] = simulation time for frame i.</span>
<span class="sd">                cluster_results[i,1] = the current running time averaged number of clusters at frame f = i.</span>
<span class="sd">                cluster_results[i,2] = the current standard deviation of the running time averaged number of clusters at frame f = i.</span>
<span class="sd">                cluster_results[i,3] = the current running time averaged configurational average lipids per cluster at frame f = i.</span>
<span class="sd">                cluster_results[i,4] = the current standard deviation of the running time averaged</span>
<span class="sd">                    configurational average lipids per cluster at frame f = i.</span>
<span class="sd">                For i in range( nframes ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#diffusion dimension - assume lateral so, dim=2</span>
        <span class="c1">#dim=2</span>
        <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#unknown option--use default &quot;both&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">leaflet</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> from the &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="s2">&quot; leaflet&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="c1">#n_com = len(indices)</span>

        <span class="c1">#print &quot;there are &quot;,len(indices),&quot; members&quot;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#zi = self.norm</span>
        <span class="c1">#reset the system cluster list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># numpy array to store output for return</span>
        <span class="n">outdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
        <span class="c1">#stats objects - time averages</span>
        <span class="n">ncstat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span> <span class="c1">#number of clusters</span>
        <span class="n">asstat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span> <span class="c1"># average cluster size</span>
        <span class="n">misstat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span> <span class="c1"># minimum cluster size</span>
        <span class="n">masstat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span> <span class="c1"># maximum cluster size</span>
        <span class="c1">#loop over frames</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">):</span>
            <span class="n">fr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
            <span class="n">ctime</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">time</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1">#            masterlistf = []</span>
<span class="c1">#            masterlistf += masterlist</span>
            <span class="c1">#rebuild the master list each frame</span>
            <span class="n">masterlistf</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">masterlistf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="c1">#            print &quot;master &quot;,masterlistf</span>
            <span class="n">boxc</span><span class="o">=</span><span class="n">fr</span><span class="o">.</span><span class="n">box</span>
            <span class="n">boxc_xh</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="n">boxc_yh</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="c1">#print boxc</span>
            <span class="n">clustind</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">neighborlist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">masterlistf</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1">#print &quot;master &quot;,masterlistf</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">masterlistf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">masterlistf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
            <span class="c1">#    print</span>
                <span class="c1"># reset the neighborlist</span>
                <span class="n">neighborlist</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1">#seed the neighborlist with the start</span>
                <span class="n">neighborlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
                <span class="c1">#now loop over the neighborlist and build neighbors and neighbors of neigbors for this cluster</span>
                <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighborlist</span><span class="p">):</span>
                    <span class="n">ele</span> <span class="o">=</span> <span class="n">neighborlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">startn</span> <span class="o">=</span> <span class="n">ele</span>
                    <span class="n">coms</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">startn</span><span class="p">]</span><span class="o">.</span><span class="n">com</span>
                    <span class="c1">#get neighbors of the start</span>
                    <span class="c1">#mindex=0</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">masterlistf</span><span class="p">)):</span>
                    <span class="c1">#for elem in masterlistf:</span>
                        <span class="n">elem</span> <span class="o">=</span> <span class="n">masterlistf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">incluster</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="c1">#    print &quot;second incluster &quot;,incluster</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">incluster</span><span class="p">:</span>
                            <span class="n">ci</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">comc</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">ci</span><span class="p">]</span><span class="o">.</span><span class="n">com</span>
                            <span class="c1">#dcom = comc-coms</span>
                            <span class="n">dx</span> <span class="o">=</span> <span class="n">comc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">coms</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                            <span class="n">dy</span> <span class="o">=</span> <span class="n">comc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">coms</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span>
                            <span class="c1">#rxy = np.sqrt(dx*dx+dy*dy)</span>
                            <span class="c1">#print dx,&quot; &quot;,dy,&quot; &quot;,rxy</span>

                            <span class="c1">#Minimum image -- coordinates must be pre-wrapped</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">boxc_xh</span><span class="p">:</span>
                                <span class="n">dx</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_xh</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">coms</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_xh</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">boxc_yh</span><span class="p">:</span>
                                <span class="n">dy</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_yh</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">coms</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_yh</span><span class="p">)</span>
                            <span class="n">rxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dx</span><span class="o">+</span><span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="p">)</span>
                            <span class="c1">#print &quot;rxy &quot;,rxy,&quot; dx &quot;,dx,&quot; dy &quot;,dy</span>
                            <span class="k">if</span>    <span class="n">rxy</span> <span class="o">&lt;=</span> <span class="n">dist</span><span class="p">:</span>
                                <span class="c1">#print &quot;passed! adding &quot;,masterlistf[mindex][0],&quot; to the neighborlist&quot;</span>
                                <span class="n">neighborlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">masterlistf</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                                <span class="n">masterlistf</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
                        <span class="c1">#mindex+=1</span>
                    <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
                <span class="c1">#filter the masterlistf</span>
                <span class="c1">#    print &quot;neighlist&quot;, neighborlist</span>
                <span class="n">masterlistf</span><span class="o">=</span><span class="nb">list</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">masterlistf</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighborlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="n">clusters</span><span class="p">[</span><span class="n">clustind</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">neighborlist</span><span class="p">)</span>
                    <span class="c1">#print &quot;clustind clusters[clustind]&quot;</span>
                    <span class="c1">#print clustind, &quot; &quot;,clusters</span>
                    <span class="n">clustind</span><span class="o">+=</span><span class="mi">1</span>

            <span class="c1">#print masterlistf</span>
            <span class="c1">#filter out single points</span>
            <span class="c1">#clusters = [v for v in clusters if len(v) &gt; 1]</span>
            <span class="n">nclusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
            <span class="n">clsizestat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
            <span class="n">mini</span> <span class="o">=</span> <span class="mi">100000000</span>
            <span class="n">maxi</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1000000</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
                <span class="n">clsizestat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
                <span class="k">if</span>    <span class="n">size</span><span class="o">&gt;</span><span class="n">maxi</span><span class="p">:</span>
                    <span class="n">maxi</span><span class="o">=</span><span class="n">size</span>
                <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">mini</span><span class="p">:</span>
                    <span class="n">mini</span><span class="o">=</span><span class="n">size</span>
            <span class="n">avgsize</span> <span class="o">=</span> <span class="n">clsizestat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="c1">#store instantaneous values</span>
            <span class="n">outdata</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctime</span>
            <span class="c1">#push to the time averages</span>
            <span class="n">ncstat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">nclusters</span><span class="p">)</span>
            <span class="n">asstat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">avgsize</span><span class="p">)</span>
            <span class="n">misstat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">mini</span><span class="p">)</span>
            <span class="n">masstat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">maxi</span><span class="p">)</span>
            <span class="n">outdata</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncstat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">outdata</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncstat</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
            <span class="n">outdata</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">asstat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">outdata</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">asstat</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
            <span class="c1"># now add cluster list to the system storage</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">clusters</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">outdata</span></div>
    <span class="c1">#takes the cluster lists from self.clusters and gets the plane coordinates</span>
    <span class="c1"># need to call the &#39;CheckClustering&#39; function before calling this one</span>
<div class="viewcode-block" id="COMTraj.export_clusters_for_plotting"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.export_clusters_for_plotting">[docs]</a>    <span class="k">def</span> <span class="nf">export_clusters_for_plotting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Determine physical cluster for select lipid COMs in a select leaflet(s).</span>

<span class="sd">        This function determines physical clusters based on Cartesian distance criteria</span>
<span class="sd">        in a specified leaflet (&#39;upper&#39;, &#39;lower&#39;, or &#39;both&#39;) and for a specified LipidGroup within the</span>
<span class="sd">        chosen Leaflet. The routine determines the physical clusters for each frame in the trajectory</span>
<span class="sd">        and computes properties of these clusters, e.g. number of clusters, which are time averaged over the trajectory.</span>
<span class="sd">        The information on the clusters is stored in MemSys.clusters which can then be used by other functions</span>
<span class="sd">        (like MemSys.ExportClustersForPlotting).</span>

<span class="sd">        Args:</span>
<span class="sd">            leaflet (str, optional): A string designating which Leaflet to include in the computation.</span>
<span class="sd">            group (str, optional): A string with the name of a specific LipidGroup to in the computation.</span>
<span class="sd">            dist (float, optional): The distance cutoff for determining clusters.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: This is a nframesx5 numpy array (of floats) containing the</span>
<span class="sd">                results of this computation across all frames.</span>
<span class="sd">                cluster_results[i,0] = simulation time for frame i.</span>
<span class="sd">                cluster_results[i,1] = the current running time averaged number of clusters at frame f = i.</span>
<span class="sd">                cluster_results[i,2] = the current standard deviation of the running time averaged number of clusters at frame f = i.</span>
<span class="sd">                cluster_results[i,3] = the current running time averaged configurational average lipids per cluster at frame f = i.</span>
<span class="sd">                cluster_results[i,4] = the current standard deviation of the running time averaged</span>
<span class="sd">                    configurational average lipids per cluster at frame f = i.</span>
<span class="sd">                For i in range( nframes ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning!! - call to </span><span class="se">\&#39;</span><span class="s2">ExportClustersForPlotting</span><span class="se">\&#39;</span><span class="s2"> of a MemSys object with no cluster lists&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;      the </span><span class="se">\&#39;</span><span class="s2">CheckClustering</span><span class="se">\&#39;</span><span class="s2"> function needs to be called first!&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#get the maximum number of clusters from any of the frames</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)):</span>
            <span class="n">nclust</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">nclust</span><span class="o">&gt;</span><span class="n">maxsize</span><span class="p">:</span>
                <span class="n">maxsize</span><span class="o">=</span><span class="n">nclust</span>
        <span class="c1">#generate a color array</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">rainbow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">))</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)):</span>
            <span class="n">frame_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
            <span class="n">nclust</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_clusters</span><span class="p">)</span>
            <span class="c1">#print len(frame_clusters)</span>
            <span class="c1">#print len(colors)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">xcoord</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1">#xm1 = []</span>
            <span class="c1">#xp1 = []</span>
            <span class="n">ycoord</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1">#ym1 = []</span>
            <span class="c1">#yp1 =[]</span>
            <span class="n">coord_color</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">frame_clusters</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
                    <span class="n">xc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                    <span class="c1">#xcm1 = self.frame[f].lipidcom[index].com[xi]-self.frame[f].box[xi]</span>
                    <span class="c1">#xcp1 = self.frame[f].lipidcom[index].com[xi]+self.frame[f].box[xi]</span>
                    <span class="n">yc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span>
                    <span class="c1">#ycm1 = self.frame[f].lipidcom[index].com[yi]-self.frame[f].box[yi]</span>
                    <span class="c1">#ycp1 = self.frame[f].lipidcom[index].com[yi]+self.frame[f].box[yi]</span>
                    <span class="n">xcoord</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>
                    <span class="c1">#xm1.append(xcm1)</span>
                    <span class="c1">#xp1.append(xcp1)</span>
                    <span class="n">ycoord</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">yc</span><span class="p">)</span>
                    <span class="c1">#ym1.append(ycm1)</span>
                    <span class="c1">#yp1.append(ycp1)</span>
                    <span class="c1">#print c,&quot; &quot;,colors[c]</span>
                    <span class="n">coord_color</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
                <span class="n">c</span><span class="o">+=</span><span class="mi">1</span>
            <span class="c1">#output.append([xm1,xcoord,xp1,ym1,ycoord,yp1,coord_color])</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xcoord</span><span class="p">,</span><span class="n">ycoord</span><span class="p">,</span><span class="n">coord_color</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">output</span></div>

    <span class="c1"># function to compute an approximation of the area per lipid of a group using</span>
    <span class="c1"># closest neighbor circles</span>
<div class="viewcode-block" id="COMTraj.calc_area_per_lipid_closest_neighbor_circle"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.calc_area_per_lipid_closest_neighbor_circle">[docs]</a>    <span class="k">def</span> <span class="nf">calc_area_per_lipid_closest_neighbor_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaflet</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Approximate the area per lipid for select lipid COMs in a select leaflet(s).</span>

<span class="sd">        This function computes an approximation of the area per lipid of a selection of lipid COMs</span>
<span class="sd">        by locating the closest neighbor and computing the non-overlapping circular area the two</span>
<span class="sd">        equiradius circles formed by the vector between the two COM points. At each frame this is averaged</span>
<span class="sd">        over the configuration.</span>

<span class="sd">        Args:</span>
<span class="sd">            leaflet (str, optional): A string designating which Leaflet to include in the computation.</span>
<span class="sd">            group (str, optional): A string with the name of a specific LipidGroup to in the computation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: This is a nframesx4 numpy array (of floats) containing the</span>
<span class="sd">                results of this computation across all frames.</span>
<span class="sd">                apl_results[i,0] = simulation time for frame i.</span>
<span class="sd">                apl_results[i,1] = configurational average area per lipid at frame f = i.</span>
<span class="sd">                apl_results[i,2] = the current running time average (of the configurational average) at frame f = i.</span>
<span class="sd">                apl_results[i,3] = the current standard deviation of the running time average at frame f = i.</span>
<span class="sd">                For i in range( nframes ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#diffusion dimension - assume lateral so, dim=2</span>
        <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#nlip = 0</span>
        <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;upper&#39;</span><span class="p">)</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
            <span class="c1">#nlip=self.nlipids</span>

        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span> <span class="ow">or</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leaflet</span><span class="p">)</span>
            <span class="c1">#nlip = len(self.leaflets[leaflet])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#unknown option--use default &quot;both&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">leaflet</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> from the &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="s2">&quot; leaflet&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sub_fact</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">3.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="c1">#initialize a numpy array to hold the msd for the selection</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="c1">#initialize a running stats object to do the averaging</span>
        <span class="n">area_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="c1">#n_leaflet = len(do_leaflet)</span>
        <span class="c1">#build the index lists</span>
        <span class="n">indices_leaflet</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">all_mem_leaflet</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="n">all_mem</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>
            <span class="n">all_mem_leaflet</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_mem</span><span class="p">)</span>
            <span class="n">indices_leaflet</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>


        <span class="c1">#loop over the frames</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">):</span>
            <span class="n">fr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">time</span>
            <span class="n">boxc</span><span class="o">=</span><span class="n">fr</span><span class="o">.</span><span class="n">box</span>
            <span class="n">boxc_xh</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="n">boxc_yh</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="n">lat_area</span> <span class="o">=</span> <span class="n">boxc_xh</span><span class="o">*</span><span class="n">boxc_yh</span><span class="o">*</span><span class="mf">4.0</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
                <span class="n">lat_area</span><span class="o">*=</span><span class="mf">2.0</span>

            <span class="n">area_stat_config</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
            <span class="c1">#loop over the leaflets</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">indices_leaflet</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">all_mem</span> <span class="o">=</span> <span class="n">all_mem_leaflet</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="c1">#loop over the group indices in this leaflet</span>
                <span class="k">for</span>    <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                    <span class="n">comc</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[:]</span>
                    <span class="n">rdist_min</span> <span class="o">=</span> <span class="mf">10000.0</span>
                    <span class="c1">#loop over the COMs of non group</span>
                    <span class="c1">#get all the leaflet members</span>

                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">all_mem</span><span class="p">:</span>
                        <span class="c1">#print &quot;a &quot;,a</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">index</span><span class="p">:</span>
                            <span class="n">comn</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[:]</span>
                            <span class="n">dx</span> <span class="o">=</span> <span class="n">comc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">comn</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                            <span class="n">dy</span> <span class="o">=</span> <span class="n">comc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">comn</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span>

                            <span class="c1">#Minimum image -- coordinates must be pre-wrapped</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">boxc_xh</span><span class="p">:</span>
                                <span class="n">dx</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_xh</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comn</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_xh</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">boxc_yh</span><span class="p">:</span>
                                <span class="n">dy</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_yh</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">comn</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">-</span><span class="n">boxc_yh</span><span class="p">)</span>
                            <span class="n">rxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dx</span><span class="o">+</span><span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="p">)</span>
                            <span class="c1">#print &quot;rxy &quot;,rxy,&quot; dx &quot;,dx,&quot; dy &quot;,dy</span>
                            <span class="k">if</span>    <span class="n">rxy</span> <span class="o">&lt;</span> <span class="n">rdist_min</span><span class="p">:</span>
                                <span class="n">rdist_min</span> <span class="o">=</span> <span class="n">rxy</span>
                    <span class="c1">#got the min dist, now compute area</span>
                    <span class="c1">#print &quot;rdist_min &quot;,rdist_min</span>
                    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">rdist_min</span><span class="o">*</span><span class="n">rdist_min</span> <span class="o">-</span> <span class="p">(</span><span class="n">rdist_min</span><span class="o">*</span><span class="n">rdist_min</span><span class="p">)</span><span class="o">*</span><span class="n">sub_fact</span>
                    <span class="n">area_stat_config</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
            <span class="n">area_conf_avg</span> <span class="o">=</span> <span class="n">area_stat_config</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">area_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">area_conf_avg</span><span class="p">)</span>
            <span class="n">area_time_run</span> <span class="o">=</span> <span class="n">area_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">area_time_run_dev</span> <span class="o">=</span> <span class="n">area_stat</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
            <span class="c1">#print &quot;time &quot;,dt</span>
            <span class="n">areas</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">dt</span>
            <span class="n">areas</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">area_conf_avg</span>
            <span class="n">areas</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">area_time_run</span>
            <span class="n">areas</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">area_time_run_dev</span>
            <span class="c1">#areas[f][4]=lat_area/nlip</span>
        <span class="k">return</span> <span class="n">areas</span></div>

    <span class="c1"># function to compute the area per lipid using the lateral box sizes and numbers of lipids:</span>
<div class="viewcode-block" id="COMTraj.calc_area_per_lipid_box"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.calc_area_per_lipid_box">[docs]</a>    <span class="k">def</span> <span class="nf">calc_area_per_lipid_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaflet</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Approximate the area per lipid for select lipid COMs in a select leaflet(s).</span>

<span class="sd">        This function computes a composite approximation of the area per lipid by simply</span>
<span class="sd">        dividing lateral area of the simulation box by the number lipids in a specific</span>
<span class="sd">        leaflet.</span>

<span class="sd">        Args:</span>
<span class="sd">            leaflet (str, optional): A string designating which Leaflet to include in the computation.</span>
<span class="sd">                Default is &#39;both&#39;: the area per lipid is averaged over the two leaflets.</span>
<span class="sd">            group (str, optional): A string with the name of a specific LipidGroup to in the computation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: This is a nframesx4 numpy array (of floats) containing the</span>
<span class="sd">                results of this computation across all frames.</span>
<span class="sd">                apl_results[i,0] = simulation time for frame i.</span>
<span class="sd">                apl_results[i,1] = area per lipid at frame f = i.</span>
<span class="sd">                apl_results[i,2] = the current running time average (area per lipid) at frame f = i.</span>
<span class="sd">                apl_results[i,3] = the current standard deviation of the running time average at frame f = i.</span>
<span class="sd">                For i in range( nframes ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#diffusion dimension - assume lateral so, dim=2</span>
        <span class="c1">#dim=2</span>
        <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nlip</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;upper&#39;</span><span class="p">)</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
            <span class="n">nlip</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">nlip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">])))</span>

        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leaflet</span><span class="p">)</span>
            <span class="n">nlip</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leaflet</span><span class="p">)</span>
            <span class="n">nlip</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#unknown option--use default &quot;both&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">leaflet</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> from the &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="s2">&quot; leaflet&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#zi = self.norm</span>

        <span class="c1">#initialize a numpy array to hold the msd for the selection</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="c1">#initialize a running stats object to do the averaging</span>
        <span class="n">area_stat</span> <span class="o">=</span> <span class="n">RunningStats</span><span class="p">()</span>
        <span class="c1">#n_leaflet = len(do_leaflet)</span>

        <span class="c1">#loop over the frames</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">):</span>
            <span class="n">fr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">time</span>
            <span class="n">boxc</span><span class="o">=</span><span class="n">fr</span><span class="o">.</span><span class="n">box</span>
            <span class="n">boxc_xh</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="n">boxc_yh</span> <span class="o">=</span> <span class="n">boxc</span><span class="p">[</span><span class="n">yi</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="n">lat_area</span> <span class="o">=</span> <span class="n">boxc_xh</span><span class="o">*</span><span class="n">boxc_yh</span><span class="o">*</span><span class="mf">4.0</span>
            <span class="n">area_per_lip</span> <span class="o">=</span> <span class="n">lat_area</span><span class="o">/</span><span class="n">nlip</span>
            <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
                <span class="n">area_per_lip</span> <span class="o">=</span> <span class="p">(</span><span class="n">lat_area</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span> <span class="p">(</span><span class="n">nlip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">nlip</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">nlip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nlip</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

            <span class="n">area_stat</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">area_per_lip</span><span class="p">)</span>
            <span class="n">area_time_run</span> <span class="o">=</span> <span class="n">area_stat</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">area_time_run_dev</span> <span class="o">=</span> <span class="n">area_stat</span><span class="o">.</span><span class="n">deviation</span><span class="p">()</span>
            <span class="n">areas</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">dt</span>
            <span class="n">areas</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">area_per_lip</span>
            <span class="n">areas</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">area_time_run</span>
            <span class="n">areas</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">area_time_run_dev</span>
        <span class="k">return</span> <span class="n">areas</span></div>

    <span class="c1"># do Voronoi tesselation using the COMs as generators</span>
<div class="viewcode-block" id="COMTraj.voronoi_tesselate"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.voronoi_tesselate">[docs]</a>    <span class="k">def</span> <span class="nf">voronoi_tesselate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaflet</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#diffusion dimension - assume lateral so, dim=2</span>
        <span class="c1">#dim=2</span>
        <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#unknown option--use default &quot;both&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">leaflet</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> from the &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="s2">&quot; leaflet&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="c1">#print &quot;there are &quot;,len(indices),&quot; members&quot;</span>
        <span class="c1">#xi = self.plane[0]</span>
        <span class="c1">#yi = self.plane[1]</span>
        <span class="c1">#zi = self.norm</span>
        <span class="n">out_tess</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span>    <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">):</span>
            <span class="c1"># get the current frame</span>
            <span class="n">curr_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
            <span class="c1"># get the coordinates for the selection at this frame</span>
            <span class="n">com_curr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">com_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">]</span>
                <span class="n">com_curr</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">=</span><span class="n">com_i</span><span class="p">[:]</span>
                <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">vor</span> <span class="o">=</span> <span class="n">Voronoi</span><span class="p">(</span><span class="n">com_curr</span><span class="p">)</span>
            <span class="c1">#out_tess.append([com_curr[:,0],com_curr[:,1],vor])</span>
            <span class="n">out_tess</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_tess</span></div>

    <span class="c1"># do Delauny tesselation using the COMs as generators</span>
<div class="viewcode-block" id="COMTraj.delaunay_tesselate"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.delaunay_tesselate">[docs]</a>    <span class="k">def</span> <span class="nf">delaunay_tesselate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaflet</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#diffusion dimension - assume lateral so, dim=2</span>
        <span class="c1">#dim=2</span>
        <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#unknown option--use default &quot;both&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">leaflet</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> from the &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="s2">&quot; leaflet&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">out_tess</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span>    <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">):</span>
            <span class="c1"># get the current frame</span>
            <span class="n">curr_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
            <span class="c1"># get the coordinates for the selection at this frame</span>
            <span class="n">com_curr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">com_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">]</span>
                <span class="n">com_curr</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">=</span><span class="n">com_i</span><span class="p">[:]</span>
                <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">com_curr</span><span class="p">)</span>
            <span class="n">out_tess</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">com_curr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">com_curr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">tri</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">out_tess</span></div>


    <span class="c1"># generate the step vectors of the center of mass--in the lateral dimensions</span>
<div class="viewcode-block" id="COMTraj.step_vector"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.step_vector">[docs]</a>    <span class="k">def</span> <span class="nf">step_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaflet</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span><span class="n">fstart</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">fend</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">fstep</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">wrapped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">fstart</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">fstart</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span>
        <span class="k">if</span> <span class="n">fend</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fend</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span>
        <span class="k">if</span> <span class="n">fstep</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
            <span class="n">fstep</span> <span class="o">=</span> <span class="n">fend</span><span class="o">-</span><span class="n">fstart</span>
        <span class="c1">#diffusion dimension - assume lateral so, dim=2</span>
        <span class="c1">#dim=2</span>
        <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#unknown option--use default &quot;both&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">leaflet</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> from the &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="s2">&quot; leaflet&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">vec_ends_out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span>    <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fstart</span><span class="o">+</span><span class="n">fstep</span><span class="p">,</span><span class="n">fend</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">fstep</span><span class="p">):</span>
            <span class="n">fprev</span> <span class="o">=</span> <span class="n">f</span><span class="o">-</span><span class="n">fstep</span>
            <span class="c1"># get the current frame</span>
            <span class="n">curr_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
            <span class="n">prev_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">fprev</span><span class="p">]</span>
            <span class="c1"># get the coordinates for the selection at this frame</span>
            <span class="n">vec_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_com</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
            <span class="c1">#vec_ends = []</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">com_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">]</span>
                <span class="n">com_j</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">]</span>
                <span class="n">com_j_w</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">wrapped</span><span class="p">:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">com_j_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">com_j_w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">com_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vec_ends</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">com_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">#    vec_ends.append([com_j[0],com_j[0],com_i[0]-com_j[0],com_i[1]-com_j[1]])</span>
                <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">vec_ends_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vec_ends</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vec_ends_out</span></div>

    <span class="c1"># return the MemSys frame numbers associated with step vectors calculation</span>
<div class="viewcode-block" id="COMTraj.step_vector_frames"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.step_vector_frames">[docs]</a>    <span class="k">def</span> <span class="nf">step_vector_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fstart</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">fend</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">fstep</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>


        <span class="k">if</span> <span class="n">fstart</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">fstart</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span>
        <span class="k">if</span> <span class="n">fend</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fend</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span>
        <span class="k">if</span> <span class="n">fstep</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
            <span class="n">fstep</span> <span class="o">=</span> <span class="n">fend</span><span class="o">-</span><span class="n">fstart</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fstart</span><span class="o">+</span><span class="n">fstep</span><span class="p">,</span><span class="n">fend</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">fstep</span><span class="p">):</span>
            <span class="n">fprev</span> <span class="o">=</span> <span class="n">f</span><span class="o">-</span><span class="n">fstep</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">fprev</span><span class="p">,</span> <span class="n">f</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span></div>

    <span class="c1"># generate the step vectors of the center of mass</span>
<div class="viewcode-block" id="COMTraj.step_vector_colors"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.step_vector_colors">[docs]</a>    <span class="k">def</span> <span class="nf">step_vector_colors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaflet</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ngroups</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">group_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#diffusion dimension - assume lateral so, dim=2</span>
        <span class="c1">#dim=2</span>
        <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                <span class="n">curr_group_names</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">group</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">gname</span> <span class="ow">in</span> <span class="n">curr_group_names</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">gname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group_names</span><span class="p">:</span>
                            <span class="n">group_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gname</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">group_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="n">curr_group_names</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">group</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">gname</span> <span class="ow">in</span> <span class="n">curr_group_names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">gname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group_names</span><span class="p">:</span>
                        <span class="n">group_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="n">curr_group_names</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">group</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">gname</span> <span class="ow">in</span> <span class="n">curr_group_names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">gname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group_names</span><span class="p">:</span>
                        <span class="n">group_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#unknown option--use default &quot;both&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">leaflet</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> from the &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="s2">&quot; leaflet&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                <span class="n">curr_group_names</span> <span class="o">=</span> <span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_names</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">group</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">gname</span> <span class="ow">in</span> <span class="n">curr_group_names</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">gname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group_names</span><span class="p">:</span>
                            <span class="n">group_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gname</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">group_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="n">n_com</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">ngroups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_names</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">rainbow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ngroups</span><span class="p">))</span>
        <span class="c1">#build color map</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">group_names</span><span class="p">:</span>
            <span class="n">cmap</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">n</span><span class="o">+=</span><span class="mi">1</span>
        <span class="c1">#pick a frame-just use first frame</span>
        <span class="n">curr_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">colors_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">n_com</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
        <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">name_i</span> <span class="o">=</span> <span class="n">curr_frame</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
            <span class="n">colors_out</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">[</span><span class="n">name_i</span><span class="p">]</span>
            <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">colors_out</span><span class="p">,</span> <span class="n">cmap</span><span class="p">)</span></div>

<div class="viewcode-block" id="COMTraj.remove_leaflet_com_motion"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.remove_leaflet_com_motion">[docs]</a>    <span class="k">def</span> <span class="nf">remove_leaflet_com_motion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">leaflet</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove the independent center of mass (COM) motion of the Leaflets.</span>

<span class="sd">        Args:</span>
<span class="sd">            leaflet (str): A string designating which Leaflet to include.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">do_leaflet</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nlip</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;upper&#39;</span><span class="p">)</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
            <span class="n">nlip</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">nlip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">])))</span>

        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leaflet</span><span class="p">)</span>
            <span class="n">nlip</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leaflet</span><span class="p">)</span>
            <span class="n">nlip</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#unknown option--use default &quot;both&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">leaflet</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> from the &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="s2">&quot; leaflet&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;upper&#39;</span><span class="p">)</span>
            <span class="n">do_leaflet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
        <span class="n">leaf_indices</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
            <span class="n">leaf_indices</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span><span class="o">.</span><span class="n">get_member_indices</span><span class="p">())</span>


        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">):</span>
            <span class="n">fr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">do_leaflet</span><span class="p">:</span>
                <span class="n">indices</span><span class="o">=</span><span class="n">leaf_indices</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span>
                <span class="c1">#get the leaflet COM</span>
                <span class="n">lcom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">masst</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                    <span class="n">lcom</span><span class="o">+=</span><span class="p">(</span><span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="o">*</span><span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
                    <span class="n">masst</span><span class="o">+=</span><span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mass</span>
                <span class="n">lcom</span><span class="o">/=</span><span class="n">masst</span>
                <span class="n">lcom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                    <span class="n">fr</span><span class="o">.</span><span class="n">lipidcom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">com_unwrap</span><span class="o">-=</span><span class="n">lcom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">=</span><span class="n">fr</span>
        <span class="k">return</span></div>




    <span class="c1">############### multiprocessor parallelized versions of calculation member functions</span>

    <span class="c1"># parallelized version of calc_msd- using the multiprocessing module</span>
<div class="viewcode-block" id="COMTraj.calc_msd_parallel"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.calc_msd_parallel">[docs]</a>    <span class="k">def</span> <span class="nf">calc_msd_parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaflet</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span><span class="n">nprocs</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parallelized version of calc_msd</span>

<span class="sd">        This function allows the mean squared displacement (MSD) to be computed</span>
<span class="sd">        for a specified leaflet (&#39;upper&#39;, &#39;lower&#39;, or &#39;both&#39;) and for a specified LipidGroup within the</span>
<span class="sd">        chosen Leaflet. This calculation is over the whole trajectory and assumes the first frame is the</span>
<span class="sd">        reference frame for computing the displacement. The calculation is parallized over the</span>
<span class="sd">        number of frames in the trejectory using the multiprocessor module.</span>

<span class="sd">        Args:</span>
<span class="sd">            leaflet (str): A string designating which Leaflet to include in the computation.</span>
<span class="sd">            group (str): A string with the name of a specific LipidGroup to in the computation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: This is a nframesx2 numpy array (of floats) containing the</span>
<span class="sd">                results of the MSD computation across all frames.</span>
<span class="sd">                msd_results[i,0] = simulation time for frame i.</span>
<span class="sd">                msd_results[i,1] = the configurational average MSD over the specified LipidGroup for frame f = i.</span>
<span class="sd">                For i in range( nframes ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#diffusion dimension - assume lateral so, dim=2</span>
        <span class="c1">#dim=2</span>
        <span class="k">if</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">leaflet</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflet</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#unknown option--use default &quot;both&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! Warning - request for unknown leaflet name </span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">leaflet</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2"> from the &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="s2">&quot; leaflet&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!! the options are </span><span class="se">\&quot;</span><span class="s2">upper</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">lower</span><span class="se">\&quot;</span><span class="s2">, or </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">--using the default </span><span class="se">\&quot;</span><span class="s2">both</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">leaflets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">:</span>
                <span class="n">curr_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">[</span><span class="n">leaflets</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">+=</span><span class="n">curr_leaf</span><span class="o">.</span><span class="n">get_group_indices</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="c1">#n_com = len(indices)</span>

        <span class="n">frame_ranges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span>
        <span class="n">frames_per_proc_base</span> <span class="o">=</span> <span class="n">total_frames</span><span class="o">/</span><span class="n">nprocs</span>
        <span class="n">left_over</span> <span class="o">=</span> <span class="n">total_frames</span> <span class="o">%</span> <span class="p">(</span><span class="n">frames_per_proc_base</span> <span class="o">*</span> <span class="n">nprocs</span><span class="p">)</span>
        <span class="c1">#assign base ranges</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprocs</span><span class="p">):</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">frames_per_proc_base</span>
            <span class="n">fe</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">+</span> <span class="n">frames_per_proc_base</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">frame_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">fs</span><span class="p">,</span><span class="n">fe</span><span class="p">])</span>

        <span class="c1">#now adjust for leftovers - divide them &quot;equally&quot; over the processes</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="n">left_over</span>
        <span class="k">while</span> <span class="n">lo</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprocs</span><span class="p">):</span>
                <span class="n">frame_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nprocs</span><span class="p">):</span>
                    <span class="n">frame_ranges</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="n">frame_ranges</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">lo</span><span class="o">-=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">lo</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="c1">#initialize a numpy array to hold the msd for the selection</span>
        <span class="n">msd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1">#</span>
        <span class="n">loc_msd_frames</span> <span class="o">=</span> <span class="n">msd_frames</span>
        <span class="c1">#frames_local = getattr(self, &#39;frame&#39;)</span>
        <span class="c1">#shelf_local = shelve.open(self.frame.fs_name,flag=&quot;r&quot;, protocol=2)</span>
        <span class="n">frames_local</span> <span class="o">=</span> <span class="n">ParFrames</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">fs_name</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">frame_shelf</span><span class="p">)</span>
        <span class="c1">#frames_local = ParFrames(self.frame.nframes,self.frame.fs_name)</span>
        <span class="c1">#frames_local = ParFrames(self.frame.nframes,self.frame.fs_name,shelf_local)</span>
        <span class="n">plane_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span>
        <span class="c1">#create process pool</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">nprocs</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">loc_msd_frames</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">frames_local</span><span class="p">,</span><span class="n">frame_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">frame_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">indices</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">plane_local</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nprocs</span><span class="p">)]</span>

        <span class="n">results_ordered</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>

<span class="c1">#        #collect results  into single array for return</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">results_ordered</span><span class="p">:</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">frame_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fe</span> <span class="o">=</span> <span class="n">frame_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">#print fs, fe</span>
            <span class="c1">#print msd[fs:(fe+1)].shape</span>
            <span class="c1">#print p[:].shape</span>
            <span class="n">msd</span><span class="p">[</span><span class="n">fs</span><span class="p">:(</span><span class="n">fe</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:]</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">msd</span></div>
    <span class="c1">#function to compute the thickness of the membrane (in the normal direction). The algorithm is based on</span>
    <span class="c1"># the GridMAT-MD bilayer thickness calculation (except without the gridding procedure)</span>
<div class="viewcode-block" id="COMTraj.calc_membrane_thickness_parallel"><a class="viewcode-back" href="../../../pybilt.com_trajectory.html#pybilt.com_trajectory.COMTraj.COMTraj.calc_membrane_thickness_parallel">[docs]</a>    <span class="k">def</span> <span class="nf">calc_membrane_thickness_parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nprocs</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parallelized version of MemSys.CalcMembraneThickness</span>

<span class="sd">        Computes the thickness of the bilayer (along the normal direction) across the trajectory.</span>
<span class="sd">        The algorithm is based on the GridMAT-MD bilayer thickness calculation. The calculation is</span>
<span class="sd">        parallized over the number of frames in the trejectory using the multiprocessor module.</span>
<span class="sd">        This function passes the thickness_frames fucntion to the multiprocessor threads.</span>

<span class="sd">        Args:</span>
<span class="sd">            nprocs (int): The number processors (threads) to use in the computation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple of numpy.array: This is a two element tuple containing numpy arrays of the computation results.</span>
<span class="sd">                tuple[0] =&gt; thickness: A nx5 numpy array containing the</span>
<span class="sd">                results of the thickness computation for the specified frames. Specifically:</span>
<span class="sd">                    thickness[i,0] = simulation time for frame f = i + fstart.</span>
<span class="sd">                    thickness[i,1] = the configurational average thickness for frame f = i + fstart.</span>
<span class="sd">                    thickness[i,2] = the standard deviation of the configurational average thickness for frame f = i + fstart.</span>
<span class="sd">                    thickness[i,3] = the running time average of the configurational average thickness for frame f = i + fstart.</span>
<span class="sd">                    thickness[i,4] = the running standard deviation of the time averaged configurational average thickness for frame f = i + fstart.</span>
<span class="sd">                    For i in range( (fend-fstar) + 1).</span>
<span class="sd">                tuple[1] =&gt; thickness_map: A nxNx6 numpy array containing the thickness data that can be</span>
<span class="sd">                used to generate a 3d thickness map/plot. Specifically:</span>
<span class="sd">                    thickness[i,j,0] = simulation time for frame f = i + fstart and lipid j.</span>
<span class="sd">                    thickness[i,j,1] = the average x position for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                    thickness[i,j,2] = the average y position for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                    thickness[i,j,3] = the lower z position for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                    thickness[i,j,4] = the upper z position for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                    thickness[i,j,5] = the difference between the upper and lower z positions</span>
<span class="sd">                    for lipid j and its cross leaflet partner at frame f = i + fstart.</span>
<span class="sd">                    For i in range((fend-fstar) + 1) and For j in range(nlipids).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nlip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlipids</span>
        <span class="n">zdists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">zmaps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlipids</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">frame_ranges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nframes</span>
        <span class="n">frames_per_proc_base</span> <span class="o">=</span> <span class="n">total_frames</span><span class="o">/</span><span class="n">nprocs</span>
        <span class="n">left_over</span> <span class="o">=</span> <span class="n">total_frames</span> <span class="o">%</span> <span class="p">(</span><span class="n">frames_per_proc_base</span> <span class="o">*</span> <span class="n">nprocs</span><span class="p">)</span>
<span class="c1">#        print &quot;total frames &quot;,total_frames</span>
<span class="c1">#        print &quot;frames per proc &quot;,frames_per_proc_base</span>
<span class="c1">#        print &quot;left over &quot;,left_over</span>
        <span class="c1">#assign base ranges</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprocs</span><span class="p">):</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">frames_per_proc_base</span>
            <span class="n">fe</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">+</span> <span class="n">frames_per_proc_base</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">frame_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">fs</span><span class="p">,</span><span class="n">fe</span><span class="p">])</span>
<span class="c1">#        print &quot;frame_ranges (pre-adjust):&quot;</span>
<span class="c1">#        print frame_ranges</span>
        <span class="c1">#now adjust for leftovers - divide them &quot;equally&quot; over the processes</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="n">left_over</span>
        <span class="k">while</span> <span class="n">lo</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprocs</span><span class="p">):</span>
                <span class="n">frame_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nprocs</span><span class="p">):</span>
                    <span class="n">frame_ranges</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="n">frame_ranges</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">lo</span><span class="o">-=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">lo</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>

<span class="c1">#        print &quot;nprocs &quot;,nprocs</span>
<span class="c1">#        print &quot;frame_ranges (post adjust): &quot;</span>
<span class="c1">#        print frame_ranges</span>
<span class="c1">#</span>
        <span class="n">thick_frames</span> <span class="o">=</span> <span class="n">thickness_frames</span>
        <span class="n">frames_local</span> <span class="o">=</span> <span class="n">ParFrames</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">fs_name</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">frame_shelf</span><span class="p">)</span>
        <span class="n">plane_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span>
        <span class="n">norm_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span>
        <span class="c1">#create process pool</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">nprocs</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">thick_frames</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">frames_local</span><span class="p">,</span><span class="n">frame_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">frame_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">leaflets</span><span class="p">,</span><span class="n">nlip</span><span class="p">,</span><span class="n">plane_local</span><span class="p">,</span><span class="n">norm_local</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nprocs</span><span class="p">)]</span>
        <span class="c1">#print &quot;results:&quot;</span>
    <span class="c1">#    print results</span>
        <span class="c1">#print &quot;len(results) &quot;,len(results)</span>
        <span class="n">results_ordered</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
        <span class="c1">#print &quot;results ordered: &quot;</span>
    <span class="c1">#    print results_ordered</span>
<span class="c1">#        #collect results  into single array for return</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1">#print &quot;len(results_ordered) &quot;,len(results_ordered)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">results_ordered</span><span class="p">:</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">frame_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fe</span> <span class="o">=</span> <span class="n">frame_ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">fe</span><span class="p">)</span>
            <span class="c1">#print msd[fs:(fe+1)].shape</span>
            <span class="c1">#print p[:].shape</span>
            <span class="n">zdistf</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">zmapf</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">#print zdistf.shape,&quot; &quot;,zmapf.shape</span>
            <span class="n">zdists</span><span class="p">[</span><span class="n">fs</span><span class="p">:(</span><span class="n">fe</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">zdistf</span><span class="p">[:]</span>
            <span class="n">zmaps</span><span class="p">[</span><span class="n">fs</span><span class="p">:(</span><span class="n">fe</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">zmapf</span><span class="p">[:]</span>
            <span class="c1">#zdists[fs:(fe+1)] = pg[:]</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="c1">#regenerate the container</span>
        <span class="n">zdist_tavg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nframes</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="c1"># get the running time average</span>
        <span class="n">tavg_dz</span> <span class="o">=</span> <span class="n">gen_running_average</span><span class="p">(</span><span class="n">zdists</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">#slice together the values</span>
        <span class="n">zdist_tavg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">zdists</span><span class="p">[:,:]</span>
        <span class="n">zdist_tavg</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="n">tavg_dz</span><span class="p">[:,:]</span>


        <span class="c1">#shelf_local.close()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">zdist_tavg</span><span class="p">,</span> <span class="n">zmaps</span><span class="p">)</span></div></div>
        <span class="c1">#return zdist_tavg</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Blake A. Wilson.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>